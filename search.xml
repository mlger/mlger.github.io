<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计组01-计算机系统概述</title>
      <link href="/2023/09/08/%E8%AE%A1%E7%BB%8401-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/09/08/%E8%AE%A1%E7%BB%8401-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><ul><li>何为计算机：计算机是指“<strong>通用电子计算机</strong>”<ul><li>通用：不是专用设备</li><li>电子：采用电子元器件</li><li>数字：信息采用数字化形式表示</li></ul></li><li>计算机系统：硬件和软件</li><li>何为计算机“<strong>组织</strong>”：操作单元及其互联连接<ul><li>对编程人员不可见</li><li>包括：控制信号，存储技术等</li></ul></li><li>何为计算机”<strong>结构</strong>“：直接影响逻辑程序执行的属性<ul><li>对编程人员可见</li><li>包括：指令集，表示数据类型的位数等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202309081604546.png" alt=""></p><ul><li><p><strong>指令集体系结构</strong>： <strong>ISA</strong> ，有时称为<strong>指令系统</strong>。 ISA 是一种规约，规定如何使用硬件。</p><ul><li>可执行指令的集合，包含指令格式、操作种类及操作数的规定</li><li>指令可以接受的操作数类型</li><li>操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、长度和用途</li><li>操作数所能存放的<strong>存储空间的大小和编址方式</strong></li><li>操作数在存储空间存放时按照<strong>大端还是小端方式存放</strong></li><li>指令获取操作数的方式，即<strong>寻址方式</strong></li><li>指令执行过程的控制方式，包括<strong>程序计数器（PC）、条件码定义</strong>等</li></ul></li><li><p>ISA 与组成之间的关系：计算机组成必须能够<strong>实现 ISA 规定的功能</strong>，如提供 GPR 、标志、运算电路等，<strong>一种 ISA 可以有不同的计算机组成</strong>。</p></li></ul><h4 id="1-2-计算机简史"><a href="#1-2-计算机简史" class="headerlink" title="1.2 计算机简史"></a>1.2 计算机简史</h4><h5 id="1-2-1-第一代：真空管"><a href="#1-2-1-第一代：真空管" class="headerlink" title="1.2.1 第一代：真空管"></a>1.2.1 第一代：真空管</h5><ul><li>ENIAC ：第一台<strong>通用</strong>计算机，十进制，手动编程</li><li>ABC ：第一台<strong>电子</strong>计算机，不可编程</li><li>EDVAC ：冯·诺伊曼架构（普林斯顿架构）<ul><li>三个基本原则：<ul><li>二进制</li><li>存储程序</li><li>5个组成部分<ul><li>主存储器：地址和存储内容</li><li>算术逻辑单元 / 处理单元：执行信息处理</li><li>程序控制单元 / 控制单元：指挥信息处理</li><li>输入设备</li><li>输出设备</li></ul></li></ul></li></ul></li></ul><h5 id="1-2-2-第二代：晶体管"><a href="#1-2-2-第二代：晶体管" class="headerlink" title="1.2.2 第二代：晶体管"></a>1.2.2 第二代：晶体管</h5><ul><li>体积更小、更便宜、发热更少</li><li>使用高级语言编程，并为计算机提供了系统软件</li></ul><h5 id="1-2-3-第三代：中小规模集成电路"><a href="#1-2-3-第三代：中小规模集成电路" class="headerlink" title="1.2.3 第三代：中小规模集成电路"></a>1.2.3 第三代：中小规模集成电路</h5><h5 id="1-2-4-第四代：（超）大规模集成电路"><a href="#1-2-4-第四代：（超）大规模集成电路" class="headerlink" title="1.2.4 第四代：（超）大规模集成电路"></a>1.2.4 第四代：（超）大规模集成电路</h5><ul><li><p>思想：</p><ul><li>将整个电路安装在很小的硅片上，而不是用分立元件搭成的等价电路</li><li>晶体管可以通过金属化相互连接，形成电路</li></ul></li><li><ul><li></li></ul></li></ul><h4 id="1-3-计算机发展"><a href="#1-3-计算机发展" class="headerlink" title="1.3 计算机发展"></a>1.3 计算机发展</h4><h5 id="1-3-1-摩尔定律"><a href="#1-3-1-摩尔定律" class="headerlink" title="1.3.1 摩尔定律"></a>1.3.1 摩尔定律</h5><ul><li>价格不变时，单芯片上所能包含的晶体管数量每年翻一番 (1965-1969) / 1970年起减慢为每18个月翻一番</li><li>影响：<ul><li>更小尺寸带来更多<strong>灵活性</strong>与<strong>可能性</strong></li><li>成本下降</li><li><strong>减小电能损耗与冷却要求</strong></li><li><strong>芯片间连接更少</strong>，更可靠</li></ul></li></ul><h4 id="1-4-计算机性能"><a href="#1-4-计算机性能" class="headerlink" title="1.4 计算机性能"></a>1.4 计算机性能</h4><h5 id="1-4-1-CPU-性能"><a href="#1-4-1-CPU-性能" class="headerlink" title="1.4.1 CPU 性能"></a>1.4.1 CPU 性能</h5><ul><li>计算机设计主要目标：提升 CPU 性能</li><li>系统时钟<ul><li>时钟频率： 1s 内执行基本操作的次数</li><li>始终周期：执行每次最基本操作的时间</li></ul></li><li>指令执行： <script type="math/tex">CPI_i</script> 表示第 <script type="math/tex">i</script> 种指令需要周期数， <script type="math/tex">I_i</script> 表示第 <script type="math/tex">i</script> 类指令条数，则有</li></ul><script type="math/tex; mode=display">CPI=\frac{\sum_{i=1}^n(CPI_i \times I_i)}{I_c},I_c=\sum_{i=1}^n I_i</script><p>​    执行一个程序的处理时间表示为</p><script type="math/tex; mode=display">T=I_c\times CPI \times t</script><ul><li>每秒百万条指令（ MIPS ）：</li></ul><script type="math/tex; mode=display">MIPS = \frac{I_c}{T\times 10^6}=\frac{f}{CPI\times 10^6}</script><ul><li>每秒百万条浮点操作（ MFLOPS ）：</li></ul><script type="math/tex; mode=display">MFLOPS=\frac{N_{floating-point\ op}}{T\times 10^6}</script><h5 id="1-4-2-性能设计的基本原则"><a href="#1-4-2-性能设计的基本原则" class="headerlink" title="1.4.2 性能设计的基本原则"></a>1.4.2 性能设计的基本原则</h5><ul><li><strong>大概率事件优先原则</strong>：对于大概率事件，赋予优先的处理权与资源使用权。</li></ul><script type="math/tex; mode=display">系统加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}</script><ul><li><strong>Amdahl</strong> 定律：<ul><li>部件系统加速比受限于其在系统中所占重要性比例。</li><li>性能增加的递减规则：改进越，系统获得效果越小</li></ul></li></ul><script type="math/tex; mode=display">系统加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}=\frac{1}{(1-局部占比)+\frac{局部占比}{提升的性能}}</script>]]></content>
      
      
      <categories>
          
          <category> 计组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络01</title>
      <link href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3c07b1faa1a69ebd1f46fb3a684f7179ab7b41f3b924306beba30c17ad0a3638">8df0c2fb6c575594294cbfe72329b39391de17c75992aa7b56f3b557dca9fdcd01c8bfb1e095f4c2875fadc647e91d760f0a905b5cc1c6f96ca4e496c05dc3040986e725727fd6486a906fae057a62790bcebb6edb419ae1255ed825cf2c55f86e88527c1ac85846504ff37e55ae39d26aabc5f6197473e7f184361260a14fda655f49b59210fca9b835d7c75a3f36c6af37844b5c04dd1285c547462bceadcb4af2e03b381ef32ea9ae561b56fe8397a4eb01836e3c07bf27844f63805ee9179d96505b55586658fc025191ad103c82417006d0483a26a6fff4d382e387dbcdc31d8d6b7ceb3831565ec6228b6b193a9589af58acf05d693ec378081baa5b29008f0eb6961fbe12f511e8a9737912bd5db89a906b63ecf34a85e0f11d9ddd1994443ee84af18e0674a614f7968a0a903fe81aa33b5ab51dd16539c2e9ba7e36d08b8790b77abd83114e95d2445d8889a33dfa530ec6109feea19f47764b40f5d725c54aa4150df5834a971646856823eaa24fab784faa53ce3e0f97300dd97c91835d7c430879250a9bfda69ff46d964817b1d77bdb46be0a3942fc3e933869188386ce0bf04fcd8452395925d6fb3de6620768b7d20c31e492ab766b7f9da4d61ec6f95697e3b4289c90fe82b29431f58be7541e50d26bae044f360488ee6a877388184dcf93a29737135d3adbd6cf337ec4b85fd212a0b51dd82432601dfebabc9d6fe9783a6031ffd6beb079599f0ccd274f456e88dfae82b34f3516adb0e6ad9eb2922925cffccd6b8be951a13cb346b4376325f2d28c58eed8a17674943fb0ca60d2d38a08d1e7c5f97b722ccca7c726e24326ae92aed9ed236762af532788937f346e9971a6748bf15595de1a6a61d2a93926a0cece4e610cd799ec46f55b917331bf8d9b643c7c9e220c7e206c2bc9820dfa414562c95d3537385f7cc5f6a79c1a8e4cb1e8f236cd82a41fdc9080704393f5855c4f9955dbcc2d7a4d1591e427d546dd01555c57246f3e702a58be1999b470a5319792e860da642a65dcde8c13466cd9e16f9b04438f6b1ed88c68989947ad0b77a1f24a385b3fbe889dbb60700567a4a7075d6d2f7448dcd395d817b2790aae1c84d8c163d5df393e12dbc6a68e1b6c0558f14db27e78c628347681848b3227a07df7e84427516256b2ba0c19129d9542b6b3972430f835f5f06d559f6f59b6c6c61beb26f6060594e84724ae3da59164b489b1f42a4e1357ab1a5b8d563a23689d015389866b4333b4fa173861f2c437d51ef0f623288f7dd590e5a830ba4fbb9c966e02eba327249cc0b8fbe8fff9dab37cd9b64a1cf02a39dfb59618a59ebf8a4b7f4e50af94b68db7feb012040dc7729cd13304e330729f2202d21641be53c0b73c39de4a037975077602bc822990d8d758ba2daf6151980d5a91cdfa9c39ac77c3e6fa864693197392ba4e272d0ca4c976074b63a5f17e7375a3309a5e6934f3edef2405b260ea18b20502194f9df9e1b4cbb8a8c3feb7371f84e0eacfd0a9e4fcd455491d3755c1e7886dac101b3dfe6d4308b3839b2f75d7e0132dd2087566bab47721d6b9db41a271e39ee3e34bb0c2e3754593e2e7d4cbfeb244ac31dc23774a39491d024c4506bed9270a90a5f1da3aa3403b5cde1ccf8d3a84ab7b029190a1175289895d438d9f45890b1998eb37ebced7ac877027b95adb31bd0e0abe510babf5c1b48984e491bb5052ba064a1b711d56372dcdbf72424dc5f8c986fa3050141e2474ce4743e9775ca7692a8cc083f16cc55d32fa502c739a76fbac4bc24ae10109d3d556ea900f5678778ab3dcc5a71b179ede49b3768471afd1389e0d7a528908bc7dd0220aaffb3e5238c5c3027618ab8ff808e255f7bd234070143beebe41a885af839620f53c845fd324fcd10a9b7a8778c6e7201b3dbf408bcd478e7a0af1351333d4c2a4c0d16808f6652429e75b5556cf78aeb91aca36eb2293b7d7b3db467c06aa3713e0bffa36cdf2b5fa9fdfe4478113c32f899f82cc072be04e5436b54754f57b50adab817190dfb8eb51bb2de34c972a506b9d1c67cb3d21acb3bb0d9b0e40b03aa35682dd84ec6ded8edc81a6636af1fefb5cfe58d10d35b6954febd73e488c8314e0ced78c073b1e359c3249d641b392e9ac1f03247a32a19174f082f256f6e272f543342db378030e40b76618b583407bcb5cb5af20d06a04389a65cdb949c93eda9c1e14151e6abe6e3ddb5390cdad05dba6448b58f6aea0aa750a3b00c22ec0aebbc68c2c37e9c218ecb9c2e543246ad5c056547807ac24e68ce29cb94bb3d96be887b6faf1cd68a970f413a81aded5cbbf234edfae38d95e38c621c2611357fc4991d85dac3c542d726f384fef4592f9d154d4fe995391a27fd976e374af43a0302ed9e3d05099eb7f0acd882c07b93a804747864e4e02460d2e979e6f6dd39bdd95452bee33e3a7cf3536d6d5b35cacfdb01e1b134f6a87925ee54d5d53b70734c04bc9f8d37ccb71fd281c8e58c9e2a14d74413ac484ebc64aada986fae00e60e23e21ecc41fc899b0b1790e1f0616d42aeda97861b3ffd4d5f92b85f11d65c2fc66d5ec6e9bd1144228c9177077f3583dd54023e0fdc2df5827699fa1a5ff36d7d85c6b56dea45ade777c89ef25248d3d36f2885d2fef08a296383b8f2c0b4dd9ef5e0a062cece27f07b2d0b578e6bf7ff27754ffd89d396b6c004f93973ce708a2e4672bec6b4f1005077c764f5ad554ae699896e1854b47b0a9dc860f11eac11e639ec9192ae953264f1f79b25a963bd968366addce08732a9d7043995e9e1eecbbbb6e731e0c1bebee64946d4afafef16aeb29d5fad241fe1e016951500111d07c0aa6365a39f08139518b177406e5b21a57f7c9c3118a28be351fb15c8941c57750ca65377b8c9b60986f14f959077a249d004a7a7c9f559d0640248be771ae3dd1ed0c765323baec9bec4df441bed6ea05c758be5556548df78ff99f1e9cc778a7929afc9babc06b546dd174fa4c965d792f24089393971f4efc2a2091c8359d63e64145bbea2c17c878824966a448a48d39dc8fdc31c6a5aab75d33b3c9e332bafbe589e3ab371bda0562eae09f58701c8c9ed9a71c590751c70cfc68e7970d062bc754434f6fc0d1f76965ee07a082518ee501b2f82e486791161559b09e778251b4ecddc782842a12f1cf500168a8ea8c9c75f547a4e11ebe9584089ce4f9ad522a5317eae690d4d52b5236e7fa5f1636379b865e1d8776f60ce07387edf3536b34ed68562460f113c6bdcc74fbe031849e71ca963e5a7b6da2542302ce6d4946ff9cc3ed03d6db1b19bad066e16386df33cbd446c5e8785fd8e847b3acdc81ccf89fff6071d401c2dbdabdb9d4cf492553834fa34c85b58b26bd95711deb481f998d54dfafccf82dbbe25436dcfde1ae326a5ad5f9464b227942689edf621f3add68514d3028d5510879ff90d7e77cdfe1640366e6e70fa0dad71da947c07855f11465795198b71a48a10d86bc36994d2dff1f720aee065f3e0e5798a8bad89ee8d7e91990737ba0c4460fbaa37c62ad939df030c3d66ef8db5f967fa888f60cfd3cb0c9f07117695a9e89e6251b81c21d7a55db8edd965330a345e83add205d99b98bd000dd34db015244c9e788bdc4d2539a4365af57f83dc9d4463969351b30ea474e32ad6112939655a268c6afe7b0b3a665cf1869c329f66638d120075602705f0b98b572bbfc7584c8dca232af79aa05ac97fdc1a7af54941f24bded1bafcbc0f117791adda818fa03ae05244c81e94f5555695060e30499b89ee02aed3ee8da5a1a5894681ef4d43847772eba167c1edd0d6104b1715097f3a15f2e11310747a8883b299d23a8ee112e20b4160b7ec960b8fd02835538532172ec86e53289ba8c101eed8fb76a51dcd5f793b858318270032dd9776d75236f4b160b1a84eae7dc37e293540d9acca3fef520782d29947ba00b32662c668b21816bac229318411baa30e1f871c54e4686a1c765364ca029064aa43482094b8e36f99635c738ca5f724933adc03e97718d58a9d55ed8b76b493a50bb9f3480867793d950f0ea628d81403a6258cf50f0f646178d26ac6155ea97fedc607ef7181bf22bf3f6e033ede68f6d637c85374ce7852b3f43d07017d92e4259654367d212650c1818e9a6e3098cc8d825ec2dc767df13150f5466e77f4e29451ca0a5cf1f206cab9b79f674d252bf0890866230bbc75e736eaff77e0bb3bcabfc4d6dab45a059804b5a603df19629f123552e6b2a6038783c5a193e5a4c114ba809e4dc875fc96d52869cde3ba544f620c836720fb7ebf36e4ab2cd0ebe95416fc13f07a964715993787f37bd9b8f05a03a4fec9253654a71aefb3c624f0560c9d4bbe0bffdb95147c9ed6889906478b9c6f44ff1fd486c480cc1ba5efb0587c2f7b3a5d67744713cfaf3d590ad02c84c5cedcf61660aeb466558691e3e630a6be606c7baa3dfd4e7b25fb3f0039110a14a7a23b80018b85166c928c092d4f7608e07d747e5bd343702e9ed7486142265657a3f0b6f6338ef7b275d37e035d08d97aaf954aa662eba25e1fbee558503b810dc79088e46d54b4be33510311e10af7018db7ee0f6561d7cf94e6813ccf5eb0192f2af0c293f43f8dac6deeba8450718bc3c0c842e089dce457fffc4cf6dcec59d1135e27e0e8a52e812082ad9ac5a457c90776f9a35aacb6ed54ee3e216d71053b8088590d34925cdd1fc075d3b65f3002abda35eb89e087b163d780874dcde712c70c4857e510ce3b76634cbf4c649cc43beec5941c203871f31d66bd3a1f9ee286b371b4b33b3574e275a539a741b7c9f47809a58d890abde8dadc6b263f093f5c13e898fa447e58334f59252b847748dc8c0637cbf2738724968f9d776f4a055e4a35d703fae45f4825e1415db82a987b478c6bb18110f9e3d27f848ca2e61824caf1187c4ca5ae91785febfbbb28f5906ad2ef468f036102877faa0b84256f5703b5e360d733982b44fa781687c38d905934d5fdf6c332bc2a477a6042f8335ac392ca97c2d235cd6d17bf20e5e2fecc5be3332a991e66dab632109ef6fa733413e0e24a79e34538bbd0ad90572ae2e4ffd77cfbaa0ac8d2074d0357c08d527f00d07917f84f45e27c8219fb6496e81762b83a7a95e9be4512744bd8b01f2e97502faf876d667dcb742c63cd55528d69d15d42f26db4063eb0dec310048e87469aa28cd57b5df7d213bb6ea2c82f7497ba96f461391fbe4f008eb43ef1900929c490e814259ffb267ac82379b2379a78c834f8f81b714783e2a5d8fed930e89286757bc91e89cb252f3bc076675956059338cb8a48872cc77ad620e8dd36aa7223859da72d9766c9abafc87e5b955262b703b948b1dc7bd6cc054f9c2903797c7e3cc6926c13b3eaafc323b348f5b97b6154e0fcd22c8c003f1f9b518575974033e25698110e2acfd2becbf1e1b88839ad89a66c98553006456fbaa81b895df765ca6219f8837b4aeefe60929ac54fd7cd5a9a3d480b8c402abb0f25118fe3d87c502b8baa7550a6b69a2afd541885b92f9aa8fb65f78274e7989a0c3f7525cd928d023bfac32390245c699de209df187334e1cd23baa5550578e64327a210c1c89fd4cb07a27068edb36be04807d32d42e0d8fd19b335b50350864abbad3c75ae26d5306cc328ffa90d2645a6d8130e098bf0a147f0865900d9c43c5ac6d57459bb93cab335cf8e990dfaae23f252cd1b47fd4b268bd6cf94639d872e6d92359c0c53bb038ff192041b7da9aab86cbf280387bb3795ceff5444bb36e07063d1696496159454aa1a2eea266937a0d593de38dcdc49c06d2afeaff6515640425bb48ee1d768e273418a55fa592c920d0490429bb4c66af04ef770d50a565619e842891cb84a9e983c8a6e65d1a349d4f5f77634625fafcaaac0bf0e34eddb53b965fab7b6d781baf10b426aebda9946f15fc856cf9975e8a70866fa387fed599f0f3d73948a87168d0b4146b8a9004ea0e5ff27c4c2887044938a4aea1769c39b3af826df3dd3d4db3aacaa5c5a0ac040b242b8b132000c54d47d235cc785378c658954fe9454e7740150feaf2c2618ae837a7ecb4066f0ad037e5d6de3514341e4a2878325c6bbc8c8d0541666bce3b182632be79045948351cd4c21fffc7ba55f50cd345bc216783facfb7a1b6397c6bed87cdb708356e03389e5e1affc8543d5f03dfa42ffadfcdd5bc1bd2045913a5c63651aa073855fb0675656130b450f454e1dad0a36a87db8c93ad33b29333dc2c6b959de7d7773e7c5083b4c727874771100221640a7fdfab170aaad1d0058e78fc30e6ebe98ea90e75f800bd143ae702f54f690f40ef3ec94846edffc064ad74b7304baa31c20e61fbdb211275c9bc9600de779f37ae2b2a287ea74d1faf24b59c4fccc0dc80945a324f38503b45265428eca83d47d6f661bae8364fa0ff7fa47fc192eb8f0b51deca94f670ce1fefe6f11207a54aa1d4137f580aa9141d5682f94dd09e01f4dbe6def9f7890bc1a2b7045c46dceab9ec1d41844284a207d187908e05c3ecb39ea43f37aec8001a38dddd567d1cc33a2e46286805c0d8fa629dc65425a0cea8b4ee176e3d380c20418c8aff5232c1f7be108d0e1fbb473e1ca294e9ae219d9580db47d57a9da1a5cb2d81d35b2c53aae0c1a1cb81ccdd1064f423a7e67e2534d9097042cad3402556b17cc2fda4c20deec875fe14d7bfb42a7e790ace882d1646af5e43e6bd0bd0e0d60656c37bd39a5ffbc15c0335110ebba16e1b7c448a2e28f44ae0a91b49fdc54ec1b3852e0d03c8737a2628fcf4bed218454e14bc3b12261dfceee602bb0d8f59850a713850a55079ef8579daf150761c5b30b96f9e4394e314565fb2ae1e7c45c5c17fcb8fbd6749414a3f363a603f9ca46d0d566a29063409e6fd517395de24352911f2f3be983fbb5225313a90b7938eaeec5d796ed0a2a70ef2c93e5ebdc9fea540be59865034b0502bb9f79f5ab6a52df21f76e636d7d063c496e2905c006605b81479abe8bcd448ccfdbb0ec2d3beca6069ac6a3d8689376db7716c1bfff52aef97a8801ce40b0e8fd7326214881b76c3ca2169b705158e0aaf1dc216d61c116f9f80069454c29aedd97d4977f1854bbfaa1ee9df71e4779a5a21fc03aa3000e0fc3e57d633bb229cd508f33abbe784ea354d9824c37fe1695eea109d52c3a6a2f9e77116ab7f5058265cb5486421c303c95413b51b3e0b73ada499cea6f2a34b2bf737c4e476e310e5a24cab20d79fafb083e71a7cbf40b31189cc719eddc5733b33c94a0058f29fa8537a7ad47baa4e9f30f7c756584660af15a6bd5b0c3ef1d97c59f3ae5c04e3a3f4391937c4069e8becf32841cd362dbce207233b0377c2fd04d7c82b9c286669c09f9f80542cca7e55b92ab18eee1f82b6444a211ae5e4f007d1bc7de3de31b38c0c0108a5c769feba66b621aba091cd7a54437bf69d98952bddb65dfb35c215e3158994c3e81cb7b2e9cb2fc8442424ce7b72a6458fa22dd724e0c4d65b1b5f49840d5be80e277bb6146ad6fbbc27fe7923c6f03afb626c235a8eacd175c546d68548fd7b0facfa65c359011857f2ca6731b46c3d5dc771ff8aa57bf62f0bc37779924f9bb7f1e1e9c6ee86706156f6c3c9d228d7fb342dcc9efa8541ae526cb925ac8b91a5d9d704c0404cf6e9a63ff4be2d928f136042880cb6861d0d5daf0d3de15df308f4fc5e4c0f7edf133374dcd6fa4a4305178e1ff2afa422bb81b4910fd3c961897533b8d12004a826acbb7af4c3890672c62b3dee9a2db198c5372ba4e80c4a58c74ae7c99c3e56245bf4e48fe2b5837dc4cbd15e1ca0f0306a8c439aa4f4651e454e4c6a1260c73b96cd6dd72e61a52f034d4f6a7a45092e79980ae21825df1e394aad23e5b6c0adfc646be243ae386a992b97d5a37d08c0afd03fb7e4008ac857421617a5d4d174c3fb90c2922b139d73d8590c4784cbc6fd5ba0d833942f7a3ae664543972479e19cf92583869d712852382b12e26193485a7b3c5f52cf0d6345de41cb627aaea1aa688b0024f4def2e6891b9082e52be749c2e404f8f067c1593100459ec5cff245dd3d9114f52aa8b7cc2e645719206614f2cec81d9d9b6c6990e0fb4b1af9d2cc20850f345c8bd8402f61d1b6e87c1b4b478409c3b5d6c233d637bb6b78882986e0d4579c94d200dc7914884658b5c896d332b5790ff75b0e6f0a02c45200fb11949e541e076572625944067a8907cba2ff6569092283ebc5e60de5d5afdd09f8a604f7b3df18d5635e3ad04e7f37ed330359a33582e503972c7146afa27300e067931209463034900172886843c2313f64bf2ffe67b4ef33677aaec106406fc9d1f76c8e033e676ded2dbfb205538d025a5e5f584d33aec0055a849eeccc97e41f57a7e3e9967135657085057c64bf25981075594537325cd903eb4577d127aa578c9f8162847f18a6ed3a652ef94160b1f4057127878752788d06dd54a2dd2636bc528a8d4f0cdbabb7e4abfec8c1ad0db3e6dbbc62fc8f89f3d5c563fa19f2013f88532d422f70a0078416b9beb303cac1724a7a4509be3e907db7fb9c643ff0b12f09391c3c5272d815d73e460640440aeefccf4edf459dddf2b5d76faac8c57168c21c30467a771254ef817760c82f839b1db8a708f0ad7af8225c4b92456829a2eb6b33c700bbe580555e9c1fa98f474714ef7357ee0659378dd7954b44803699fd6effee353a2b683bafb0b82b571ad57f3a0b5dd83672d5005551762a1136b9aa716c1cd6114ef93d61453e7c325bd8c871697d65750d99b5a8cdef62d70be0e0a1d9f692937a6526814001f5e51b94d3fc774dea159078b1c673a79b7fe6675110fe2efb2f7785ff0ed93a67b3b4db2d097fa46bc92350c9ee85c79bf9f0a1e7fee2c057fd25d17658d63afad2ca2f661161f4698ad999bcbce92d28c4307aa7b7b53b52f6fa3366fc4df02ad89caaefffeb86fe9070af921e6c06e461560a75e020c004066c02f4fd3cac3a7c593bea3fc984003f6935b2131c0d3a825b7f9040c1388bfe6da6019aabd5a59ecd7934a3ff2ccb76426c067a421d3221cdffd61f9acd0cf427264d7c3e6cabf0f0d04f6c21494e25e3174cae565c2063f50a46cbbb68494ebf88b5ee09bdcbf5fd9248815fe393c21e0bd6ef81e600ba46692960284807b13e4b5d680e85faf97f46b5d93a05c62b85bc8369867b742ab9314d98f0023f9e15251b59c52539d1e235a9a8e463f0871226d22fdcb915242ef7294a6685d817d4815f6cf63394879bc60a42601ef7a57b9d518bd5f0195564b289eec276205b6628dee9f0dfdbc7e7ef4b27f247913821d2f5b28b35fe84755064cc7bf260b81d241c9a762caf94597435613e0aeed5ff66f68c60d77ec20ac5c4f3434d5402c9f7857257416d5a34ca5a603520303d4413395c7fc469c2bd26aac315cc20bdc1d43c95100f7287f476b2c21e8157544302f825dd0e3b822d66444b7c1741ec95f97602474a0ebeb06a59f4a36a7097537298c690c61b56318a17a5f4116271c9d44447c54107dab48440bceeaa72892e04e7634d4907705bf4525ef8642a60e7b0902c48b4063bf60a0cb72c28fbcac31082ba642f77a3c01271efb49703224223dfe9e443e238d5334fc531365bb8bd1973f49ea6104ca6d52295f246c91e54c30d3fdc851ba1b4e62448ce9428b341234f8024d07b164796f56592a03de9240da98073b3bbefec03d184272a2b20976c42bfc0dda15379e93e0073e2a9e06766ad18a36784ae4b9ff9ed07551bc5c4dd9c93388c8e404b5b637c0cf3082a503bee0b7ec3b08b7c0f8a417bca8e231fa54d89621c694e237f26269b950c71c24b5817dacb5ac0c55d85c198f9b445713f33498c063a83282c594f44f62a9d5d0fff1e45f6abe76f30146d2f29a9c8d7ada15a27bbe6d4d868882bf8512a7f5f3b882721436dc7289dd5089b363af3440f137fdf56cbc5939715784743621b97ffa3755bc63fddbef1b3266fe9ba7614e9971dd54f2225026e0c7a0d26472cfc623f6b5fdc28cedeb14a0af0cf4bb50a7fe5c8499771e4ae61568f1f19820f5179f1d3e545cfb9120e502699a30c013290560884f935ee75494804f6ec7128adabe178a411bf08169d4989c3d582bf95bdb0edbf4e89d5431f820b778edcd0f8aa75688018c7f97ff1a865fc3c560f9f093bf1df4c1de2a1fb2b89e23274fc12ed224f92a6cbed47a92ae39d042e665d9499a0751084f3f1b556d7f2a4681b27b3fec4a8b15d1995698087b00bdf819fb66efd4dc9b2d3a104235c032692ec145d7313160ef1a1e629f1d73e4e8ba0ebe40e69048c516edd02ec53723473f672894ad4a1d74e0211c1429656ef0d077a5e2869f34b8ca1bc838f6648ae7a8e3be05b90c90ec506b797ff4f6e2fb2b26532bc7af94e84fcf4602b03caa41fb3ec8f9e0508e7b786252b7abc31ed6a0e4688341274be4a1ffed4db6ae61acf4fa3373b284e3cd8041e896f6d26b6ebac35729e2b6ca20c7ab60f0d7884bd0b82a79794c03555614dbbd7a7aaf9539e1623c5a94732af27f5ceb31930c17ea2be143feb21e19d011da00e2dec85dd460534ed98d04eb906cb010ca3468c88e7c3120cc4f5a88729ada64957cb5babb26e1e5f9d6c08a4e679c5656bbaa5f7202a78efa85a676835137b4594f1b92ed61b86fa960f91c72b9a392e4fdad44352507610d1964c5f0547f43a2470e85f9d54cc0f8b3a52710e03ca4af58883893847f4cfa1b5b4e4ffed6467eca5d9f7eac51f2d082f5dd69ca6fc52d58b177068a05674b46f7b165f4f59743064a4f0ba8ff5cd3a0cca7c3d2b10c870ad8cae31c54f47772725c331727e2512fe4396f414d37fcb43c48c0477ed6a8e0845cd37793b6b3fd2abe465c0a1b3d680f09daaecb2634eee2ec64fb265940d81c80e24c42d338934a7fd5c11e37ab8709638a8dcb27bfd4344b5f293579f9bb73baa7f8c17c25c7f94876566cf11b4c0b0362ccf150b38e55312d248b69fcd0392a25c63d9ad055bc6e0592f60a2a3e23edce23abf38df00f6c72e61bc74a2d56651754df758a8c532174611ef995a03d1d025a59bd35b1370be569d37b4fffd7de854763d6d015b56bcde9e498d0a2460c39caefac5b662fff1b7eb4610e465a34effd620a3b0f4e4e8351c9431567fdce4386240c51b31dd6d217f87a2f30405adbf6c9f8ee954c009da017ca07c8ee5b553b6cb126dcc8abe5aa3f620e2adb442568a359a50b846bcbab8ad3c952790b75ff97269d1e08b82bd049a06eea2f7f002658fd933de0f24962c8b24f720bda10e34ac09a8887a799fb78208caef72ce44a3874716be3df4bb121a5d99f592fb33c820c0e44a31b1fd8aeb3d5185bb2beb104f739cbcd70368089892cac0dc08bdd3e1d73c93dddaea4cde5f443b50fefe1a514eb37cd522ed21287615f0c17fb7191233b222e04c893da3c59c50302f15acadd2ac7bde0167f0dbf20ba41e7bfcdfd9484102d43d3c8a66536527dbbb9c8de33152f9b8ac4ee3a14a1e4cddc9495f54be63d4f6da0ed34b2647f10f7f61a930a418dc6c0760a8a2b7052a2be668e8646f36f0b29065fe54517b22589ae0db84ff2b2b80f882bd05d68b7cb08ec5b31fd5fd62bac7fe249c20f6c5f6948383c89c6c984b74bd66450efbafb5d48a1a2c428217c452f3b73f7647fadb479be6e10a65fe89488a34c95de640f5e14f1fac50fe93a1ef139aa40d885cf154817b91ec22c2dd5c561fe503c9fa26e414163494d0e33da04dba0a13716eb2908a85f60b1e1e61dd20bfc13a04f0d24c20fa8cda36f5f7b7d3a3e0c3c8a2623a1612fcd6004cbba55fd34501c05e363306deae7d56a793b5998e405aa2811e64049dc6596c35e733998d650c068229f96b5c78bd42ac2f89506ca2d167b4ea233d373a139dc5db1bf62cb3587e7b7a9b4ee834717e7f3ed42ad0e5bbbd606f44d838e26c488ca30baeccbe5ebbed67b36241393967cdbd90c72fa5c2900729bc50f2c80ce4129925ba3d72c81819b6df308f5738570bd31e60b626c2a1f30eb4887809ddb268d7033f6f57aef80595787d830d8877627fd64d135e766a5634c430ce778b938581f7e5c37710d28cc69a5652eedc4658d3bfaa1ed935e8467d1d07233acea20db92b41025bad8bc8829ca0f9850a191dc51aaef42dbb9a0a097709580a40981d3dca2562d10e1a46157eb1beea3d6a8d209c752efe0189f2b84ce3efa14aa8ac114f3678bb7e4212e76f34ef5ee7beb318c84c1639943c86ed2528ae6e52736e915b6ac4347862c8b9e5daf3077e980a5e7dd6dc1d2e1689ece400cf24ebf6c2f8d3f9c15e345075109dc4169f8b1969501981654574543449f3d33c0f936e0d8daa84ae5358abf4b5d30503193647cc1470c4f1542e75290db2606142bd340bbf72f1fe628db9b034f1ea7138cc2c6bcad323a99aa8e431f074b26a2bbe921d29a0f4283177d370801e43a7b9a3da84c905c540ba6a0b7373278b12a795e397e427d50a7952a9176d70a066cbc416cd7314073acf40d1584857ee724fcdfdad6b4d780ee24b6831d7024ee6d1a080235138ee26bb8589fb382aceba3615f96c2d34e325c361ed62b199fc04b690e19b16192480c33ee4b7088a4b8b9b3d80e6c931dd95c42bcae4d170436448c4e15f48195f120226cff0be03676cf84dcd24d9a522260c5901c3c46219c1c2bb44f7f73d862e965c482325e3171559f62e3c20645fab68022876965eee16b65c55cb5cbe0cdaada32068ff39884ab035dceea45eefd6d08392157bf05b4e2d26c1a935f8a85df399dc695cc0bf1dfd126b73357d80f1c6f69e11ac716727cde02d39be10351b20beccc924b21b01d48fcbb221dd301b3aba875a5c00cbfe389a0d8b769a7e08fa6c795462992248fe720d202f306e017f3a717a2fb34d7035c166a7c45d19c8a03a81fcccb79f8e38e612727ab828b1ccbf18827d7a1d45912ee20dabf25dc0881cb30952a5aacddbe51f033056d8dbe94c7a62cbb4830d3e79932e515efb3d3a63358ba96b90361f5aecf2443a422fa11a8a235dd6c4f24a60b1f61f5ba06ced3b3d19b0e863769e81682a20a90d6bfc7821418de6853fc05370ed25dbc36ef11cfc250388d0efe52056d6d031342cb52862714e96b198d73fc0ba40335280dce19aa5f10e94919e7d5d6c49f1e78eae9bfa5be371e74d4fba42aa861e5d32d9b4d85382420b44eaf3c96aea6c33b8d64b356134010ca3cff9a29ca24ee9363d775e06b068cc1411a91938804b15ffe3772712c67f48c38d6b69678dac119be14fd81bf326a707dc4b7e0e9b5789e423cc1b7fc9acdd562bdc1d0c173ee16e84d0fb13f463aa6a551d25eab8ba8015c5111e7c0c42eb9166ea7e0ac4370953addff24c01976b46f9f515d115adda1c33db4b5745f88e674e987d82d1bb704dc6c1e754da4b59260d7657079537315b49e9fa2b88e67b9f0f7421d8e0226a2e47bc3280612edecfbcade433122925505b366f00a5214f2d7732f35da0ffb4fd2ce0cc3f20b43cb4dade812093b69501cfd8af805499486e890c3c5be84034838f54ce0613d445aecef9e516fd24f0dd878a9ed4687d75b11b3dc3cc17536183f2966f8fb9446c372796dd1cab545edac19e43c64515b8b47c0ccad51ca7ed8396fdb4eebdf742eefca3a59ca7792fdd6d1776be55f5a6bd5dafb731c2c77e7d1c40737d77ecafa4d3ed66855824e5062f07b761f3f965aa4bc9be13cbef2aee40c381f4dd1b6bf712b2e39c7684c94cee9504675bfd0e48eb1b4320dd3d3a79034cb8f7800b4d1468d4c824e0d394d81be144aff67a43011e7fa71720892097b7859c7d57f1d36de4e9e279004e609de5985ac72d419dcdb5a566a80576a40e591f2078b0ae7881bb70e3e3b14c6ade2e7d12d0a350f79abba006fcb999a8057c1cd461cc5585db3a1370b3178df84cb234a8adcc5606ff20b3eb94e585d2bf5d045a3667094e8dd53f9d5bddaaa28b474d9374a84f82986e8e4139005ab9a4cf4dc7d0c69ab4ce9c0057fe9feff1125ed44914aad7cd3553482c9a2400cd1c1a66009b2e91cb35d50f0160fc148789b9285cd2542b2143ae906ddae8023787aafccba53c086c0b98aa0c22c5506400dbd779292a01ebca4b97196feaec4246b021237da3dd5a52f800a6a33fb8f219ad2623ceae438b3b0f7a83b8540096e6759a9db8a2f6c30b1a572c2b55339b77607527fb82a84745b023ad7cf341f8341b216d55dc7dfb67b26ee2ed682595d2da3317d1bacb616c1c1c693f917184da6ec08b17e8cef3a2e0887cdb86deb0d9801c9f512c7a88ba4156e7d37ecfdde74b29daa9cfbb2dc6e5b10fbcd5a2c8f65d6f0c3d47b55dc8d00a88ed5aaa3f79a6db7a43e6b0a31a2a738bc9df8927970ce9d78ee3582720d1d6a44c3e76f1b3f5446b17f90891107d483a55d020a0e842aafc065b8dc0bf829ec7a103bf8b51bdefe24da331c604a1e9d175d1d46f7dfcf20e549d134654ffc3789158886256bcddfcd915b6c19206b48321c8f7ff068d9ef20af2b178441580a37d9d2521e59e8e60040f57b95ee713a972ed29c32b44844ac50c5056c917c4a33708c276e2b88970becbb20f70ac30b0480d6c20eaab05d497a559a5c56842d644fba69a71ccf8565fdf7a20750e7f4bb3ac6b0342cd787f5070e1a876906f2c064d7041e899073166afe3237f3bc2d2c15cab78fb0ba836dad9950d709accbfa8e204115f8868d1816b3b19f3aa876d6929d72d3afeb0ba359ccdf194d31eab3d3e8ae8606a617f4c2e6579a36bf7c4772ed31b11365c710e85796a57b4d81c3642cfa40e8085883db28d0239ab0c736ec253a4248ec7c2913406202e00c0201bce7d354e50afe8ecc0e358486</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相信未来</title>
      <link href="/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/"/>
      <url>/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<p><em>作者：食指</em></p><p>当蜘蛛网无情地查封了我的炉台，</p><p>当灰烬的余烟叹息着贫困的悲哀，</p><p>我依然固执地铺平失望的灰烬，</p><p>用美丽的雪花写下：相信未来。</p><p>​    </p><p>当我的紫葡萄化为深秋的露水，</p><p>当我的鲜花依偎在别人的情怀，</p><p>我依然固执地用凝霜的枯藤，</p><p>在凄凉的大地上写下：相信未来。</p><p>​    </p><p>我要用手指那涌向天边的排浪，</p><p>我要用手掌 那托起太阳的大海，</p><p>摇曳着曙光那支温暖漂亮的笔杆，</p><p>用孩子的笔体写下：相信未来。</p><p>​    </p><p>我之所以坚定地相信未来，</p><p>是我相信未来人们的眼睛——</p><p>她有拨开历史风尘的睫毛，</p><p>她有看透岁月篇章的瞳孔。</p><p>​    </p><p>不管人们对于我们腐烂的皮肉，</p><p>那些迷途的惆怅，失败的苦痛，</p><p>是寄予感动的热泪，深切的同情，</p><p>还是给以轻蔑的微笑，辛辣的嘲讽。</p><p>​    </p><p>我坚信人们对于我们的脊骨，</p><p>那无数次地探索、迷途、失败和成功，</p><p>一定会给予热情、客观、公正的评定，</p><p>是的，我焦急地等待着他们的评定。</p><p>​    </p><p>朋友，坚定地相信未来吧，</p><p>相信不屈不挠的努力，</p><p>相信战胜死亡的年轻，</p><p><strong>相信未来，热爱生命。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 877 (Div. 2)</title>
      <link href="/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/"/>
      <url>/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1838">Codeforces Round 877 (Div. 2)</a></p><h5 id="A-Blackboard-List"><a href="#A-Blackboard-List" class="headerlink" title="A. Blackboard List"></a>A. Blackboard List</h5><p><strong>题意：</strong></p><p>​    给定包含两个数字的初始，然后进行 <script type="math/tex">n-2</script> 次操作，每次操作从序列中取出两个数字（不能取同一个），将其差之绝对值加入序列，最终得到一长度为 <script type="math/tex">n</script> 的序列。</p><p>​    现给定最终序列（乱序）， 求最初始数字之一。</p><p><strong>题解：</strong></p><p>​    由于新加入数字必为非负数，因此序列中的负数必定是初始数字。</p><p>​    若全为非负数，由于 <script type="math/tex">|a-b|\leq|a|</script> 且 <script type="math/tex">|a-b|\leq |b|</script> ，因此最大数字必为初始数字。</p><h5 id="B-Minimize-Permutation-Subarrays"><a href="#B-Minimize-Permutation-Subarrays" class="headerlink" title="B. Minimize Permutation Subarrays"></a>B. Minimize Permutation Subarrays</h5><p><strong>题意：</strong></p><p>​    给定一 <script type="math/tex">n</script> 的排列。交换两数字的位置，使得交换后序列中，能够成排列的连续子序列数目最少。</p><p><strong>题解：</strong></p><p>​    <script type="math/tex">1</script> 与 <script type="math/tex">2</script> 之间夹 <script type="math/tex">n</script> ，这样能够使得数目恒为 <script type="math/tex">1</script> ，是为最少。讨论即可</p><h5 id="C-No-Prime-Differences"><a href="#C-No-Prime-Differences" class="headerlink" title="C. No Prime Differences"></a>C. No Prime Differences</h5><p><strong>题意：</strong></p><p>​    将 <script type="math/tex">n*m</script> 之内的正整数排成一个 <script type="math/tex">n*m</script> 矩阵，使得矩阵中任意两相邻元素差值的绝对值不为素数。</p><p><strong>题解：</strong></p><p>​    先考虑 <script type="math/tex">m\geq 5</script> 时，将 <script type="math/tex">\{0, 1*n, 2*n, 3*n, ... (m-1)*n\}</script> 排成一列。以下是一种合适的构造方法。</p><p>​    设 <script type="math/tex">p=\lfloor \frac{m-1}{2}\rfloor</script> 考虑两个序列 </p><script type="math/tex; mode=display">\{0, 1*n, 2*n, ...p*n \} \\\{(p+1)*n, (p+2)*n, ... (m-1)*n\}</script><p>​    然后将两序列合成（下面序列的元素依次插入上面序列的空隙）。</p><p>​    若 <script type="math/tex">m=4</script> ，则可构造为 <script type="math/tex">\{1*n, 3*n, 0, 2*n\}</script></p><p>​    设该序列为 <script type="math/tex">A</script> ，则最终矩阵可构造为 <script type="math/tex">p_{i, j}=i+A_j</script></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">4</span>) &#123;</span><br><span class="line">        add[<span class="number">0</span>] = n;</span><br><span class="line">        add[<span class="number">1</span>] = <span class="number">3</span> * n;</span><br><span class="line">        add[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        add[<span class="number">3</span>] = <span class="number">2</span> * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) cout &lt;&lt; i + add[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Bracket-Walk"><a href="#D-Bracket-Walk" class="headerlink" title="D. Bracket Walk"></a>D. Bracket Walk</h5><p><strong>题意：</strong></p><p>​    一括号序列，从最左侧出发可以随意向左右移动（不超边界），最终停在最右侧。途经符号构成一括号序列，若该括号序列合法，则称原序列 walkable 。</p><p>​    现给定一括号序列 <script type="math/tex">s</script> ， <script type="math/tex">q</script> 次单点修改，要求求出每次单点修改后，序列是否 walkable 。</p><p><strong>题解：</strong></p><p>​    walkable 的必要条件首先是长度 <script type="math/tex">n</script> 为偶数。</p><p>​    其次构造一序列 <script type="math/tex">A</script> ，包含所有的 <script type="math/tex">i</script> ，使得</p><ul><li>$s_i=’)’$ 且 $i$ 为奇数</li><li><p>$s_i=’(‘$ 且 $i$ 为偶数</p><ol><li>若 <script type="math/tex">A</script> 为空，则显然圆括号序列为 $()$ 重复若干次，必定 walkable。</li><li>若 <script type="math/tex">A</script> 非空，其中最小数字为奇数，则意味着序列开头为 $()()()…())$ ，必定非法</li><li>若 <script type="math/tex">A</script> 非空，其中最大数字为偶数，则意味着序列末尾为 <script type="math/tex">(()()()</script> ，必定非法</li><li>剩余情况， <script type="math/tex">A</script> 中最小数字 $m$ 为偶数， 最大数字 $M$ 为奇数，则 $m, M$ 之间符号数为偶数，其中左右括号奇偶性相同。则在 $m-1,m$ 这两个位置产生足够多的 $((….$ 来消除右侧的 $)$，然后在$M,M+1$ 两个位置产生对应数量的 $))$ 补齐即可。合法。</li></ol></li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;str](<span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="built_in">return</span> ((str[p - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) ^ (p &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) s.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2 9</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; pos;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(pos)) s.<span class="built_in">erase</span>(pos);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">insert</span>(pos);</span><br><span class="line">        str[pos - <span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span> + <span class="string">&#x27;)&#x27;</span> - str[pos - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*s.<span class="built_in">begin</span>() &amp; <span class="number">1</span>) || !(*s.<span class="built_in">rbegin</span>() &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-Count-Supersequences"><a href="#E-Count-Supersequences" class="headerlink" title="E. Count Supersequences"></a>E. Count Supersequences</h5><p><strong>题意：</strong></p><p>​    求满足以下条件的 <script type="math/tex">b</script> 序列个数：</p><ul><li>$b$ 序列含 $m$ 个正整数，所有数字均在 $[1,k]$ 内</li><li>$b$ 序列删去若干个数，顺序不变，可以得到 $a$ 序列</li></ul><p><strong>题解：</strong></p><p>​    考虑 <script type="math/tex">dp</script></p><p>​    <script type="math/tex">f[i][j]</script> 表示含 <script type="math/tex">i</script> 个正整数删去后可得到长度为 <script type="math/tex">j</script> 的 <script type="math/tex">a</script> 序列前缀的序列数，则有如下转移方程：</p><script type="math/tex; mode=display">f[i][j]=\begin{cases}f[i-1][j-1]+(k-1)*f[i-1][j],\ j<n \\f[i-1][j-1]+k*f[i-1][j], \ j=n\end{cases}</script><p>​    发现该转移方程与 <script type="math/tex">a</script> 无关。</p><p>​    因此将 <script type="math/tex">a</script> 序列设为 <script type="math/tex">n</script> 个 <script type="math/tex">1</script> ，然后作差法。</p><p>​    最终答案为：</p><script type="math/tex; mode=display">k^m-\sum_{i=0}^{n-1}\binom{m}{i}(k-1)^{m-i}</script><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">auto</span> quick_pow = [&amp;mod](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">            a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">quick_pow</span>(k, m);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans -= <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>(k - <span class="number">1</span>, m - i) % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        ans += mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * (m - (i+<span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>((i+<span class="number">1</span>), mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/2023/07/04/README/"/>
      <url>/2023/07/04/README/</url>
      
        <content type="html"><![CDATA[<p>本站采用 hexo 架构，部署在 github pages 上，采用 github 作为图床。建议在能够流畅访问 github 的网络环境下浏览。</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307042122433.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 150 (Div. 2)</title>
      <link href="/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/"/>
      <url>/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1841">Educational Codeforces Round 150 (Rated for Div. 2) </a></p><h5 id="A-Game-with-Board"><a href="#A-Game-with-Board" class="headerlink" title="A. Game with Board"></a>A. Game with Board</h5><p><strong>题意：</strong></p><p>​    给定初始序列为 <script type="math/tex">n</script> 个 <script type="math/tex">1</script> ，两人轮流行动，每次可以选择序列中若干个相同的数，剔除，并将他们的和加入序列。第一位无法行动的一方获胜。假设二人都绝对聪明，试问先手是否必胜。</p><p><strong>题解：</strong></p><p>​    分类讨论一下：</p><ul><li>$2\leq n \leq 4 $，有限轮模拟易得后手必胜。</li><li>$n\geq5$ ，则先手取 $n-2$ 个 $1$， 后手只能取 $2$ 个 $1$ ， 之后序列变为 $\{n-2, 2\}$ ，故先手必胜。</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-Ranom-Numbers"><a href="#C-Ranom-Numbers" class="headerlink" title="C. Ranom Numbers"></a>C. Ranom Numbers</h5><p><strong>题意：</strong></p><p>​    A, B, C, D, E 分别代表 <script type="math/tex">1, 10, 100, 1000, 10000</script> 。给定一由大写字母 ABCDE 组成的串，对于某一字符，若字符串后方有严格大于它的字符，则符号为负，否则为正。字符串权值为所有字母乘上符号的权值之和。</p><p>​    现可以修改至多一字符，求可能的最大权值。</p><p><strong>题解：</strong></p><p>​    据说 DP 和贪心均可，这里思路是 DP 。</p><p>​    为了方便起见，先将字符串反转，规则也对应修正。</p><p>​    然后设计状态： <script type="math/tex">F[i][j][0/1]</script> 代表到第 <script type="math/tex">i</script> 位，目前前缀最大值为 <script type="math/tex">j</script> ，且已经/未修改的最大权值。 <script type="math/tex">i</script> 这一位用滚动数组滚掉，然后枚举状态的转移即可。</p><p>​    复杂度 <script type="math/tex">O(nMK)</script> ，其中 <script type="math/tex">M=5, K=2</script> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> f[<span class="number">2</span>][<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[<span class="number">0</span>][i][<span class="number">0</span>] = f[<span class="number">0</span>][i][<span class="number">1</span>] = -inf;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">        p ^= <span class="number">1</span>;</span><br><span class="line">        q ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[p][i][<span class="number">0</span>] = f[p][i][<span class="number">1</span>] = -inf;</span><br><span class="line">        <span class="type">int</span> x = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;   <span class="comment">//i-1位前缀最大</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) &#123;   <span class="comment">//</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">5</span>; y++) &#123;</span><br><span class="line">                    <span class="type">int</span> nt = t + (y != x);</span><br><span class="line">                    <span class="type">int</span> nj = <span class="built_in">max</span>(y, j);</span><br><span class="line">                    <span class="keyword">if</span> (nt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        f[p][nj][nt] = <span class="built_in">max</span>(f[p][nj][nt], f[q][j][t] + (y == nj ? digit[y] : -digit[y]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">0</span>]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Pairs-of-Segments"><a href="#D-Pairs-of-Segments" class="headerlink" title="D. Pairs of Segments"></a>D. Pairs of Segments</h5><p><strong>题意：</strong></p><p>​    给定 <script type="math/tex">n</script> 条线段，用区间表示 <script type="math/tex">[l,r]</script> 。若 <script type="math/tex">n</script> 为偶数，且可以将 <script type="math/tex">n</script> 条线段分为 <script type="math/tex">\frac{n}{2}</script> 对， 每一对线段相交， 不成一对的线段相交，则称其 <strong>beautiful</strong> 。现问至少删去多少线段，使得剩下的线段可以 <strong>beautiful</strong> 。</p><p><strong>题解：</strong></p><p>​    <script type="math/tex">n</script> 比较小。一开始以为是 <script type="math/tex">dp</script> 但怎么都消除不了后效性。实际解法是——直接暴力。</p><p>​    首先考虑两对线段，共四条。不成对线段不相交的等价条件可以表示为： 成对线段取并集，所得两条线段不相交。</p><p>​    因此可以直接求出 <script type="math/tex">C_n^2</script> 对线段中，相交对的并集。然后找出尽量多的并线段，使其互不相交即可。互不相交可以天然保证每条线段至多用了一次。求不相交线段数目，这里用了动态开点线段树。</p><p>​    复杂度 <script type="math/tex">O(n^2logn)</script> 。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> lc[N &lt;&lt; <span class="number">4</span>], rc[N &lt;&lt; <span class="number">4</span>], dat[N &lt;&lt; <span class="number">4</span>], cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">    dat[p] = <span class="built_in">max</span>(dat[p], val);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid) <span class="built_in">update</span>(lc[p], l, mid, k, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || u &gt; v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(lc[p], l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(rc[p], mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">Line</span>(n);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; Uline;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; Line[i].first &gt;&gt; Line[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a.first, b.first) &lt;= <span class="built_in">min</span>(a.second, b.second);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> uni = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="built_in">min</span>(a.first, b.first), <span class="built_in">max</span>(a.second, b.second));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(Line[i], Line[j])) <span class="keyword">continue</span>;</span><br><span class="line">            Uline.<span class="built_in">pb</span>(<span class="built_in">uni</span>(Line[i], Line[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(Uline.<span class="built_in">begin</span>(), Uline.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Uline) &#123;</span><br><span class="line">        <span class="type">int</span> rem = <span class="built_in">query</span>(rt, <span class="number">-1</span>, inf, <span class="number">-1</span>, line.first - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">update</span>(rt, <span class="number">-1</span>, inf, line.second, rem + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rem + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - (ans &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h5 id="E-Fill-the-Matrix"><a href="#E-Fill-the-Matrix" class="headerlink" title="E. Fill the Matrix"></a>E. Fill the Matrix</h5><p><strong>题意：</strong></p><p>​    给定一 <script type="math/tex">n*n</script> 的矩阵，其中第 <script type="math/tex">i</script> 列的第 <script type="math/tex">1-a_i</script> 行为黑格， <script type="math/tex">a_i-n</script> 行为白格，仅白格可以填数。当一个格填数 <script type="math/tex">x</script> 且其正右侧格填数 <script type="math/tex">x+1</script> 时，贡献一 beauty 。填入 <script type="math/tex">1-m</script> 共 <script type="math/tex">m</script> 个数，求最大 beauty 值。</p><p><strong>题解：</strong> </p><p>​    看起来似乎比其他几道好想很多。上层所有线段都是下层线段的子集，因此从最底层线段开始枚举，填数，分裂即可。</p><p>​    这里还是用的线段树。注意细节。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dat[N &lt;&lt; <span class="number">2</span>], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>) (dat[p] = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    dat[p] = <span class="built_in">min</span>(dat[p &lt;&lt; <span class="number">1</span>], dat[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = N;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>, l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">pos</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] = n - a[i];</span><br><span class="line">        pos[a[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos[i] 值为i的位置集合(补上界n+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pos[i].<span class="built_in">pb</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(pos[i].<span class="built_in">begin</span>(), pos[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r, pre_min;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre_min) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">pre_min</span>(pre_min) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node X) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l &lt; X.r - X.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ask(l, r) ask(1, 1, n, l, r)</span></span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">1</span>, n, <span class="number">0</span>));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p.l == p.r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> min_num = <span class="built_in">Ask</span>(p.l, p.r);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>) &gt; m) &#123;</span><br><span class="line">            ans += (m / (p.r - p.l + <span class="number">1</span>) * (p.r - p.l)) + <span class="built_in">max</span>(<span class="number">0ll</span>, m % (p.r - p.l + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m -= <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>);</span><br><span class="line">            ans += <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l);</span><br><span class="line">            <span class="type">int</span> L = std::<span class="built_in">lower_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.l) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> R = std::<span class="built_in">upper_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.r) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> pre_l = p.l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt; R; pre_l = pos[min_num][i] + <span class="number">1</span>, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre_l &lt; pos[min_num][i]) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, pos[min_num][i] - <span class="number">1</span>, min_num));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre_l &lt;= p.r) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, p.r, min_num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 879 (Div. 2)</title>
      <link href="/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/"/>
      <url>/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1834">Codeforces Round 879 (Div. 2)</a></p><p>难度适中，但菜鸡依旧。</p><h6 id="B-Maximum-Strength"><a href="#B-Maximum-Strength" class="headerlink" title="B. Maximum Strength"></a>B. Maximum Strength</h6><p><strong>题意：</strong></p><p>​    <script type="math/tex">[l,r]</script> 之间选两个数，使得十进制表示下各个位数的差值绝对值之和最大，位数不同则较小数补前导 <script type="math/tex">0</script> 对齐。</p><p><strong>题解：</strong></p><p>​    设 <script type="math/tex">l</script> 和 <script type="math/tex">r</script> 位数分别为 <script type="math/tex">n</script> 和 <script type="math/tex">m</script> ，取的数字为 <script type="math/tex">x<y</script> ，分情况讨论。</p><ul><li>若 <script type="math/tex">n<m</script> ，则最优情况为 <script type="math/tex">x</script> 取 $m-1$ 个 <script type="math/tex">9</script> , <script type="math/tex">y</script> 保留 <script type="math/tex">r</script> 的最高位，剩余位为 <script type="math/tex">0</script></li><li>若 <script type="math/tex">n=m</script> ，则除去相同前缀，然后 <script type="math/tex">y</script> 保留最高位，剩余位为 <script type="math/tex">0</script> ， <script type="math/tex">x</script> 保留最高位，剩余位为 <script type="math/tex">9</script> 即可。</li></ul><p><strong>code：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    n = s1.length();</span><br><span class="line">    m = s2.length();</span><br><span class="line">    if (n &lt; m) &#123;</span><br><span class="line">        cout &lt;&lt; (s2[0] - &#x27;0&#x27;) + (m - 1) * 9 &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (s1[i] == s2[i]) continue;</span><br><span class="line">            cout &lt;&lt; s2[i] - s1[i] + (n - i - 1) * 9 &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="C-Game-with-Reversing"><a href="#C-Game-with-Reversing" class="headerlink" title="C. Game with Reversing"></a>C. Game with Reversing</h6><p><strong>题意：</strong></p><p>​    给定两等长串 <script type="math/tex">S</script> 和 <script type="math/tex">T</script> ， Alice 和 Bob 轮流操作。Alice 每次可以替换一个字符，Bob 每次可以翻转一个串， 当两串相同时，停止操作。Alice 希望操作次数尽量少， Bob 希望操作次数尽量多， 求两个人都采取最优策略的情况下，实际游戏操作次数。</p><p><strong>题解：</strong></p><p>​    解释起来比较啰嗦，这里简述。    </p><p>​    实际上 Bob 每轮操作都是相同的，因此可以假设 Bob 只翻转一个字符串 <script type="math/tex">T</script> 。</p><p>​    对 Alice 来说，则可以有两种选择，将 <script type="math/tex">S</script> 变为 <script type="math/tex">T</script> 或 <script type="math/tex">rev(T)</script> 。二者最小步数都容易 <script type="math/tex">O(n)</script> 求出。 最后根据实际的奇偶性补齐 Bob 的操作数即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    int ans1 = 0, ans2 = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (s1[i] != s2[i]) ++ans1;</span><br><span class="line">        if (s1[i] != s2[n - i - 1]) ++ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ans1 &amp; 1) ans1 = ans1 * 2 - 1;</span><br><span class="line">    else ans1 = ans1 * 2;</span><br><span class="line">    if (ans2 &amp; 1) ans2 = ans2 * 2;</span><br><span class="line">    else if (ans2 == 0) ans2 = 2;</span><br><span class="line">    else ans2 = ans2 * 2 - 1;</span><br><span class="line">    cout &lt;&lt; min(ans1, ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="D-Survey-in-Class"><a href="#D-Survey-in-Class" class="headerlink" title="D. Survey in Class"></a>D. Survey in Class</h6><p><strong>题意：</strong></p><p>​    给定若干条线段，求最大分数差值。</p><p><strong>题解：</strong></p><p>​    对于线段 <script type="math/tex">[l_1, r_1]</script> 和线段 <script type="math/tex">[l_2,r_2]</script> ，设 <script type="math/tex">r_1<r_2</script> ，则分三种情况讨论：</p><ul><li><script type="math/tex">r_1<l_2</script> ，则最大差值可以分别来源于两线段整段，即 <script type="math/tex">max(r_1-l_1+1, r_2-l_2+1)</script> ；</li><li><script type="math/tex">l_1\leq l_2\leq r_1 \leq r_2</script>，则最大差值来源于二者分别对交集取补，即 <script type="math/tex">max(r_2-r_1, l_2-l_1)</script> ；</li><li><script type="math/tex">l_2\leq l_1 \leq r_1 \leq r_2</script> ，包含关系，最大差值来源于长线段对短线段取补，即 <script type="math/tex">(r_2-l_2+1)-(r_1-l_1+1)</script> 。</li></ul><p>​    将每条线段按右端点排序，枚举线段 <script type="math/tex">[l_2,r_2]</script> ， 目标是找出对应的 <script type="math/tex">[l_1, r_1]</script> ， 三种情况分别需要求：</p><ul><li>右端点小于 <script type="math/tex">l_2</script> 的直线中，<script type="math/tex">r-l+1</script> 的最大值</li><li>相交直线中， <script type="math/tex">r</script> 的最小值以及 <script type="math/tex">l</script> 的最小值</li><li>左端点大于等于 <script type="math/tex">l_2</script> 的直线中， <script type="math/tex">r-l+1</script> 的最小值</li></ul><p>​    四个值四棵动态开点线段树维护即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x7fffffff</span><br><span class="line">int cnt = 0;</span><br><span class="line">const int N = 4e5 + 5;</span><br><span class="line">int dat[N &lt;&lt; 5], lc[N &lt;&lt; 5], rc[N &lt;&lt; 5];</span><br><span class="line"></span><br><span class="line">void update(int &amp;p, int l, int r, int k, int val) &#123;</span><br><span class="line">    if (!p) p = ++cnt, dat[p] = inf;</span><br><span class="line">    if (l == r) return (void) (dat[p] = min(dat[p], val));</span><br><span class="line">    int mid = l + r &gt;&gt; 1;</span><br><span class="line">    if (k &lt;= mid) update(lc[p], l, mid, k, val);</span><br><span class="line">    else update(rc[p], mid + 1, r, k, val);</span><br><span class="line">    dat[p] = inf;</span><br><span class="line">    if (lc[p]) dat[p] = min(dat[p], dat[lc[p]]);</span><br><span class="line">    if (rc[p]) dat[p] = min(dat[p], dat[rc[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int query(int p, int l, int r, int u, int v) &#123;</span><br><span class="line">    if (!p) return inf;</span><br><span class="line">    if (u &lt;= l &amp;&amp; r &lt;= v) return dat[p];</span><br><span class="line">    int mid = l + r &gt;&gt; 1, res = inf;</span><br><span class="line">    if (u &lt;= mid) res = min(res, query(lc[p], l, mid, u, v));</span><br><span class="line">    if (v &gt; mid) res = min(res, query(rc[p], mid + 1, r, u, v));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123;</span><br><span class="line">    return A.second == B.second ? A.first &lt; B.first : A.second &lt; B.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">#define mp(x, y) make_pair(x, y)</span><br><span class="line">    int t1 = 0, t2 = 0, t3 = 0, t4 = 0;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;pair&lt;int, int&gt; &gt; Stu(n);</span><br><span class="line">    for (int i = 0, l, r; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        Stu[i] = mp(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Stu.begin(), Stu.end(), cmp);</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (auto stu: Stu) &#123;</span><br><span class="line">        int l = stu.first, r = stu.second;</span><br><span class="line">        int rem;</span><br><span class="line">        rem = -query(t1, 0, m, 0, l - 1);</span><br><span class="line">        if (rem != -inf) ans = max(ans, max(rem &lt;&lt; 1, (r - l + 1) &lt;&lt; 1));</span><br><span class="line">        update(t1, 0, m, r, l - r - 1);</span><br><span class="line"></span><br><span class="line">        rem = query(t2, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (r - rem) &lt;&lt; 1);</span><br><span class="line">        update(t2, 0, m, r, r);</span><br><span class="line"></span><br><span class="line">        rem = query(t3, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (l - rem) &lt;&lt; 1);</span><br><span class="line">        update(t3, 0, m, r, l);</span><br><span class="line"></span><br><span class="line">        rem = query(t4, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, ((r - l + 1) - rem) &lt;&lt; 1);</span><br><span class="line">        update(t4, 0, m, l, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-MEX-of-LCM"><a href="#E-MEX-of-LCM" class="headerlink" title="E. MEX of LCM"></a>E. MEX of LCM</h5><p><strong>题意：</strong></p><p>​    题如其名。给定 <script type="math/tex">n</script> 个数，则对应的有 <script type="math/tex">C_n^2</script> 个连续子序列。求所有子序列数值 <script type="math/tex">lcm</script> 的 <script type="math/tex">Mex</script> 。</p><p><strong>题解：</strong></p><p>​    同样是利用好值域。 对于区间 <script type="math/tex">[l,r]</script> ，固定住右端点 <script type="math/tex">r</script> ，则至多还剩下 <script type="math/tex">r</script> 个左端点，对应 <script type="math/tex">r</script> 个区间。这 <script type="math/tex">r</script> 个区间有多少 <script type="math/tex">lcm</script> 值？从 <script type="math/tex">l=r</script> 开始，每次向左添加一个数， <script type="math/tex">lcm</script> 要么不变， 要么至少翻一倍，因此 <script type="math/tex">lcm</script> 值的数目是 <script type="math/tex">log</script> 级别的。因此整个序列所有 <script type="math/tex">lcm</script> 值的数目不超过 <script type="math/tex">nlogn</script> ，迭代求出然后求 <script type="math/tex">Mex</script> 即可。复杂度 <script type="math/tex">O(nlogn)</script></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / __gcd(x, y) * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1ll</span> * n * n + <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; num[i];</span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; s;<span class="comment">//以r-1为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; rem; <span class="comment">//以r为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; ans;<span class="comment">//所有lcm序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: num) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">lcm</span>(y, x);</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= inf) rem.<span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        rem.<span class="built_in">insert</span>(x);</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: rem) s.<span class="built_in">insert</span>(y);</span><br><span class="line">        rem.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) ans.<span class="built_in">insert</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = <span class="number">1</span>;</span><br><span class="line">    ans.<span class="built_in">insert</span>(inf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != now) &#123;</span><br><span class="line">            cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数理思维</title>
      <link href="/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/"/>
      <url>/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h6 id="一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。"><a href="#一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。" class="headerlink" title="一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。"></a>一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。</h6><p>​    在数理逻辑论证推理中，务必做到毫无破绽。防范”千里之堤，溃于蚁穴“的局面。更直观地来说，论证必须有从底层起始的依据。</p><p>​    在日常生活中，这一条也同样适用。我们处在一个信息爆炸的时代，很多时候困扰我们的并不是信息资源的匮乏，而是信息茧房的拘束以及信息泛滥的迷茫。保持理性，对信息加以筛选，过滤掉无依据的信息。</p><h6 id="二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。"><a href="#二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。" class="headerlink" title="二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。"></a>二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。</h6><p>​    比较典型的分而治之思想。当整体带有规律性时，局部往往也具有与整体相同或相似的规律性，通过不断地划分，最终将问题转化为一个个显然或已解决的子问题。从个别、特殊到一般的方法。</p><h6 id="三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。"><a href="#三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。" class="headerlink" title="三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。"></a>三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。</h6><p>​    从易到难，从简单到复杂地进行分析、解决，而不至于迷乱。</p><h6 id="四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”"><a href="#四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”" class="headerlink" title="四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”"></a>四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”</h6><p>​    如其所言，思维缜密，考虑周全，确保推理覆盖到所有情况。</p><p>摘自： 笛卡尔 《方法论》</p><p>​    </p><p>​    </p><p><code>人生没有目的，只有过程，所谓的终极目的是虚无的。——人的情况和树相同。它愈想开向高处和明亮处，它的根愈要向下，向泥土，向黑暗处，向深处，向恶——千万不要忘记。我们飞翔得越高，我们在那些不能飞翔的人眼中的形象越是渺小。</code></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT 指北</title>
      <link href="/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/"/>
      <url>/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0b9628033c767bbf3aa9fee6487070856f5e148fa15f92e5f20f8eb5d8b0b88b">578d5c17fdb0be81f91dae08d76a8b9d310fe713a3967a08677820d492351d4d8db2ce40c3d8dab35779bf2fde14fa61c200e4156e98e199d65a4f6ec1aee5b9815b7e5e19294072fc6ca00bfdcfe1fdc03e417f1adb72afa06d680da541c738197ab655a1e49104eb77ef86810c9e98c936e71ca104e1468987a8c1e4b1296836fc3d4145db7d9fa4c464b5166fff91038e2df137e5865cd29aa5865e803bebe454cc244e72f408e32aeaeecae74074129952ce099bad2b1987eb5a86827dca7852c842cdc14eb9cb8266b8774b394f73c82ffd15441a66c402a27690d2352201cf129e86dadc27dbce48b9701822060af5d9f46cfad7e9a8bacdd9a487b6ba370c023ae61299c46c8b7f9cc4100e59a0c098d1bca096af391e03cbffd11680904121495a7e928ae1b3a572bd196bf307fd8e815440b15142cd0832f0b8e8ecad8f412613938a1a65d7f435cea3376f4717de8683ef1b9f573173c119169384e2071082ad17830d107bfdde9c46f44e4105a5a231bcac34b7f4c9d13a3041ea222256429263941c7aa50e1c238a49960c3c8d56e5ff8b29ba2f8c5129f7616b3ad065cd14acd62ed7699f53937ecd023a0d56bd295b45f263c1ee4f8b9426acd1ca77ae4ec2e922b18fee7c29cccd302426ec247fcd95e8650ec9ba580132dfe01dafc3882097b69a72e9472006bf33438a2b347e6fede1c44aa5d8255cef135c08e327f34a621531aa0b83f0c31b5669e24e0250798e3290b7e08de1de4c4f8554d08424e681a69f844a268ff59b9600a4122880760bb56642ccfc16bbd7b6fe5ac62e500220531706b6a9434298adaaa7c2c75b7f93ebfecb6534894df6f477bdde4f5bb44b1316fbd1cbafce529a9cfe14a130b2ef47140dfa3090ab6fa312274a67f661ce4d4b178cf9a5141d43adc3efb3bb0ad68bf1f682f19398b75d56ffb3de87e1c3dfc138195f9c436ef370e92fd57e54d8b22972c3bc7e3f068cc7ae5841ef8d6f250c9c7d998b895528166573464185355ca11909ec3377912299fc2162fed0db073e1a201d52767c97db1d3691ccb5ea3e30286c6b9f7ac6dc75cda6a57b08ec6e4e19f29642591fd0822b4cc4a45bbe7317888fec0223836e2dc79789659561124fd9e17bfb8c96339a8714177c12f979324aaaafb93974e0eccf4df7aeffc5c405708064516b72cb1cd6c795c6453e532d7916015105dc29705393b7c3d729c8c4afb47fc8128e6532d4919de15ec86c9f023fc04194611851c481a03b828fc3c4230600b5d94bff38a8d323e8885fc584e9ac3978afeecf77d309827cd7fcbfcf3536adad3adbba9762f408660ad60bd6238bb5cbd2e5b8d0997dd13be89a954a208f8eefbc6d878cdf5b2a802ac0ec2cce1000a2d274f5e48c77630ae7e8ab81dd57dbd03d0582dadfba8437a8b4e68c135c696b0d4b37447e9d376d61bd19266ff0634809b387c047ee4c7f2b6b0c2f6f621de194b15a859201705ad40319d2e7d1a1c886b0ec12332d5a57fbb2ad9e2713164610232a6f5a82bde627fafbbdf02d2383a9cd3d9e107657f08a02b2a535a8f0fcbe2d358cc62c67472d7bb5d8649da262144c896eb621cbbc979a63fbf3ea44a928d154d5a6706b0b0ff534cd35db0d9702b0cbdea9d5f6a1290426f05c59c34500bf913d6dc39d319f80b5dff4030af7de7e32b5856afa9683d8e7eb7b46fef84735b9c8ff15152086081797da1c839ccb75cc97fef9c38fcbedc64f4b384a9a8e99c1f2b508de9cd6b8027c4e2743d1d422b9a0a57f46819294aeda4d783ef4668a5f808fb8c53811db3672853b8ae5ed2fa68f5e39d6638177543a7ec36295c24dbc2fe6821e2c04458eaf0e402077bd68e663bcbf90a32a4fd7e692c4ff0263a829b7004ab7d3d7800fb7f8e075c9c3a0aa21a3a79dc3f1c29e13ab66610208af1804abd5a3d451813c573ae3dc14bf9ef69226669f033074a0311681bc2d0d28588b08a9ac56ba7fe20d397567ef517e0121ef8d1ac29abd6f8169967329581b48a8ad121163b857e2ef4e3076d370d99903cf3d91532d284a1a4afb23949c3c1cb9836577a0499d0e4bab26deb85311e854b3f4de26346631a778a2fc33d875f9aaf68579875a69615e740e9eb79db16b3f9b389507063f2ca4ceca5186fd72b2f61ae0679e010a4bd38aa7bec34219ca15ad9e0856972ab65b704fa9bb383a396fb26b274103a8b3c39a1d1951d09168193f5266632332715663118cc0c29f400d0e7f24f77543d1875ce3744db7b50256ff8e96d3d23b3f499ef06cc7e940951be896d16ffd18cfde1c906a96b9d90b50c48d8a7bb5cd66c3d0884564078fb3cc0ac3a1d4c962ef390fdb7850786a61589e1ad6019b15ccec04d277fca0cd1197328498afc896797ba3d4864ac4b6dab9392e35e74702f5b8aab284749c305e4646729c8e971a91fc73f2b0865f76ed95ab5d28b99d97807367c7ea5850dce550640690c09284eb7421866bfda04389edc0fa90aaded37e7a3a0ca1ce6eca3f0018aa38439f2fa6200fdcb33f5644a2bd4b912eb4f13a254ac7cdea8f148018a93837c5b3e3666a14548b1cc8a6387c3cfbeb27ca56bdfac92550c86835cce802a1607d8a528dc42e2ff738b67a3a7b8c7ede62eb5ed3ae1f5107489db5467cf1444c1824545b78ff98de3ac89e68ded45fe73b1711e1015cb244f6046b0ad33cbcef218c4df747a694f84285b0ff7d4be7730386458de5df313c0c014b995495db0eeb7aef36155abfd2bd611931276c3efec28af0a0c7c56aed369ad3471856e710aefb4349af76c0766b28cb535f28771ab80f4fc1864592556ed3696e4328a6df82711fb5cfa31dc8c16ccfef7ee5541a12b9a53edf8cc5052994b27aeb74874835b838f41965388c005f8b2a418fc7fa680352f4e681126d936c56eb39efb30c53620a24f6a10f59dbb609a221eb37fdba065f4d865ad20c8c27c63112cc50a267c07ad06a02a1019a0917a94289bbcf66d7372258edbd758b3c266d18d73e008422a2e1d9a665feea94914f3521ce3fb306cc790e1a8d70a09983fa416b6b3485f17c876c6c7781ba7d50e75ea1ba3ab6dc6e33d9767acc7d171ddb3714cee5a8dfd48e1f4ebeea41d1bdb00864e0d9d1bb4b02345acd9f49f4c29516763288309332f9796e55bf06df916e225be7f837e0d7b2fc9ab8e19465666c9e6052cf130c00a9e591d0838cbb52ae686ea00a02e2f8366776f47c586961b77a0358127db76d6ca8829ea8f71df597a02f3e9092672828496a0347465fadc16b1bf933f6f817a5b2c798f5dbf02dedf18b60e89064a24bcba7afed522845eb60454a62d1ed21d70688d822419a9d71404c5db9df70d7c11f5b8e38e97f95da616b5de5e11005e7ad00bb6f38f856f4a5f5e151916c46c3ebbe6649602cba5c3b89d28a6120f354cd333e4d7e86e21b66ec10b4f4e0658464fbe2a4ccfc028d45ccf73a2be22f9edd950b91a094e709e60ac1368f356e3132eb2a4918b645bd0d249c9d1513761c9d1c3637ea4f9c4577914c6d24d8d6c84bc1e83b04c05a425ae7075c1fd30e9ccc2517af0c3b62e83731346b90d8b7f47d2f1da6556402350609d647312bd12db35f8a127e53632e3265c7492899e47b7b8833f39cbd49c51613eda73ad8819bd7dce8e1426a8e9bfa32bf52a0065312a14dd51985a779505b7404d32a797d98f95fe9a1388a9b3e9d19100a41c577457a64c84126f1b84055cd821ddc6aba117f1e0930e306ecb961e1a39c6b4b9be623dcf0311c975ee4a49a5942889221d5cf7dff6437e6926adb0fa98378c13cb215c8c91ec79b20522439165ec78e383b3a8091ae096d8df7601975fcfa2c550b431b820524561101ca84917b4a6e2d2adb3cd0792d99c80e2de4a78ecb9bd54b55106eb136c8e9a424772e638862b5337e84a14c7227573a3566ec9d281f68203ad3b8e90cbfe9743dd4112fc2cc1073b32b6fe51167419037dcb8fc0ddb0913fef6d17d3679ba7efc65551f48865fa2046c9be394855f9abb4a0710d24a89bbe284f5b209a0543bbe0b71cd5725125cb1398a6df3bfe2b26fbcb8b05554962fb0d17ca95c7b98cd1d5b06cd945c0ebb5f2cece52ca8b5be76ce577b9f9b315f598bdc09f251581e79420d193e87a717822a85ad0fa3d6e9cf820f7269f44fc70dfe48d0bafc577a14185e58e772811895febabc5adef518e0c6c1a432170b4881c971cd8bfbf7737f68c8d990881baa37ab44aaa526d5f8dd17a921fb8539e4e9c2530e99bc8cabf0e77ecb0b0b4dfb05e2519bcb19c7785f42878636ab11c1b47c375621b640d95270df167a1043012b91b5058750a1a9b7ef6bca3a178fcb893ee5a9c17f51be7398293a866a5ca81bb339de8d422db232be59ae3d725665ff686f7342e5da98ddfd79083428a8f61da8d3817877be2603e7bbc241b979dfc1314c7e6bdbc069174340652a6e598a22a32d63291b7984bf527dd8147ef1c9734f3505f92f5ab33934b035007b34480a6543c0d8b5c70694865d41237d52a3c6881fa9edcf9e86810234b6b1105689a0a19f502d6c79f0d9efba90a224cd82db8d85e1f1cf96ea39b0e70809555c6773f5a0593e64457c2ff0801235a179dd01408c419194395fe5a4ccfb3369510e626443aa52961c02f83590386bdea13b081de2b0cb23ec122375ccab6f29e5138ffd6d2215a549c9d7be3fe4b2963c51efff678c7fca3922a8c50896179396b9adeddfcdd69c1f8f67e91670bf87b52727187c390f3fcc27218986cbd62287fc2b16501d4f2a74b5166ac45f4fed6a4f445b93b2fc81702bfd8451b5c7f7a87ca2cd8b5f00c671f6f73a4ee8ca3b2ee18d40bf2e0c34725f9ab31b1f9d2c86ccb27a422938898d6807aea0e0cc52f7dddd69c5344c6d2a3ebc86b235dd7f8ff11b97436d28289f4df2011cc22af341b49b18181bc58fd24637b58d5408649549fe47da5fbff571009d5fd233d0b83dd1db7757435f42ca5de0229b0662cdad24cf151d3029e077e6e01d0f242c7cd3c8f0cce4f421b0e3e9c006c035ea53014ab9e31ec6b6f5d2b97aa085424aa307b09c4c676352cd04e880fa6d23b19a1be02c9bdd6d2d11c2040a538ffab8a4a0e153e05f27ba094b850cdec3e90e139f9943a3286cb1d4818ec05d868ade7e38bf515af1d32b67d0c7758f29793b5c74e8e05c59bf62e0e363899ebf1ec09aca77f32288c22e3a81ea67c501af545f946360519ae1e4c04715d9e43f5a23808607b6ad8f0aaa75cc886790d0e768bf3c5fe071f82f076e0af671788a6afbdae09e80fbcd31381bb66ab62c3e4e68e49413fce2304016fbbb9d62b5cab45eb74a7da55f333eea28462dc5b7ddd3660a0c6b6bcc4b6a66dec95227de79eee1ff5f747f9de98dffd867db8e6fd7e9adab0b178e41c9a3c66983e731bf0cca6aded587ab2930c34ca1ec969ae46ebbe10cb4b9d68c2e5fe45885e5afdd41eed5f71683daa99b3deea37e70497c3456c66b4ae4fa673377106c222a1aa3885d4b42d13f148242c9a5b772ae5b46dfb0966ea1531dfaa50d2b53dfb6af310f94cb052d7c7b1e5190f6f9dc2c8cc88cd26baca3e508eb456d09b51329832509e4ed0f5dcd9e125305f2cb217b6f77544255eb5edc7b8adda3a7a46053eb98b12507c78dedb4da56953d4be909bdaf8b9b8ebd95cbbc977b9cca80ecbcdc52c623029cea5330bf05a6e4fd45c55dfa8b6ab4c0991be52a87c5c4825d3c33e6b2af733f2461b2350f84b22090b4be6631235bec0657e43521235c60d40b91467539adcd45fdf41613e53c774cce7d99a28133f0ecba414231dce28f22e7e697b369e3178d7c13276444e55b44ca7c4687a4606191a92c8610809e5e147748b0f9429d1c0e38393c177dc05b66e411ebf76c6d10d09ee10d674c9b3556a606ccace20f0f110a3651c017e8b177a3cbe5f842b877cdee76912eac93b927fd8f3e72e7eb51d2fcc18d2183bdc564e9586730068e7e5a28af416dfa119f6292000ede457569dfb0e960e221563489e023a488393065bbe5f31ec1193f127b49e5e56132e13d41a51655ad0522920b1359518f93ef614c62335cb478551f4502225b62951fa24235fc83febd00d2445668800fbf7206683b9ecc4723a6bec539a24b1bb56a71caaa8a0101d0d26dc6c0cd9c02db46b41e803387bbebc6be9d31bcd1d182e177f78ae1410cf15d7b289178f383da68ac73f5b0c168ee5d78fb31b9ae861058a699dc84f89187041d5d9784d9f27b7effc632044f1ad65a494d855c7bef88688fbdf1833dcfd02e8f0623c01e606f41e94ec621d1f33b6e8a90e69a776d53698461c5ffef029c7bd5d65c5d0d5c8254c06d21cacfa6ca9b0a691a440046058e208528373c096e25ed0168cd04225e893b731c6824f4f0128d83fb43252f01f4aeb6e43978aa17bb7bf25f5424d364ff7892fe4837bd79230463624ead5a376995d4fb076d8f2d945b153201483396ddd7a4806629d1238411ad798c2256366918c3708b6b692ac01787f74902169ea08bea09e561a61926dcdd120050272a5a63e73298b8d725b53d9ed71692b8db11d8565ba85275d08d509ced3582dce1a120645285a8b5c35a2e764dd13894ba53772247b0a4a1ce7a65b18961591a78811ad71b4d262e887064e96f5a388c57e2fc234d54285b5b390902c045b07dbce837b1f780068cc992e08705cf633f85a50bce1b9bd211cf814e9ec987a7a08174d99da61c1c9ee232648f65cd2bf9547c704ef20fb4ad57028dc5ca19f4d7dc6a07a207c876493c4f2ff3f8dbe4f29bc1e3f0c9a350b4eb3962fe96754486fda4aa032fc1910278d3b4bcabc91247fcb5168c8f77a2034951180a9f0505f2cb0aafbe56fd5268227a6bd17548f768a668b8639b969761b2d86e349f24efbf1587423d472d6457d3631ab9b91a7ad309ffb4f01c37b50da074dce5e5ad52426ebf0511a8f31f517cdd556af6bc224f745d54d794511cd4dc98a69210d60f0caf9d40fe209b144f203af8485b4b8ed48e85db564b5956c831624f96e6783a141d661ed66bd918055ffba0f8363b6f587d409c369472ca1ff4f24e2166d284dc138a062aff48b6538a10aefe334002bb0c2c19ccaffda14b0f5478a7761d659443adf21ebeb51bf25b2f08091b352bd1a9b206c1ba55ce3eaab64d6815a3f4ad5b8565c59d06d4de64886e564fb32b21ef6ef976026765d2783cb37cab04bc8e73ce8344ba6690a1297a903b1be9e7d11189f8591bb8760119a487e4d1316f34263b0537edfcb3169a094ce64e82a8091941018813d52117214593937a540c26714e40048592a5ec6d6a7bbe293814322eea9773e00cc1a714d9c001d36d2e61019c248ea1977ec4c54dd7b161b4dcec69812bdb229e75531c4431e07ae7f5b49d407d00df2f7e54e68c6d6ecba93a817b6750a93efd3d28f89b146d0827870cb035f4c140c14bf15c77892dc97c51a1bea8bb12a3d72449a9febb584ef764348fcf4a5b2acd512e3ae814b3cbbcfdfe51d1f330b1e594227f730b01ca60cc834593ce2bcdc08b28a769ca7b5cafeab1acd74b970d08f90ae6388ea9fcfe4e8b1d4e7e86aeec5dbe0dddeac564fb372396aeb58fd06ace81b0ee4f2ee13105326df367c2cc74184581af73d542041a464ee44c94c024b80a4870af54ff33641b5daadd592d6e9ebbf29ef505cfcb6968b8a28ec77da263ec38983ae301a5a373be648518ae3eedf3decbc264a0de2e72ecdd75e25331a3a0b22fe0af91f0314c0d2c67b12d7239cab1d0874e7e5b887ba33ff7d46ad9469b84ea6a2d5231868ea75b0c3883f5fb41b009213dc99160bdbb584517dd478a2105f8324118c53e6ea057aaebef438861bbe4ee5a58b5c5072551b6ba224c8f00f1d077d6efde112fc034baad7e0ae05acfd7375712ad8349c9e8c3935eb9f1cb7ac3d8836af2fb0f86ad3e43e0957c4bec35dadb67c53d339e01eba36645d6847c6d68596a17cfdea24dc52493d5e3e7fb9bf735a2f8a110f962bea57cffdaf595fc973fd915cc512c49ef5d31257dbe8847531a05ea602006ac0784fb29b93efa6f763e913d7bfe1f8afdfac85983a13ceeca2f576946404738c3d5763c586dbd5ddea84b4d51181549e416d2c9bfeec85bee6413362479de9a4bde0deae3f2f135c8d2566fe3f79a652acfcc4569d68ec6b9906892f0828c5ffdc111e398b9d96f272cbcbaea7cd231796458d111fbcce579052eb395e92745f0e658b68f4fd5c8db7b5b664f780d9c2c39b6bb90b9eb3d889ef9d54d71f69622d8999b9984056e78b65104a1ded33de34ff2ec23799df91bbb118fd2d35c63b825168215be40d14b97a600f11f2acfa2a595ccad024d23d0f875b473f445821dbd4b54d60de8c72ad331bdeb49e323da4dda1d705cd9eeef0533e2c648c25bac263cae778eac4de13f19ba82396e374a489b310d4d41d2a7ec228943dacb2ef40a7b77a302794f2197d6e74403232f4eaca30e7c45e47bd864f20f5f139b56935a87d6d65b91b5f6310fa8368d92b64711820ec54b4ef0afa6ad52bc1663b600d94922c6446a5517a6c9591ff2d6d34b5a5ee0d83beae4253061aedaad5e9a09b18ca8b055269db0d7203d9b5f2518f5bf7964a60628c6e19d64546102efb9ff87c37a984b89fd2cceba013a8b6639707451a940725e291d22769944eca80f703e321ae951401a77bb278c1f95ed3918d5c6ffa9585601c1c985f832f13c1fc157383aaa9f02a3c8c3adecc2ee8ced7d153b04255893b2a6f76c7674e713c63db9699f7ea3d8724e3002a414ed41f945152f81aebbf8701ad0d352c953e0777f008c6073a2a5ee11a503cbd4e1d0cb76be0da9fa13216c571b9bd4e36fc7f343ea4ec1cd61701386da014aa8adad328b71c28a50a88ad5119a1ef841a44e368e75da6ca528d627e162f731abac031e6fb5c900c181c3f74f5f9abc5e86d6e8fb29c7d46dd94176a59dfc930f32db13f5d27eff529b973eef379381f9ab6537987b0b8d598676f8f27b3b116d0e9bff76b02056182eb555fba061f5f7d19ca0c593d2546fd9d8ddb71524811da1987bc809fb09923b73f2d46aec81386e385b05ae09dc556da1c847f74ff00244ae227f7bbad6cf9af83843e1660899020221232d06ef59e2df1d84166a9e4e693ddc98e2568a72028764b5dcf815b738c5f17baf4057c314b759d5e68fe74723e5800463cb31669ebbb1419d5cec686951747e324456226db023b3078bf0d945474e386a956096c83d1d7fa935634067c12171bd47351c3d7c02de5a65f56b32bef8073f3fffdacf0d185abf7d987743a90d923ae7fc927ec750c144339890ed0abac99a046915eefad409039642fe6ee17ebe792d5dd5f5582e85af60d08be459200701c822440eb6d2ebe44caf1afe657536805dc80050083eb04a670b65a175c2b8683c353cc0fc3ccd9d01c5fb555cc5f6f9b9bbfd39a761b802e84a23484fa3b82240a36aff54621401dc0a7e93120d4595db1ad86714e0b78f4e18a7f4528736fe1a30f82eea30f56098e6817e4a09129ab8595f3daac9fde8d8814fb2ad2e23605346d0de643518a9dbba359f180fd0db77af843b2d7a629bec222def3e2ebbeceefac0ed8e3aa9b00ac47f021514bf7182103f3b2d5e86f9fc17c30ed3077eed0307c94f896c0db8c4061968c67c1317855e9492030433b9bc852dcc0f1fe83bc473b9c35a6a43c0dd76b06e1e725d00eb3aa4814e28f099a4048ea3f347426835227efba1ef0bb764d512663a47448d3b231c8b813f354d12be0bb87a0faf955b4e2a40c8b32dbe951a76fb68a140afb921a4d73abe1f9309803b090e06689c456fefb2218b17521f8e6f1366810fa849baba4d057a61a5ab41e89c6cb08b2f934d4d17945dfcac9feb43ccdf220c2c1252f45332be4b7ea756c902ce15bc584b27ddd999651527375ee2fdda52653ef236358b8d853477b209</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 880(Div. 2)</title>
      <link href="/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/"/>
      <url>/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>挂个传送门：<a href="https://codeforces.com/contest/1836">Dashboard - Codeforces Round 880 (Div. 2) - Codeforces</a></p><p>评价是，切完ABC蹲大牢</p><h5 id="B-Astrophysicists"><a href="#B-Astrophysicists" class="headerlink" title="B. Astrophysicists"></a>B. Astrophysicists</h5><p><strong>题意</strong>：</p><p>$k*g$ 银币分配给 $n$ 人，设一个人分到 $x$ 银币，$r=x \mod g$ 对每人有补正如下：</p><ul><li>若 $r\geq \lceil \frac{g}{2} \rceil$，则向上修正至 $x+(g-r)$；</li><li>否则，向下修正至 $x-r$ .</li></ul><p>求分配完后，剩下的银币数目之和最小值。</p><p><strong>题解</strong>：</p><p>​    什么黑心资本家出的题。</p><p>​    考虑一个人分配到的银币，从 $0$ 增加至 $g$ 。增加至 $\lceil \frac{g}{2}\rceil$ 前，经补正他所获得银币为 $0$ ，原先分配银币即剩下；增加至 $\lceil \frac{g}{2}\rceil$ 后，我们需要额外的银币为其补正。    故对一个人来说，我们的收益和他分配的银币呈一个由两直线构成的分段函数，从 $0$ 开始并且回到 $0$ 。我们的最大收益点在 $p=\lceil \frac{g}{2}\rceil-1$ 。</p><p>​    此时可以分成两种情况讨论：</p><ul><li><p>若 <script type="math/tex">n*p \geq k*g</script> ，那所有人贪心分配（至多 <script type="math/tex">p</script> ），最后每个人分配到 $0$ ，方案显然最优，结果为 <script type="math/tex">k*g</script> 。</p></li><li><p>若<script type="math/tex">n*p< k*g</script>， 最优分配结果为<script type="math/tex">g\lfloor \frac{p*n}{g} \rfloor</script> 。</p></li></ul><p>​    讨论下第二种情况，为什么是这个式子。</p><p>​    易知，最优方案不存在向上修正。设第 $i$ 个人分配到 $x_i$ 银币，则有<script type="math/tex">\sum x_i = k*g</script>，因此我们的收益 <script type="math/tex">income</script> 满足 <script type="math/tex">income=\sum (x_i\% g)\equiv (\sum x_i)\% g\equiv 0</script> 。这是一个比较重要的性质，答案必定是 $g$ 的倍数。</p><p>​    设 <script type="math/tex">income=kg</script> ，则必有 <script type="math/tex">kg \leq p*n</script> （答案上限就是 <script type="math/tex">p*n</script> ），故 <script type="math/tex">income = kg = g \lfloor \frac { p*n } { g } \rfloor</script> </p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, k, g;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; g;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> p = ((g + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p * n &gt;= k * g) &#123;</span><br><span class="line">        cout &lt;&lt; k * g &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; p * n / g * g &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-K-th-equality"><a href="#C-K-th-equality" class="headerlink" title="C. K-th equality"></a>C. K-th equality</h5><p><strong>题意</strong>：</p><p>​    构造第 $k$ 大字典序字符串，其中字符串形如 $A$ 位数 $+B$ 位数 $=C$ 位数。</p><p><strong>题解</strong>：</p><p>​    体感很简单的一道题。</p><p>​    设 $x$ 位数的范围为 $[L_x, R_x)$</p><p>​    由于 $A\leq 6$，因此枚举 $x+y=z$ 中的 $x$ 。</p><p>​    接下来寻找对 $y$ 的限制条件。</p><ul><li>$L_B\leq y&lt;R_B$</li><li>$L_C\leq z&lt; R_C$ ，即 $L_C\leq x+y &lt;R_C$</li></ul><p>​    由此可得限制条件 $max\{L_B,L_C-x\}\leq y&lt;min\{R_B,R_C+x\}$</p><p>​    然后边统计边算即可。复杂度 $O (10^A)$</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mn[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> A, B, C;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mx = mn[A + <span class="number">1</span>], i = mn[A]; i &lt; mx; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(mn[C] - i, mn[B]);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">min</span>(mn[C + <span class="number">1</span>] - i, mn[B + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= r - l) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; l + k - <span class="number">1</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; i + l + k - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> k -= r - l;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-Twin-Clusters"><a href="#E-Twin-Clusters" class="headerlink" title="E. Twin Clusters"></a>E. Twin Clusters</h5><p><strong>题意：</strong></p><p>​    给定长为 <script type="math/tex">2^{k+1}</script> 的一序列，值域为 <script type="math/tex">[0,4^k)</script> 。求原序列两不相交子区间，使得两子区间中数字的异或和相同。</p><p><strong>题解：</strong></p><p>​    瞄了眼 Tutorial ，不太好想。一开始想过类似于分块的思路，实际解法也差不多，不过只取一个块。</p><p>​    先关注二进制下低 <script type="math/tex">k</script> 位。算上空串，共有 <script type="math/tex">2^{k+1}+1</script> 个值，但实际上低 <script type="math/tex">k</script> 位值域 <script type="math/tex">[0,2^k-1]</script> 共 <script type="math/tex">2^k</script> 个值，因此根据鸽巢原理，我们可以匹配出 <script type="math/tex">2^k+1</script> 个区间 <script type="math/tex">(l_i, r_i]</script>，使得这每个区间 <script type="math/tex">S_{r_i} \ xor\ S_{l_i}</script> 的低<script type="math/tex">k</script> 位均为 $0$ 。</p><p>​    接下来关注这些线段的高 <script type="math/tex">k</script> 位。采取同样的方法，根据鸽巢原理，必定存在两个子区间高 <script type="math/tex">k</script> 位的异或和相同，取这两子区间的交即为结果。</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    n = (<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; Line;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    g[<span class="number">0</span>] = s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lbit = (<span class="number">1ll</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hbit = (((<span class="number">1ll</span> &lt;&lt; (k &lt;&lt; <span class="number">1</span>)) - <span class="number">1</span>) ^ lbit);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; g[i];</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ g[i];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = (s[i] &amp; lbit);</span><br><span class="line">        <span class="keyword">if</span> (mp[p] || p == <span class="number">0</span>) Line.<span class="built_in">push_back</span>(<span class="built_in">mp</span>(mp[p], i));</span><br><span class="line">        mp[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Line) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = ((s[line.second] ^ s[line.first]) &amp; hbit);</span><br><span class="line">        <span class="keyword">if</span> (pos[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l1 = Line[pos[p] - <span class="number">1</span>], l2 = line;</span><br><span class="line">            <span class="keyword">if</span> (l1.second &lt;= l2.first) &#123;</span><br><span class="line">                cout &lt;&lt; l1.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">min</span>(l1.first, l2.first) + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">max</span>(l1.first, l2.first) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                     &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> pos[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Lottery"><a href="#D-Lottery" class="headerlink" title="D. Lottery"></a>D. Lottery</h5><p><strong>题意：</strong></p><p>​    给定 <script type="math/tex">n</script> 个人，每人买一张彩票，票号在 <script type="math/tex">[0,m]</script> 范围内。设开奖号为 <script type="math/tex">x</script> ，则票号距离 <script type="math/tex">x</script> 最近的 <script type="math/tex">k</script> 人中奖，平局情况则编号小的获胜。作为第 <script type="math/tex">n+1</script> 人，你编号最大，求最小位置，使得能够使你中奖的编号尽可能多。</p><p><strong>题解：</strong></p><p>​    非常繁琐的一道题。先来看这幅图（截自 tutorials ）：</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307021737523.png" alt="image-20230702173756179"></p><p>​    假设当前选择编号为 <script type="math/tex">c</script> ，<script type="math/tex">c</script> 的前 <script type="math/tex">k</script> 名为 <script type="math/tex">a</script> ，后 <script type="math/tex">k</script> 名为 <script type="math/tex">b</script> 。则中奖区间为 <script type="math/tex">(\lfloor \frac{a+c}{2} \rfloor, \lceil \frac{b+c}{2} \rceil)</script> 。由此计算结果。</p><p>​    接下来讨论需要枚举哪些 <script type="math/tex">c</script> 。由上面图可知，处在 <script type="math/tex">(d,e)</script> 区间内时，中奖区间虽然改变，但实际中奖区间长度不变（<script type="math/tex">a</script> 和 <script type="math/tex">b</script> 没有变化）。故我们只需讨论 <script type="math/tex">n</script> 个人所选号码的前后两三个数即可。 当然，特别考虑边界情况。</p><p>​    输入量较大，需要注意 <script type="math/tex">IO</script> 效率。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; v;</span><br><span class="line"><span class="type">int</span> nowl, nowr;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calc</span><span class="params">(<span class="type">long</span> <span class="type">long</span> now_pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nowl &lt; n &amp;&amp; v[nowl] &lt; now_pos) ++nowl;</span><br><span class="line">    <span class="keyword">while</span> (nowr &lt; n &amp;&amp; v[nowr] &lt;= now_pos) ++nowr;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posl = nowr - k &lt; <span class="number">0</span> ? <span class="number">0</span> : (now_pos + v[nowr - k]) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posr = nowl + k - <span class="number">1</span> &gt;= n ? m : (now_pos + v[nowl + k - <span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, posr - posl + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        v.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    nowl = nowr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res_pos = <span class="number">0</span>, ans = <span class="built_in">calc</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> bl = i == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="number">0ll</span>, v[i] - <span class="number">2</span>) : <span class="built_in">max</span>(v[i] - <span class="number">2</span>, v[i - <span class="number">1</span>] + <span class="number">3</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> br = <span class="built_in">min</span>(v[i] + <span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> now_pos = bl; now_pos &lt;= br; now_pos++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">calc</span>(now_pos);</span><br><span class="line">            <span class="keyword">if</span> (p &gt; ans) &#123;</span><br><span class="line">                ans = p;</span><br><span class="line">                res_pos = now_pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res_pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="F-Doctor’s-Brown-Hypothesis"><a href="#F-Doctor’s-Brown-Hypothesis" class="headerlink" title="F. Doctor’s Brown Hypothesis"></a>F. Doctor’s Brown Hypothesis</h5><p><strong>题意：</strong></p><p>​    给定一有向图，求无序点对 <script type="math/tex">(u, v)</script> 的数目，使得 <script type="math/tex">u</script> 和 <script type="math/tex">v</script> 相互之间存在着长度为 <script type="math/tex">k</script> 的路径，其中 <script type="math/tex">u=v</script> 也被允许。</p><p><strong>题解：</strong></p><p>​    不会。稍微翻译下 tutorial 。</p><p>​    突破口在 <script type="math/tex">k\geq n^3</script> 。显然对于所有满足答案的点对，两点都在同一个强连通分量内。于是讨论范围缩减到同一个 <script type="math/tex">SCC</script> 。对强连通分量内的所有环的大小，存在一个最大公约数 <script type="math/tex">g</script> 。将所有的边 <script type="math/tex"><s,t></script> 按照 <script type="math/tex">t=(s+1)mod\ g</script> 进行染色。由于 <script type="math/tex">k</script> 比较大，所以可以认为颜色相同的点都是等价的。</p><p>​    对于一个连通分量内，满足条件的点对有以下两种：</p><ul><li>$g|k$ ，则所有颜色相同点对满足条件。</li><li>$2|g$ 且 $k\equiv g/2\ mod \ g$ ，则所有颜色差值为 $g/2$ 的点对满足条件</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[N];</span><br><span class="line"><span class="type">int</span> col[N], cnt_col;</span><br><span class="line"><span class="type">int</span> _stack[N], <span class="type">_t</span>, dfn[N], low[N], cnt, siz[N];</span><br><span class="line"><span class="type">bool</span> book[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//强连通分量</span></span><br><span class="line">    dfn[x] = low[x] = ++cnt;</span><br><span class="line">    _stack[++<span class="type">_t</span>] = x;</span><br><span class="line">    book[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[ver]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ver);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[ver]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book[ver]) low[x] = <span class="built_in">min</span>(low[x], dfn[ver]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        ++cnt_col;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = _stack[<span class="type">_t</span>];</span><br><span class="line">            col[p] = cnt_col;</span><br><span class="line">            ++siz[cnt_col];</span><br><span class="line">            book[p] = <span class="literal">false</span>;</span><br><span class="line">            --<span class="type">_t</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag[N], dis[N];</span><br><span class="line"><span class="type">bool</span> solved[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    dis[x] = d;</span><br><span class="line">    flag[x] = des;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[ver] != des) <span class="built_in">dfs</span>(ver, d + <span class="number">1</span>, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试染色</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    <span class="type">bool</span> Flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) Flag &amp;= <span class="built_in">draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">        <span class="keyword">else</span> Flag &amp;= (num[ver] == ((num[x] + <span class="number">1</span>) % base_num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt_num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//染色，统计数目</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    ++cnt_num[now];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) <span class="built_in">Draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: v[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[i] == col[y]) vec[i].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> search_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solved[col[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        solved[col[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[col[i]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x = i, y = vec[x][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, <span class="number">0</span>, y);</span><br><span class="line">        d += dis[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= d; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d % j != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> p = j, rem_num = <span class="number">1</span>;</span><br><span class="line">            <span class="type">bool</span> now_flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (d % p == <span class="number">0</span>) &#123;</span><br><span class="line">                ++search_num;</span><br><span class="line">                <span class="keyword">if</span> (now_flag &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, p, search_num)) rem_num = p;</span><br><span class="line">                <span class="keyword">else</span> now_flag = <span class="literal">false</span>;</span><br><span class="line">                p *= j;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= (p / j);</span><br><span class="line">            g *= rem_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span> &amp;&amp; (++search_num) &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, d, search_num)) g *= d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) cnt_num[j] = <span class="number">0</span>;</span><br><span class="line">        ++search_num;</span><br><span class="line">        <span class="built_in">Draw_col</span>(x, <span class="number">0</span>, g, search_num);</span><br><span class="line">        <span class="keyword">if</span> (k % g == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) ans += <span class="number">1ll</span> * cnt_num[j] * (cnt_num[j]+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; k % g == g / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g / <span class="number">2</span>; j++) ans += <span class="number">1ll</span> * cnt_num[j] * cnt_num[j + g / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当我开始真正爱自己</title>
      <link href="/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/"/>
      <url>/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<p><em>作者：卓别林</em></p><p>当我真正开始爱自己，</p><p>我才认识到，所有的痛苦和情感的折磨，</p><p>都只是提醒我：活着，不要违背自己的本心。</p><p>今天我明白了，这叫做“真实”。</p><p>​    </p><p>当我真正开始爱自己，</p><p>我才懂得，把自己的愿望强加于人，</p><p>是多么的无礼，就算我知道，时机并不成熟，</p><p>那人也还没有做好准备，</p><p>就算那个人就是我自己。</p><p>今天我明白了，这叫做“尊重”。</p><p>​    </p><p>当我开始爱自己，</p><p>我不再渴求不同的人生，</p><p>我知道任何发生在我身边的事情，</p><p>都是对我成长的邀请。</p><p>如今，我称之为“成熟”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我才明白，我其实一直都在正确的时间，</p><p>正确的地方，发生的一切都恰如其分。</p><p>由此我得以平静。</p><p>今天我明白了，这叫做“自信”。</p><p>​    </p><p>当我真正开始爱自己，</p><p>我不再牺牲自己的自由时间，</p><p>不再去勾画什么宏伟的明天。</p><p>今天我只做有趣和快乐的事，</p><p>做自己热爱，让心欢喜的事，</p><p>用我的方式、我的韵律。</p><p>今天我明白了，这叫做“单纯”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我开始远离一切不健康的东西。</p><p>不论是饮食和人物，还是事情和环境，</p><p>我远离一切让我远离本真的东西。</p><p>从前我把这叫做“追求健康的自私自利”，</p><p>但今天我明白了，这是“自爱”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我不再总想着要永远正确，不犯错误。</p><p>我今天明白了，这叫做“谦逊“。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我不再继续沉溺于过去，</p><p>也不再为明天而忧虑，</p><p>现在我只活在一切正在发生的当下，</p><p>今天，我活在此时此地，</p><p>如此日复一日。这就叫“完美”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我明白，我的思虑让我变得贫乏和病态，</p><p>但当我唤起了心灵的力量，</p><p>理智就变成了一个重要的伙伴，</p><p>这种组合我称之为，“心的智慧”。</p><p>我们无须再害怕自己和他人的分歧，</p><p>矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界，今天我明白，这就是“生命”。</p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

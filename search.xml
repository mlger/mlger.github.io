<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于抑郁症</title>
      <link href="/2024/01/22/%E5%85%B3%E4%BA%8E%E6%8A%91%E9%83%81%E7%97%87/"/>
      <url>/2024/01/22/%E5%85%B3%E4%BA%8E%E6%8A%91%E9%83%81%E7%97%87/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="66ff0f662acf4e732b6c3b1cedf91fd6e61f23c8dcda1d204be744bb6b4aaeaf">7feab2e74e7ac8c26f5b44aac0c37567ff466b63919be9d0ba0ba966bbb2663d32df72e4636f9a57d9b45e369f5d3b81c009155d2629396ad68c367e3b51894426e559d4aa911a5984c666f8105313cb66b68c276b9e501a8d135d7eb8be12bf1ec4ec7df3a503fb0717280bf17e666f5faa836b57c159af16b35df0f0724d46c8a5e468d24445dc51cc920897bf4d04966e64a83b54137a3c2fb21c30ede1c2cb83690a826d5005a581bc10ee1c333d42d1cadf66f27f4307c66744d5908be754ed957b0cad9093a82061b009b189f1f402174b50486b1a2c4a972119662913cd6fab339887b2d2a861dbd80dc181d29f5c7900cfff4554f472466cb66e4d8bdb7557dc59075d1a2b8513ad0942a38720a4cdbe11f4724c516090e50a3d7b92b39faad74d88dd12b25f3f0224046549a69cfb1a822a234533e2c316e1fded15741d99a155f138739342d769e455787067c1382180423ae80417c9d19e806a161c637765f538d6f9f37e8bbf772ad97190fc2480f07bd9a32e6d83bfebf9814f8735a22ffb0aaf92e32d69b3e2f18861249df70c9f0d06726dda9da3748343d9b76e15f05b944844968f79ea67f89c1bfa1981c0ce411b10225e206f87ce213e2023d0ebc40323513e464edba458e137e8b2b98457cd89d504248d55a5d824897364d51b0ce9c25fe18d6bc994576baa00a092ad3d3d1fd47db8ea574cdc32490b12870ae3a8f110f2db40cb2b4147b66d74b64b718a637a80d0eff9422d80499cb0fc3676a53e465517a6bc162981a44732c24050c654154ab756de23e8321f00f757bb13796b6b754241420848cb63c84f27095c28828d485eebe88f5f58f7da47bed8065b9fa8bdcaddb543915988ddf7b41442da77d970e179e5137de4a313f564d7f63dd28100a690ff3879e5789a723351c38da2669499293bf914d0af3aea1175f9e056be872635ba22752f4191e13933c384fa9c2751fe73eb9a000fd5aef983d4099b43f97dbf404809bfe2bbda4d1c821fd6733c8004dd92f58b587a5ab7cd12748bdfd978f00c651b6c1f57d7858226a59d692894e452cb676e0a7308abe0e0cdeac8b8f5a2cf827069775d1a868b1229428ba40d2b83320595b26e59c143174f8b1e038cdcb22c10c9023c4e9221b57f89419a7ae00757cddb0cbbab5dbd5c3c473a40d8367ecb1ac92f465455a34278fe5e14929e42dfece0cf6d908376e2b4aff2c3cbf7261439418f1483adcfc43dd506a57d5b62df4479144f5e4c4bb9da59c3b2b5257a51584e8fc6519fdddf1ddb29888a0c4147322736054db6d3723bac96ac3ead72484682f20d34ac281078cf95eb67b4b0129dbf8a7e7a780ac18b12e1078682ccb1bc357f370320c44d84351824d7fc988feaf6a72a0010cd62a0da55babbc2b23434d61997a39053ff1923be96dd259f0dc19cb032f1bea2c66cd61dda4a9e1e09d2aca40aade111fc8efa393086e4b9748a8ad3cc6eaa862b2c657adc47995744e32cf2dfe25b9f1f6738c79788d42a080635fd63f2dc66321b3191a575de88141e3952bfb4eda806c6520ce24cc07f2ae2455200fe622cc76f02c4bb778b921a55c43cb947ceccff698fcbd50ac458e0958c40cad2c69371f9bc07fac46182d09d7f60def1e73a7d606297b55298e000c5b5882ffa1768521240424b59cbe41279a24bcb6c9660b6afb132559a83f70c780a579f98bf9b4edcb3a7d515a2cc3778e43baa4895cd440b610f8281b48ee1b2dc0d596526875958046fdaaae01984525cc8f3753d5941919139a6950051b0b8b2ddb87a06eb56795d36563735976ad3b7455026bffa03691f588d7d15287635384f834ce168b1e02822acfea0b0b51d34578424a26cd168aa1029ea0f6c9722695f20fdab1bb25aa43320ef92204f773af11f97d9aada3345b6585a3d1234c9d3fd5ac118b7aee81fc9f092c1a043644216ecd6f76b0ada533ac68dc0240ede3ae77eca6afcee3e54f79432282b9cef198672b09269c669d30014234938a1e4ff04676d28b3156bdd1d6f22df59eba898f01b5af2a1a3f8c4b776bf88b159bd18f760b603cd7ca825eb310d3c733bf59ecd49486c1a817398b4305bf612819edcd305fe130dcfcf5178d81bbddb6926d7c583e037a183d4fadef76ab25e837d19aede866dd223808484c0b9a0f5bdcaccd1d1754f08da7fe32ab5760e1e7c3f783624f062004ecb0094192c52699ca0da64c67561f72a8af06448cdee63f438dfb3728d45a4bb9438c740c2ac86220ca63cb50aff569213721ffd43a0d6b599c617e0f950581fd7f720892c7d795618cebacfb553ed9c562c996ce1c51cd85fba4fc73da585f05b3b5bc3c551dd33a5d797632ec802b48119a9145f7010be5eba73e6247e628babff270a6433fede34ee33a7f7cffd7ebf308ab431eca05eb45d3f9c65376ee4fcb5a3b22a55e760438fb3d9d0823316dfa34fb2dbb332af9748ece2a1f2a3b7fc1d1c117f32448683d9c2309716a4bb39826d02abe88e70ab49ff472f9b053a9e8867e5dc7aeccc9021ba4f02e7cd0d88c5e9978b773da84b5323678fbc9204e0337f05f4533579620d78eee80c5e44a265c90965ffa7ef70ec50541954967fd5f53c0385ce393b5d6d801f9c0a1b1e785c892b986eaaa4cee7fa9cac6c6f7e4cb6b4924d06a86afddb8fdec1c72bc9bc4e60fe6ed352fafb805be69ce6ba35889bc2ed71438c1b20cfc1f3eaaaeedb823fe59bd395545abb611ba74cea4a973d34094376ec54cb9a7e11b6468a4b1b9a81c450e418cbe16a1a76124c17f845a285a30de553e7b8cdedfca012f8888aca8214fc740aec57d81a8af272e38bfa50a2627defdfe6429baa9a686b3bbae5254be844fb130d62a024ddae120729642aef40f283f94f600867f05253925f0d9f96848cb869ba8251d53cc4ea6b387494831873503f0eb636c10a0d703e145055b4ad2f65c4a15f6cecd80227e45d05c13587f35f6ae5140b8c7db89859ab1ae1ed068e8828f9e68d4dfe425a5755636f637c90d1c73bb1116365a940161eb3002e1e0e11521c0d0162d8e47b8ed36613dad23637dcb5f5ebafa1170de89eb7193d9836529e74b5e68634c4e1b57f2a72ce68789309e00098eacc6f115b58357a9d47a997188eec55f847392d60714b23e41c733b5476f88eb2594939fea958d65a0ac10db9a43cdd5d72b2751ce39c50efa7cf77dcf309d63b3af2c5c6708cb21c718e1d472093ebe1a0d47cc1257b59bb245aeb4161e6f7632a7efaa02277ece33860aa2ecfca62013d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 抑郁症 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>走在自己的时区里</title>
      <link href="/2024/01/20/%E8%B5%B0%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E5%8C%BA%E9%87%8C/"/>
      <url>/2024/01/20/%E8%B5%B0%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E5%8C%BA%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<p><em>作者：来源不详</em></p><p>在时间上，纽约走在加州前面三个小时，</p><p>但加州并没有变慢。</p><p>有人22岁就毕业了，</p><p>但等了五年才找到好工作！</p><p>有人25岁就当上了CEO，</p><p>却在50岁去世了。</p><p>也有人直到50岁才当上CEO，</p><p>最后活到90岁。</p><p>有人依然单身，</p><p>而别人却早已结婚。</p><p>奥巴马55岁退任总统，</p><p>而川普却是70岁才开始当。</p><p>世上每个人都有自己的发展时区。</p><p>身边有些人看似走在你前面，</p><p>也有人看似走在你后面。</p><p>但其实每个人在自己的时区有自己的步程。</p><p>不用嫉妒或嘲笑他们。</p><p>他们都在自己的时区，你在你的！</p><p>所以，别放松。</p><p>你没有落后，</p><p>你没有领先。</p><p>在命运为你安排的属于你自己的时区里，一切都非常准时。</p><p>好，别忘了危机与奋斗</p><p>难，别忘了梦想与坚持</p><p>忙，别忘了读书与锻炼</p><p>人生，就是一场长跑</p><p>New York is 3 hours ahead of California,</p><p>but it does not make California slow.</p><p>Someone graduated at the age of 22,</p><p>but waited 5 years before securing a good job!</p><p>Someone became a CEO at 25,</p><p>and died at 50.</p><p>While another became a CEO at 50,</p><p>and lived to 90 years.</p><p>Someone is still single,</p><p>while someone else got married.</p><p>Obama retires at 55,</p><p>but Trump starts at 70.</p><p>Absolutely everyone in this world works based on their Time Zone.</p><p>People around you might seem to go ahead of you,</p><p>some might seem to be behind you.</p><p>But everyone is running their own RACE, in their own TIME.</p><p>Don't envy them or mock them.</p><p>They are in their TIME ZONE, and you are in yours!</p><p>So, Never Give up</p><p>You're not LATE.</p><p>You're not EARLY.</p><p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p><p>Well, Don't forget the crisis and the struggle.</p><p>Hard. Don't forget the dream and the persistence.</p><p>Busy, Don't forget to read and exercise</p><p>Life is a long run</p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谢希仁计算机网络07-网络安全</title>
      <link href="/2023/12/26/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C07-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
      <url>/2023/12/26/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C07-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8d86d9aa835ab5b3f88abaf4ec6b2199f1c4cea4ea4bc51db806222ad56feadb">4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b4288053e71317bf3667b81f60a5bad14183829efb37000826653c323b50848ef840c895306ef1aff018dc00050747bc2a5c6cab4953152f457fa13b782cdb89afa918adc26816f64a1445f7f4c25134a66c266f8c0a49ecc6077d229be00a8246afa55d51164bca9be3231842bd5681564e51ea25a0beb862f60422804d8cb5d7ba750631a3b5d2bcdb3e6503986d3383d81449e15d05f2c5039bd0d9edb8b1340767bee82b251f89a97aed79a254c2b8ed3439dd6cdc97a150cefdbddb9a0259c87ad56e24ad9b3894544e6cb2c0076cbdf6806cc90ea2c3cab9f309ad3e58ef76148d644e6cdab85b05f8e5abb185c83b5437aee5178c26b63610a4503a3dcdc3a886286e4c7b143d62f7a55ae9ef6b7539528d68a73d1a9ac022bac2668f70d807d96c277bbf77db7f6bf2c4c2eb5ff7bd896708625fcbd3d37de82ec34c5e8f420579402cb759bfca4ea3c64fd33885f81243230a506eaf3b72b53852312859c55614a8cf3f4dcd3953f486d9aac3eb9bcbcc815dedde80deac8cbfeaf5083cd9f248d717b864dd55e657df775e514455366e19f8c310c68f31f426e269dbdd845ba91bd817f8369097096e091da57f8d80b94ceb4be48bc02eb1307329530941815e65111ee570a711b0c96efefebb443e7c53a7d7edba8a85454679e51faf3014d24f3332637fa7971d34fe9e71f7ca66e9702acbb5c5b5de310836e20403d3236ec8e99c420cdbd3952ea54e7d61f5d8340a5fa58bad1c7bbe9bdb1448323feb925726890181f36996684cf3b8433ef12a92b503d0e8a4e164fbabf1048e13359d5891842ef8a771f3f016ea7fd696e515640c1bd2c1ac24d87d5e1d0cafa70cf19866752c680e82688235a51e5fd899ed749a84569ceda9e885479968c4fade8ba3ddf8baca0fc1da849dab1004b549eb4db43332d120c06157e23117efd7047361b5ccdaada0ff205f331d174aa52b883d91510ffc4ea431f30d2686c1bb5b78ed4d9061ea7b90417478a1fff0c7fa33ba9d58c9a0574770e670e3453b8baa5f66c62fd4ee7dd483813484e706d2add7c2484be68e73bafc4772e7042dc006d8b8019b6b8d3e013e3dfeef85db43b9b4fdfedb064695aab2b6683c83f321b036ae51e6ff61439fa836d789c16dc8895beb85a7e0e4209dac39f15290a102e80016b4dec58004a662a6c3aec51bf23778ad8f2cb9774ad959202fbaec0c56ac27420a606ebeba4735d3f34fb3073539dbe2f311974b40fc680242e45f2528745b5862e3c52dfe3b41b8131ac405ec045697f3aaaf67822df7a0370af7ebbf643d849bab3d5a73aa948e428d3a493fdfd5d53f0c0ba8f7853577a6779a5618ccd540c2ed62e14a9e842202bfed85b34a92128b8daf05426700625a7e50efc2b2718bf58f6e55f555b7c1e1ca9e7d49323e59dacdff239dc47c47bc77bbd7f32213382fea47750e885899445d2d5510c7c5f631f61a27bfea08ac15cce1b64805e5d33f4295d79787a8a498a90d0315126be6aa5158a4ef7f415385b423ff2252b3bae0e520d79a06daa6a3fddd3cd9d1de57a00b65f2280ce9c8068366080eb4a50529c3b80765953f6a911b11dabe2644f106b1f7df1ddea670421a50a32fe70eb3625ed05b39b75f3add558b9a450c60a0ecae124be5def51857a00019bf6881acf244f6d1d4480f5c1ee99a6a889638bf1bb52483bbd290995729dc29fa021d49bd67a3fd561d4d886c0beb98630faea89050eb8bc4803c6cefc2bc5a2c278219d878f53735c510a75465047bd3781d68f6fbab4dff1287538bd5445ffbd5e60aac484c72f6acf66395973cf38eeb0c30915e30548ad01679e38a5ca72b2d65aa18c2c70ea041d9690a5bede5a73fc427eec934d2cfa32aed6571fbc052060624f3e5d35a8dfa1dc7cb2cd452085ddc82225de5bdd12c5d0fc8f2b7dc7826e39e7da0da794fda45396a03bbc0ee7cd7b4ec6981bb51765dd250834d9aa5f3fadfde55bded667cd43e7b4d52ba69fcd62ac3bfc2e5aa9ff5f44d356ec691aeea46daef2d333ad06151deed8c76a919bbcea4fd9477f520204901db14f08160a144837245fe40799252b5df89384da702a906453304660cd7ded580ef6804e2e676385d9154fc7ae812dead5390b1369a34333f593cda99a34b73c93b4be292738cd6142360a6ff61f8e37af7e0cf6dba5c86bd1e061640f8a44a7fdd6a3cd210e4f84185a70dea97cfeada1c54716357671473c5e5070c3c0c248362322d41f5e8a4b989b8de6cc4e8b318da2a041b5a793378e315383ae35c8be794c1e47c404d0ffa09e72a0f166d9f8e247cb2b1f8e965fdc3243e9a219bdb3d75ae418336bed7ddd4bd37b3eca2000505f641b12b8337c5d77006ada15e80b975483a04a95778dbc2310d5ddd56e51b1b0ef161d3709e2d8a32e0b621227196fec9448b257d132e166a3d6d10437b165b96f8f7e638476ab9833b33c991117560b83395ca381eec6bd728bb22219d4604b52348de66a9d79f7b10974db20b65886b08f586fa4b06de604c4e8ca78f3b78c843b1bbbef81e997024851d54c43c5b103875f2063a48612bd5082d6f2bae33bdff7eedd7872d4b9575e1c199e6bf119e67928e17d49bd82001c1489fb200ad837ae70c107ff9e16337c351e6c387abdba7ea36b3998dc146ae8c640419cbf2fb27ac27018836dada28962486d8273a284f6bbf2c23a5cec5a7c75e400e3d9bf9cf3da4e2fa0e06f294b95438b95f3ffaeb7f71051802a2079981a6d42e294a41fd151b910ee9be43704fb8d9b1ab59bd680bd0eb7b51af98d5187ed3bc97d7727a68c71f5e6d4770a56f873c43f443dfa03df0675566a8fe157c1bf065766c1feec702cf280f33464bd9c5a31472cfdd558acbbcb5998a43e8aaff9f390f13e523565dfd405e6cb928b28f718ad4e1c8574426f6643e2cbb5bb6ee5987ef3fe5667b0bfd4f18e7a31cca7f03ca823ea288734d3e2a1b77f3fed6aab2ee08877af85e9152a2623110353d17b05d17891097f9c70cc70211c4f16af0551fc33a9bd388045c626ae28f56e95fc6638108e0b7130792d34a08b7d0f8bddf27d5dc885961271f25b8f37bf2c54f2a81b43fc5289f1718c129307c5e0bc4bc18efcd3385a97aac5a59e8277dc0d94a1fd8304a44a31a121f7c59a856fd41f5cef4e767415ecc0917f800fd156ff54cfc35d83ec83f93a7203d4aa3c419a1757fce0b2ffc013b0915d86b743bcfc68dfc0f7deaa5addd62ea6af05084997a0bfe1ce8d12be0f9564804d8e93d753ea28b0a50f09707c45069327f772dcfeefb45174d3562d3baeb846f556e93732066f2dc0ec3354c73a5506fec02e861db209b313c12e12b9daaccb9c0a274ed569432d76f15d3d686b43d7a9537b23c8cd7908f693ff1003d9d51541bc34be216adb3dc53752eff68b6af1c489a83aad1e849a6bc25d932c68898f690d6e90a09b9a246c89320320b1231a1942872e69a249efda1840567928fd9f9e612ba707695e9a7bb91de5a152f604b9ca891a4910dcbd408bf1fccdde0fd1298852f18c2bffd6280f90d9c24c645b68c5e53df7488a127a4f4177c22c38d3eb4156f9ba1dc98332283481d08eb9fb24e9d21a3fef15830da6dc698ebb8b3cb739a66271bd9d2f6f516434371848170c0b3e41936941bc8989239226ea058fae0a556b4111e1873f17a9fb041f36bfc32faf430c07060f58f717d623a0438fe771665d3196562bfa150583529dae9b195fddea498b24fa2ef233dc49e586143215910af8656b4146f8cfc813a3a087e0bac00972422ea843b7ff9b369236958ae0fee2d9f3aca0184ac40ef66a3873de2751852bf04f41fee2e98cadbc8a70bac128d3f065c38864624ccbf189a523bf03a32bc3146e5bc9ba6d5d5d1d2026ff87e5b037c393050a05a0a94bd9683809043645536f1226191b7406dbd5f80b1f8161d19f86f1580aacda0213f680d60244643c684de465b266a5e40f71ee0d73f3940ffdcbddb5e3975e9fb748c167e25cae876e1e1dcc80e4af20782d6ee615611e971223edbc03553ac8725071c6c3e6d74d8605059ff051a23d9a635499cb8d3804e7e73a0a486ec9d43079bab62710e8addf55f8366b7b7211219a34c0bccbfcc0110a31ad135d90250ece566d427768721848a111e58ff7a850610946f01d21ab58a95b285d700b00680c0dfc45fe1ad5faaf332b686b289856d698bea029d51f4aa1bef6f0717cb4dc99d474151f4dc4b19cddfaacf500bf2679cd101e4a98f255c4903e709d32195b3fca72f72892a79141107acb5b0d639efeae1befb7190ff00cea49e0f3eb0fd82f8d72a4f3d71d4d3e793f610528d02dd5e0653fbf7a06a5d263c5f03c9e96fa148eeaf898c7b2db494d2a57ee77618406ecdd99c82954d2bc8788879f46a24d876e3e7f0e5d98bf3104239da655b791d1f6d465f023ec63ec75de4fabac5deef3c80202379719117e44e9c34abdc9428732fd7b60ad7f745c99d8a476cc94a6332a48a8db94cc322bbc60597b80a1d849d202656d41243d1b62830dee1b3367aae9528c33587dcaad85e8b336c70da9a86faa821c21ad840568c5341c203435d51f4bd12789830c857ac5d3f2663a79d55ebe5119dee86a897a5e3a781af03ecc8a4e3cbb9ecce333e6f035fc953bdc8021cd8da94249c90ffaacd9a98659e0f1cb38511034d42f2aa34ca1a883dc7b82f0432c9752546138f0b9794a7f57e128e6581c607b3950aba887413d76fa46be9f4df26399b3b31af286716681f96cc6ac2ff02c3c38befc1a12305bb6c2216b770089ef146993234840ea3b4c4b75689972fd255a7fbb2e1bb517325cf30700755fbf0fc2441298d16616dab9593ae8e4f8382c996e546d536d9e0b8fa7135dc70c040a81f3825d3246e6148dba9eaa4c7dd3014a377d10eaba063a76dcc52bcfeda3ced819870b65e34c8b7355211cdb520e0140041736c3570c6bfb1d0d317321bc7cf6b42e002b8e3c298b7e72b80b2c7122c36f8208a39a0669846a29bef5f004412d6822aaae8513ddad681775d7837503f847da0edf832d95d075142316669c96f71e9897cdceeb586d8ef6e8dfa360bc2ac1eedbeefc12c44a90646f07a7787f53e782209181ce4b12524b3006bfe77f8a504298ddd05856e597b99022b6fa9e3e1e8a12dc790ac3d1b91dba214b8eaa89bfd5e3392ab63a87ff29a581e4d112fb4f1310d98761352b5a0bbb7db1894c12c9693e1b0a0c9e09fe07717fda18e38ad594f2da86b1b8bea8f53977c638cd71983c6349287a912cc9546cb5147df3a965cc10dffbc57039f385463b07ddaa08d6b9413085661dc6b29f044b4a635d8a4941ade8e0ca8a327653654391f78a513d87a4d42f91c0ad5ea085d68f0a976e215541150cdcadb630824fb365093410c52b273ddb8efe22fef117f02dc5ca9ebc35b69cafa6ce8e59dd696002b7158ad4cf49844a4d7dceff1902cc6d5a126cef8e99d9d68241f0680ce485c4dbb6ed80964e4155433da0cf80746a45c2b66bcf43da21a1b7c9ace698081d7a33a7568f6f8de4e03316e8158e75950a28088f0110c1129b43b3f0968f5c9796c4aeee83f666fbc5f9a40ddbb65c6e094e2b9e204c8354fb2f75129a11be735ff170a60ca45d815cc33fe9b272adb5df31f2c2b11b32e9845fa213b93889ff87ac3eb3708772f2d7d12f35739f7df36d2d3d910f55bc7b9e25ffecc9e4d794c3ecca2b764a26e895e1e1a623482c7ec5c4ed03bb3d55961383944d24d47e7fc4981e0106b796a8d2820efc80b2c7f4711f1b561aac6537be300dcba5a68f5cffd0b078a63b425f46aa96b5e1943b97138880223c0d142b76093897e427b98c2d857f46df85effb96b34d7db6b76fd3c26d0074d91b22abe74be0cecb70aed0fd13977af77238fb72efd18454f4a3bdbd2545be880fbb614e54e48840e57e10dd344ce182a52ce56a112cb41d409f6fba77102fd3e537562a74243a79aeb5ab8bd990644112c1ba865d50e6d5820519ef2accd95a725c295702b83c5f3d03a0904ea6a1118d443ba60e5ebd37f52d2ac1432344282dd3e990d8d86f7f5e324b0434c93894c3cc77734bba8d43746422a59b4d84b72844cc64d56a490f18e3736619131b2687bc68671a209760679a543a08eab74d6b1af63f01ed0ce72eab5c75dcf3873cc634f2453c1eef55e5f5ccf15b93e2dcde691acd456d48de02402a44e1d2c0234211c061410e064d2c65146f42dfd5e8067ea8ca003ff9f9b37c3c82604d7d6787582c5c0f827c493fac47ebed45a227e72727e9dbffce52056231c9bda5864f9328aad57c06ff419b87a2af8e8947adf6b78937e9a67a50b9c9e436b4e9da94f0d131e660c11e9b87296187460c1d24c8901d4327f22590022ac34dd5b637e8f03a5b82770126d6e370ea89733c1e5b1f38e8a90c21444417406e109f631e45bd1491a5b6ccf217fce86ee42ce93a6fb23cb6aaf8ad2814335a3f07704804657d4b06f85eceb8893a32929f9999be3a0edace9b185ad41de3a8637d54b27f43d8b59f59d5f6e3e0458c04ce8ddd9bc77338f2606647132931eb50e5d06ec801178c9f7ddd291a3a917adf6d33e22840131bad214e7f14aaa00f3362ea1c33cefb341606f40957cae21100bc68d49d1945bf81b0f64a9a62c3cce069f24e8ebcee23b80b468e1572450f47056c3731d7cbb59e5874ba739aae9c09c2e536369f793658689fd5af8138e3a111c260c8ba525fe8cbc3c8b0a4f1d2b55b588ab55c7e52965c46c464ca599c15f7e67d8d4fb57d6b8608719940c7cbd881eeb66beee1f656ef33345910ce57aca82348326e5a079bad823f1e0bcd7d4db6c576e95c295d5ba15e79dba19b69bdac4e967a4a67aeff963fb08a0b49b400120ad06a1adab4be4f60572262adc1815a33efa0cf96727b418e7964226ef4791ad1b4fd5445625720ff6cdcd5a53be05afc012621b01587a41f4b166d5daa54eb8fd4d95c8b34e845031f309a3d1f095b1d2965b896092c34e0ee15637af45cdcee0f81fdd4186afd7890156578361f3b36f876ea857da5e35f5095b60ca0ea217a22ce0d0115114fe6bedeb2fe3bf4298c21d9fd8959c6aba997e44e4f8bbd157827766e20c265cb95b2346dd6f5f4df4c58d8d739858967e9d26a17fcef605136e9b8ba8408f7672b902375d8939efa186b9a27362079666a063f9e2a541ce1a6d1fd5bdeac3d984d5e22bd34f7f763f308714cac816ee93b7db0131485e2dac1a457530b8fdb49e4cad53f28dfd7ea0d46d6ddb8d6e95aeaeaa3327fc1b0133d2cc715182f4802e2ba14ae78c1c64ccca2c29158b8869f4eed3c342d1990b2b291f0964e09e0f06c3006fc10de724d0ddbafecd966f05ccad24cf1701e8c90ddeb73b99a6673534a915654d795d56effb5796daae26159aa9175deda10da0c5b1871771002458853efbc25ac3f73e3dd7dbd32ddf6cc24fee752d8f6ddc61abb016dabfea5c9e1268837b9caca7db481d14997b1b037cf76a463b15f964087c7b3f4b94570cb06daa4547fe4d3b99ced18a43b5a2a49e5d4384f24957060ba594a86fbda31e4bdc4ca942cbabbf010528d53a28851495ba08bdf6478e5971082aa63bdc0cabcdcde9c8fd06c824c2c523bf4fd0f31adb5eac1d4e635f246ffa4def819873b4715a370e5d7d90dc94efa4198b962f41fe60ba94f1e84c00278306c7904e259b6d97a0453635dcea6761e2cb4b41933d55c31b017e9e4c5705fd545aa4ae98253c9ebb0c6b3571a72b3982d2369dba87bad472c972a11aba158f61bb991c9aa9ff140d45098600508a582a205e094f6896a964546418f42947b6e2d90ea83c203b5ed13be52a62d79c55362e7e4e9a64863b4fadf94b06db053b80bf7f8512a54b7f1f5212815348ef720a629e00a1affb3fc3968001db861a69d23e91c9ea4cc875cd13560edbf941ac1dbe32be2225ef98a2589d914595fc49052dd584566a0a75e7b29ad4557b39477c4967c7a8dc27b86f28373714a79795044af36de486b851358b8c46746c1630fc8fac29e25b11e8aea3fd6eb52de54d2f272e4cf74d5b9213a5d0fffcf8e3a529eb6c70cc9ec1e1e23c9df38214386a8e216e8cab5d834f3c48b9dd08adc4b97942b6a52a2a4bef70b898fe0392a29e56ab57b73001fcefc7535123f7fbc05d85c5bcfe089cd0d29376e337f93a0a5e40a354bcfc3f3ee4c1f62629d6e8176f053a7640d25f7de2f2fbb3afff8ffeeb3aea7a181fccf6f44d1538cc6fc678d9e916844d9ee7eba1dc8f7f3dcf5bdc44ed96fd2df8c3c0780abf6b5a73aef6d20441ebd6607d27b3c7657013699a0b02b2d7761ee370b8b96cccd465b7eb8ae03934662e9f9f0f2a32a37d3efcfd53ee5ae7639e5fee7de60ca71e80210c02f6292bc57baac33fab8c487b091570dc40dedadd9c8555fd5b7b4efbfc1e10a2e468b43b40dc8a726a5f8bcb0f2763fab6d6335cb0eb633068c1c9ce6dbc8e107fee4475d385d1b9541d873801965c395f6b5944cf1c67ed08f83913c86054b76cc8eb87017a9fadbe5db9e44e608efda979b6297ad8bc55aecf7e00a72ac949a032c30bfab4db670c7051d1d1b1d1f218427213439392a93f7da260146c363d6ae1e597fabc8732ae8a333cf3c4cebc4b0a30d87b72a91917f80527a95782b5a0c488e192b3171595188f3295aa9bbb56a75639e78f24a2e93fddae5bc3a963d818ad25aedf91495ef728a685e4f90d9d29e9acba7a984fda6106c35390e4df81b20f7d1890d5c6bc8be3e208c4f91e636ec7985c3dd7d37e8c3f33abddc6ef701072744d07fe12b2377a6d1741e1a478e235a17c80f2156388699347cf1b2f17f91c032f75e68b421c3420101d355b8ed8c5cd7884a126b40143d81fa8860f22aa9c1875ce7a3eb114f1262caca348636a87b8c475e6cb4ea900e85a4c6a648b8a6e6577681844f15550b374245bbe2b48c41918d1c9aad323e5f6d812e24d871dd1eaeadcd0a0c5901aec8f03e0b35b597e46062070478ed59f23836d1e1abe41aa78456b6a15f709a3e8cd043f7e6d499c5a1d3f38c5a594ad43255c5cee891c71dc0fa73ec0640a846e3370bd3f8e5eb195f3b72e1c74e974c815069ab39ca8d322103eaf7fcbdb3b4cb0c541c48137d99f0d742779fff7722ac528b662856c1f00ce43a6f9375802fbcda9e87140f83bbbfa92ebb02e38fde3ae9e017b7248d389532549680e77bd7610c271d157b493b1164ce7c28bfd6767dff5794b5b4833c7e70ac8369ad6619b4ddfaf5e50d94debb6477a015c1691a3476431f34f562423f62dbc8f3feaa05f518c57613a8f6659c7295b9c3b1abf7caba6351b6a0c98ba60caba176df313409afe3d62d13869f45d768fb3d96168ad592ca1b57b9ac7addb8d338d68469a4cbda3c8e62a27010c5788b81f5e903a764b0e19b5ba8dc5e140e28f9a95500726ae81a17b7dba3bcfff0a579bb5b1387f21303f00cb384424b819e4d337a5bfcc4dd02b1579d7b9b542f61ef389accecb8f77c65abce9a6bef8982eea54b57e78e8c6f97f5039f31b4f02878f83ced9eaa91f3c3d7a0ac18e6a92490fc9736e5ea583535653d634bf36d292f341a853e48dabd13e0c8ed2c414024aaa4045e3576da08154f5f1722631ff22ae4455cfeae692aa3908aeee3d77b64ef69d544520e1366a50662b4897e57829d273c607bdc5c64181af0c26187557005385dcd3ce3cc568b0d9c8a4878b21afb9d6085bfdc1cdabf89dc5ba98037bf4db70938fc6903d43f21d82ea909ed152e2ef60b6c33d0863fda3d374d539a9e945a009531d863e67155f985a66062159110081af4c123366a69bac07ef3b73ff92448a0ff8352cdd6768b858d201ab1c9f4f5e1a0249c37c97ca577011ff640d8d7dc873c7f65627b2987cb341c6e36c8a215022759890c6030741bfb7236208875c5d59b829ed073fbfecafddccaaf205efa13d71bc49eb90c4b31cae27cf57f3330f5257f30859e04dc324e3859ba65665d345ac150aa6026e56b25e2f3c30dc883336b88a01d315809f8649d72422d7a1c305b1931abbedd355804052fb8f4b7a94c21f3fda0efc75edebd0d103560a5a67a4460b7b5fcb00326706f440f6acd48cc29af3c46154d8b419fb5763e4922a6afa0316769a1f4542ef2c1df2737c2db54fc3e6532b336e92e8d020a260605683cdc828f6ac937661e90412117aead508f406aee4afe33c5306dc5788a008166708525e656151a0e0cdd420e4778d4c0ac86fae4418c457041aa504c22db2dcf1e927f88b437179bae325c62c056105b57e9ae2fc75ccf34144c9c3746455a87226370796fac0b6483d246ffc9fc4e72ff103e13592ddd59354a8585da6cfe2a3b3e2f2252dc080506751ae0ba12d097b4443e3de5e6476f638f4a556c2892f4cd23f1dc5ce590f8256b43d744abbf60ca774b8b2c55b702212654dc347b919d59f35b0590822c54f28711b29e25e190df98b9706148c640cc2353990b7b89c62d753fede88053a1cfd4319fcc225956a0b1b0153b28a0b5f0755e744a1c30c13800e14d102314c95f1ee27be8669c216607e078c632d69045d372be1558307f9c47e6ec090aa29a11bc42ea01498245323847ea25bda7ad1670b057f19a760645237fc13a3d57398f097bcb3213c466d8c1a6d0eaf98fa3531934ea48b5ddccc6bfcd53103f7eaf3bab2e254500dec6387f400737aad43f21ee8a8c9c672cb9d6b978be8661c479471822985135d8be6e310a4710cc853abb6b1fef2d08e799ea8def255fda21636a24e217f7def4993f27b1bac31d6580f2e04e15002d24bffda5c816f19fdcf1f42c712fc130b57b2230b0f67a0122b4b873b6b72fb00017a9640365bd3abc207ff8f1b7c2b21c8943ab3ee04acc671a455a1244aef0c82cc9d2c6d2e338922b5529eeca4017a51e771c83f34c59566dbe23ed76084dee8a4c8a51c1cc3074d43ffb156580dc280caa7be436663d81a82733296194f065c0b41ec31b9fa59f8ead247bdbb6b42028771460f29606abaf795667d0a548598540ea859241f9b743067564984543c032c7260a7f981a4babf448fc3accc60b333028e38ad689b5696e79af4652bf3d59495040db77160e091a20a692ae7cc3201fc30d2f1c812da528af7cfc2ba5794a187bf172fad2594bc56f7d5d29611128201c2f51d4c53a59587ca1810c7e215147db72c2ad9348c546d66f1cc785c7ea3413558eee221fe6886dee3c57a77780a24a68d9c1c18377ce271e112fb3b29d5246822c26354de6dcee2ad3e99aaa964ef7406d98092e6448657df22133323ca89ee017a24d59b1dea75c777be174b01a077568286448a404c16e5c9a6535603133d586385689a2ce20f8491147d1f2d4dcdc31688e4fdf9d1882d563a5f4f9d0211be03838387dfc3c23e4c7f81790d921558c2629da4589f4c5c3295e6474b982b9835fc0a14ea3de2458ae55bdc1871b136718dec69cf198040d8de9b01e8907e7941be4c9c69c7b60d90a79a863fe95069034af351cbf1e27d600457e7f3206b85d9f3d748f4e054b004c420327c077e8e0c9ee0fbbd2027f9cd2114a35ca1ed000dd73eeffba51c11b519604378f2fdbff053f1a98c0fca178ec7393d738f3dc2f11abc307c01d28a77b23cceb1280b3be3128ead2c05b8fd8d6aa500575f05f9dc9f6ba72f7a2652596d5319babfb33ed0355a73c1adfb0c9f5c6253c6a938b984879bb97ff7015e074d2f962195688383bb9574f337eca086c1694aeefabf3a3abd5d1a56f91b5a805c32815f3fcc7869c36f9a28b731257fca1cf7a0f5f84afa1bcdabb19c086cf3fc84aa00159d836b9faecd9521a44db23a384ff071a761d7bd93cc3e88a52cbddf51c5c93f9aa61a86e8d26941e58d59a9895e7955bb0635e8f72ba5a643b9c8014468bdda49d6cef5b45296b370d6d031f1163aafc75600e076a30c85b7dc71f976eee51bdd8ecc0d282dc65aba5a113ea39f8365f6d29b79b7c1df1e5309b29d6a70195d191d50c96af6657ff83f5a43091115c53a10dc51d5873f5415e1971f746733b39f851633ea99317fb033d2870da9a652a9cb9d120a3a6414052da9df91ae33629a2eb9ab04f6a5aff052c86ac50c7eb7bffd197685c45d82716789c3e66500d63ce84adfa91dddb40bc4cab8ff8b09cf0de4076ad84c55f2c6bb53d2f14f1fb7f8040cbd67903dca95ff64f4896abc7e1fca65d92e9643cdfdfb6a9a360a725b086946aac302cb6876312f851c631ce82b143b73f4bdd485ef49dd895aa7bead08fac9ead4f9aacae8784f9891911a8975c8f5a6f0c49882fa1d643b68efee7aaa718078616bb551359740f303e37dbe8dca6188e43654b819d837ade994e493d6b7e327df774186986597235546410d6ddf06c6ed6f20338037149afcf3314e7b911ecb98f8dc64dc661a20e2426495ce2d4b62f37cb65efd53b042d847e68dd953deebce89db8710c85470ea17e77146484ba7ff9d97619c5ac1fff8dd036788fe5776de9996a1be610acb992ff7d3d6aa990d722432cd337bf1d71c070cb3963b21c48ed8d0d520125bb55ea97bc0521b3cf259fe6098a87a747e6807f4ac927076fcbff9d3245c49c4ad444c165be32031e93efdbef89cc51ac0c563100c806c1780da6b3525a75925c822faa80b3e87f226dc081534b255e5bb43adf72319959b0c78d4a4b290bc540dcbeed6577714293ecbc165b5cf92bfd94f9e561d936176a35b78996b130df4b75bb3907638b6680a612050e2cd88b4c9f8626cea86e9f9318d7f60633d6990b4980b9902daa2622726f9272cb648fb01adca9971271cba340db79e2b49d1339c3dd73d2b874be9506dd28e71bdc54dcc8e2bd42ba083696aaf7e0db841f3a9fc855eb1097da05390fd08a28302e70809acf71d8b62413ad4f18331b9d8635985dfc2a1d6e1d1c6c7062a1ee5d84666968ac031450fde04183f69d0b6156db257ebf5229d4acaa1fc7078317a7fa979801ad837373a393bc17fb1000bede753fe8c2978fe1da825722c44fbd0bc1db1e3b0e0765f502ef4162d3f84a20b4effbcb7d67d671c3a9e003ddc1e0c1b4f6049881c469ae29d95bfba2c5f953048e66241a8b3725fe7da6a40fdbe931951fafbf7ed48e741a841ff7ed87890657b1d7ea2818bb29196ab87b969acbf079cf27cf2b1ab10d92b50fe70b0dba9af42ce1316f96341c8142df06faed3b0fd9b3704a2213e8ae143bd4b4b1eb9ff243916a598df2fcceff7e1f43da8360112b7aa2a43929af22d086bccac702433a1b1c5ca1e3fec7925735dfa4606e8dbf480e900c8f51b3796737ecb6133fbcff4c929698244027d10da6c4a0c9fd06df47f89b77b421c206a7cc8574e708616123af588817f0fe707c25bb1e58265702a9332f78624de47f599559cab76b90e0868430d2b27608851703de4d84d94de7527a1c1ffe9b9301716b8e614eccce70ccd10487ee0d532f4a4b260b5bed3b5a3b41e9165b3aa563cf323cc4e9be2a1a6eb9e142f53a961ee8775dd98ba08956f05f3f5162a3d3afba3df0fdcd6f07ba6e3df16f0c64869740284b664ff825539da1f323c4ecd3fd08c00fe2452d40862d7682d69d0e2fa66f68c80628495734e73819d545e1cf8a79719d12d01c4083fa3dd5cf53ecf00db57ccd6528743baefe683e95fe663688eff55c59798a9973bcdd21fe58d338467f294ada04fb16ba343c5b9f7b8713360a94b0b6977b4d5b5ae6fb358c5d4968b8562c0d7b985a9e1690267141f2899b653396af54e5a7fde0bd72770bd1a8f1494df061897618e7e79d6f555f9e27abafa91e4f827ccdfffb67f1e26407b74947387ae80d33fd8b85d5c169ecb2ef958b4c3a67f04036e9c966c14a3a0d66f12b8bfffd0051272ceccf0847bf021fea8136276ed60e7e56e310847aecee3528769c9337ee6c93c51a44913a8530c301b43febf603bc4919e9c87534547789fd06cf3acf3959ffe55051be57787658465f511666baf4741dc14f801887514cd69998326ec8be13aedd999eb3015c379089e2e073f75431c8ef25157d9142f9a7a8ec7202b108e2b592ffe9bf596c39a184379854ca1b6fcaf6b9caff07870693f5c1f45fcc2c59a1e9a3caa8ad7d713743e6803a7e29ad249426e8dff68bfb789eb7a6ec55454b437b494fcd8fde6256ebd6684add3924ac269089c416735f9fd7f9d155e3b986d06e0f2c0521382ca439d6104c7e4ef5b27ed47df20734d3dac7d7b5277450b6dadf36bf52cbfec3d7cdec48becf2528592e0ce89add65bf8f883be35ec37bc624ec8def9c84ae8b3b4ba0779699a7222abe5d13fafc14a88134964b22632d9dad5d5c8b6a4909080fd405b326fa8c010c9eb384d2eabbff210c2f457359c7b6af5b5f8c328af0fe8d6923af0f5d2b2349227fa5eb8c90f12edd89c687eebb2de34fcd06d81411b70c9d520d879fc5bdaeaae3f74de3bf8e724ade9dc2e90964535b204bd057e49cc66a12013b73ce4edec7c0404d9babb163eeb28cc936f2fa7c7689c9ee181e71c364c28b53ea51505870f163ac96b1c45bbb7832481de283966dd940cf5707a80b5b263eaa877c40064c3bfd20075736682b143718ef830be082931c2d3b85728fdc0d188802a2c299a9343bb0251bc99735e4f22cc189f1aac3a8875e716f6129ad835e3051127d97fcadaf7aad6cb7c8f21d7b84be9ce8937b14c6717f3743eb014a296c0698c7d85c4fcc7382412a5bae19d6edc091148d9a2947b32eaa770a6d8459ec0c832dd9f2ec14a809462139a6f065d24fad8cd3899215df10e11bcca973842558b90f21f6150d9164378d548b8d6414ed40509f3f648ec18e14e913b92b644c99a46a490922667c561db7f2ac2023ab72ff38e6e63ad3e520bb075608db5a26b38c1261ad293a3e1b6e1f2d8c0999c70b1ec55260bf2d7facf00dccb8057b6c362154057cbde6a36d5dbffc952fc0ecd773d6134b186f77d5d9615d457396801f88054ea42d7007b8ce678fdf47a299615a1a68b4193952bdac150e134f6c04ed74349e3f80b461ff0ca88f7b057a45af22f34913f0af15e5b2b4a2b882c24c3d5029453847726335ff65871e5e4b2d9673b820f9ea4e64ad6c7279367843e114e1d8c446e4c87564eff682a92ffa20bf0c79d7be660fe5d688db4cd1ba3dd8231c3b6ca7b5c8534096c00813948bd39370d349c419cf8fb5229944df43159e9252b7e483f9a09c10adae9f9497322512b6968bbe378bfc173787ad2d059065b39ed8d92f4c1e4eb8a0a1638fe42f6638dff6d1aa259e5b3178461af0563a07a3f62a3da30ceb4682dc44a1c59efa5bfc1e0cd1f31b82302b21bc757664a83de7aa015ec22ef1f98990903159a826cca9f1c70b6d0d08ca077337ac5f322c0c4bd606298ed6eaac80840a86c1bb17a186a7d0e36c5103543c79be06d30e5cfa57156ef4a2b4ebc9863b88ff798447c229a0c42805d15baf4423e0d76b2e758defff0eff447674f2e3eab636b4c2afd9ed8a6aaed3c0df8888c4f88685cb40ac73e13c9325cb0fc74c167b0c7913c86dc55b2e36f4be0ddb68455bf65899f05b56df8d76e7662578706c6c2de705b7e2a27d15d332889f9f0a0e2a6df9ec444d5437e50a7d700031e88d25b39313d5934f1f6b211aec9b1b7b5743cbfc64157ae9707ed0e801af7751b90a1e3ffcdb98339b615f205f9bafcc5df1f54b77934d5bda40384d548df53569f6448cd7dd6a1dd5327e0f93e968ae2bed3aacaa0f4832221ca75d3b52db76e589da5f3fe4f4fcffefd23a0530198cabdf4ffc1042621a22807cf1da7e6dc75e8b191ec4869226fbec2062e3ab180e7232c7d445acf7facaeea42c6e91af25ee5c3d27367f2cbfa8f4db957f30c10644b4bd468ba66baa32aea8800c92523c4a4c200a40f6c8a4520e428692335b9df713a640c018d702b55bd1d683e25c4cc824261631a205e10f3b09a02d9f18ac0a681bb462d15b5724850efb1eb8a458b35553487dc99e4e0e0537d43fea01fef0fcb8ba5e0ff96f756f4f329e556122683bd878f977d1b1f4fa7783ab70c802df577f9f52e8a2b07be28c69aa41e8581b962517beaa6823a93500b3296eb43441569cafe15c8096e85a10357769f6c583a0a92b05b716771f85e2abeadf696b2c4553c827cdb58e3e8c31ba4ff306da9261d1e4ae5a666b9d904739162db8ad12ccba4775511b8dc8044ab47f71b41ded7eef0e06a56fbae1dc5007d6ba3ceed4702ac639343dc4baf4aab18e1f02cf40e7b198dfbeed36afc6bcebf54a7f4d79b438cb3c586f91d553afd2bb52d65c49022853c122d84b6ce8ae218a975842f4bba98fbf4f95ec82e4f0b4f483b7006f28e3364df1444672c6985099116729bbcd2d3d47c6e91b7c94541a9609db8c2b6e30d0fff368e333c62107c428a541a00e610d52172a4c89c57ada6b3ffd95d881692e69e8674faa0fe83049f498ee0d26f282a8d2785a27dc943bea25161fdbf442b006f0479943351a7b2b5425429b530b2b45cc00fb26573923d707abbad2fdf0290fe6833548ffea3d4c7ec8ab59fe4a181ed727cb82eab0622035f9d0b6a1de569f1f2667427bee28eddb1de940d384f1436b6053d6b6a865e6b89e3acf27673f122b95422f7a5e5f194054ebcc1283ceb95eb54b4f88ba390233d9fd288ff18435eaa7b82202e9b364c7d358113e1390f2a89d59720dbdf2ef5953967ce1eb894de173939656c2bfa5cb530da4e6df2bfa6d7f0ab1f8b9da2b3ce88dd7c38c9fd0502135c35d7ddd004f31241282c2f059a3baa8155965148287100d5737cb71bf512219bd22428999b7d0cfb0b4c662f25a208c2c112eb31f6b120c83fdbf87ab242307a1f8cdef566e4f0225a2338da6c60cfc35935680962710ef3eb4c82ec14f7d157b680ca929e142d46f531fc517ca0cc22cbc7352f22b460c55e06df9932a8d0857a206328a3a00503cb3c83ff0d51b8aa1ab07e841b7fe6809965e5ceef60275ea452356b5f69d09cf4d19852ced8fb3e6694117fe181ff504cc312b6e571e1cffcb6c438dcfd95a4cde76462cb5cc89b57b93272ad375e4eea0cbdd2eadda9e7fc66bd303d78ceec6e34d4b4f06df2b3b33baa1028b596d6592d96b9657862cff9f2a8fe0eecb9fdb34a565bd0f0f8b13ccdd613f4991eb7ac1d5984acb5fb65cf4ddedebc491fa76facc40e7e1cc5724b6c1bc463414a94a6e6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未选择的路</title>
      <link href="/2023/12/04/%E6%9C%AA%E9%80%89%E6%8B%A9%E7%9A%84%E8%B7%AF/"/>
      <url>/2023/12/04/%E6%9C%AA%E9%80%89%E6%8B%A9%E7%9A%84%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><em>作者：罗伯特·弗罗斯特</em></p><p>黄色的树林里分出两条路，</p><p>可惜我不能同时去涉足，</p><p>我在那路口久久伫立，</p><p>我向着一条路极目望去，</p><p>直到它消失在丛林深处。</p><p>​</p><p>但我却选了另外一条路，</p><p>它荒草萋萋，十分幽寂，</p><p>显得更诱人、更美丽；</p><p>虽然在这两条小路上，</p><p>都很少留下旅人的足迹；</p><p>​</p><p>虽然那天清晨落叶满地，</p><p>两条路都未经脚印污染。</p><p>呵，留下一条路等改日再见！</p><p>但我知道路径延绵无尽头，</p><p>恐怕我难以再回返。</p><p>​</p><p>也许多少年后在某个地方，</p><p>我将轻声叹息把往事回顾：</p><p>一片树林里分出两条路，</p><p>而我选了人迹更少的一条，</p><p>从此决定了我一生的道路。</p><hr /><h5 id="the-road-not-taken">The Road Not Taken</h5><p>Two roads diverged in a yellow wood,</p><p>And sorry I could not travel both</p><p>And be one traveler, long I stood</p><p>And looked down one as far as I could</p><p>To where it bent in the undergrowth;</p><p>​</p><p>Then took the other, as just as fair,</p><p>And having perhaps the better claim,</p><p>Because it was grassy and wanted wear;</p><p>Though as for that the passing there</p><p>Had worn them really about the same,</p><p>​</p><p>And both that morning equally lay</p><p>In leaves no step had trodden black.</p><p>Oh, I kept the first for another day!</p><p>Yet knowing how way leads on to way,</p><p>I doubted if I should ever come back.</p><p>​</p><p>I shall be telling this with a sigh</p><p>Somewhere ages and ages hence:</p><p>Two roads diverged in a wood,and I—</p><p>I took the one less traveled by,</p><p>And that has made all the difference.</p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数笔记（下）</title>
      <link href="/2023/11/27/%E7%BA%BF%E4%BB%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/11/27/%E7%BA%BF%E4%BB%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="04ca3292fe261232128a621a791d0a7b0e7e75e24f6a8653f7feef8499303980">4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b428db2cafa69bbc9e59058bff678bedffa8e087bee66a27b2aea4dfb1baf6f64f8b42acb2da625020efbaf03f27d875afe5a6ad68bb6f2be86f916627ca35a49ae959b80379c44733b906558d06c79b3a4eba69eebf89c676e0ff0ce0330fb5420e20014dbba2088e0bc81a31bcc1770de496a4d594fc1d182dcb11f64983a1f879ffe4bcf3bb73b5f43f4d9205116e10de620921ae735518ba56844a84e92fe6c5cb80a60e7c0f4d58baec6517429b6f7007f6506aa2d5b3234c821ef3cbc1697816d820f88d83a412665a35dc076491ce510506f143961b4912b7d0d5c4f2b5caef7e7a84d7eda72d52b4271123b8e11a2984918a5281b2341813ffe861a0477e7af0c47a21d4cf3c90f74fa27aba2594cc458c2c77388d1e776fd3c4a7fcfda9216e2757c3502a5238a7e7c724de4e3d2a9ea7108ddd71ebf212261d5874a282fcf96d46fb55fbec7eee89225f46788d4bb928af13a269b681f07809d600b3eb401b6d0c8abba5670d1a65fb1f695cac4298b963dee9bd89566d1140e68cbd0142aba8a2f9c141caf2e7826f5af7f2727a4d514c10ca35a2347c1b2f9b977ce56c29645aa55a9779cc64476756e4a62b8086576e2a3970526becdac165d127f6806181e24953ab9c5552fa6c634399eb950b12e40a0089f695a62676b043263d341753f1cb81cbffdd435e336b7bc94c15fdeca54d61e2bb6f09ce71966e74444f490ecda21743714671699881f995d4e3dc309ed65d6be192dbb05dfb7d2b7f4bf0bda39123fbf314260405814543df266991991130463f8719ac13e9c3450bedfad3eb0ff835ca3181259243cfd796943f031f2d85363fe609b938329d518c284e3f8e41a85c8a8648c54bf268d27a9e50dcc6be951b9721d26ad31005fc3ffba3f37f236aa3e955d2392d378c1b6ac1fa5d4ae568985ea112f3e6396ac7cb7296dde49e7feba6d08cb6750da808fdd98ee30589d03e710b851dfcd086a54984c2db1582bd2d6aa111ad4bc1b3706b39c3d44e5cd4fb1a2ba1c900f6ee252f7aaee156a1019605b968c04cb1467452a250e96ea51a7d7957d070e853f16caa0ffae73e38bdc6ca1207070e656abb59941ad50a10624396d8ddcc26291aa92164f279b3e0a908a42aa2a29771490ed72a19b5f01ffeadee1d7bb68febd7f46675cd486af0da142d6d612c6314b62e19f55846bdb6e9e36acd25b9b03969d4a4713176549f877bdbb90e39b82f454d017a0f55e64bd0d8e36dad70767fd380f473ef7b7ed344777799a7c24aa1acf4332fcfb867e4e13a7dacfaec1f1e70218a9901ac4f5e1e1e8415c7436ceab104712e303548f674ad837a9b65ee76c04b81e82238229b6cef1c71739d0571c54f68eb479331f635a82cb4402bac9d4a7936a80795a18ad799a82e6b8d3c0571e725ee13782765aa3fbd960317311ad988e3d0da5a116bb5e3f0942b9cfddae50d9cc0eebea8b2b0f553b94bad0923262250b498850f29b94a7040ed672467cdcab5307cafb351f1d74f80e69dfd0b31d472d61ee090dc6671ae238760f941f3cdbd6fc6220bfee530bf24f0c6afeb72af0e4016f0819bdff8a49acaa3ca73d68fe1a43f3675e38f5af6357ce098a887cce90837c853aeadef392affe3e87b1cab613e1cefb6530c1c567f1fbe50437d9d53fa9326c9d1720f4716918b622eb780a965021dce37601744992ee01411cc42ffe297c5286fe7a96b3c71c21d543ec684a1462cccc4e41316278f3499d997882549e4e6654d5997044272cf08b6ade7ecef5611ea9bbcc5fda46adc3ea5fe11ab631badcf61c818791cfb2aa8e649afb7525bc3155abad4026bbc46df9f4938c184b5efaf71142d23ee0aa097c2226792a460192ed30d100f038d3e12359ebc00c91bbf823e2b6c4b3292d1045c99f996b17767b89e06dd0278cde0f21da753b9922c484dd701c4cc36ca2f6986d39b7802f242023798d082c2b83b276269bfc37394b5c9997965cd696b5aa72fc527614cd7e4184f134ad01bcd2acc642d441f39fc0d5d905eb2394e006954c70aded3e7a40e4dfd7ecb918a846c95e7fd71e5c66e43b999864b73a993e56fcd54f83188c1d198576ca11f8f2c40d314d13254371a21b1e726c6b81c0512c1dd8141c75bc795dfacef7e8e665e8c03328a578598cc0bd214effbd7acd9c43cb194b27dae9bd9064120bc627bf0a30a172f6f6be40a99d749ab1418e29a28f4f5ae1e4cb7594a8ed785e64c13e3b92c6ada6a9349c393b8dfbfdafe21f4d0685ba8ceb366a07505ac14f4d9c35e5d64b56ce2c5230379050f5d89e93d73a216c984c4eb30132cc2cc0f2c80e47d247c11fa9681f469c607b0705297df57d3a7063958cf7a04c82c96f3153bd9419faed735c1ff54708cd783fb187c86721f43fbd313e76d2b371969d3bb4fd62b4691d0ea1bfdd412a421f0e1ea2813bc035d25cb4fa16da97e953c4a91257b3bb64d49c6a55d44b322b4e94f51ff4340d97602caba838a1677324a6208abc6457ba034b8dd8ff2596b89124fc5d154fb0e7583cf301ff5b2ccbd39381d60265e5015b8ac6c659c532e5cb15ff1eb114c5415dcbe7bca6f759f667c88fbf7f59031e8f7405f7bfa1a6fc74c401f22987b2a76dbcc6b55599ac2e19ba6d10fcd840301c9aaf13dbc2c4db2bd77e2172578dc9babeadd15748de2ad0597694e9cd3ac535af617ff846ab11e31d07f6b582794191505854226f23a9a8d56a780404270fc6c5325e9ef78fe7f8cb8c41f501ecc990b53d79b21733126274f0f3650bd29c30661d834dc40b46539bac32112aaa8877a1143acb2e1c7ead21916adf789926b5c430b5a1cb9a78e2b2e4753e86c5494a5abd92ea89169a46627367329972607449da488c0c9eb249df7518a78843916183617e81fd12e8c5540a6d7335c792c6b77dd4ce1418b55c834dd40f3dda042a1f1c4ec54c59ef0fef6d7c0bfafd2c9970a13e79a79b20c62d5e5d63740a6c7af59c84061ccf01d773a5fb5b0aa94784ea61fca7e07bbc04b7d41b94b1684473e7cf1ae91723f74c03a84991fef1fd16242f661da2b0820bb12ccd52e1770e63315c855069901cd8a5a727100d757b92826d22b10319e4d1af30095bf578dd857086225a612e8dc9375d104fde5763593e6347e2d4cbb23fca516e8fedb9b2b35148320cce3f1c08d2d44ab538d5d2e15fbd9ba9621fac9d23ea1184960c43c6f783b134d6c2aa7fbea523e67969f216fcc46a74d9d04384654186f52b56dd6f1d03a7a7bd4a22b7c86399f96d0f9767ff031e6a4d15de7ce35afea54d0fa47976b4f6be2520bc7254fff2a1faf4ae9b9b214d498be7d8624e5130dfdfb3f2b323c4ec5a18333b7ae507367fa75916a725d5374dfbbb697f59e06ebd59a528c5385b5699c277fc78635798105a57be5fbee11c165fc6a386d8ce0532a548da1413aeaa384c8adff197651a5b15adcce40a1ef826eda7659e3d7b1d4a5c3450580e191531e411b1c903a4420f9bab1b32c43a2f39c4c5e459bbdc7cdf126dcfb7667d260718ba88718caadceab4aa21c56031654f190c046ddf4e88de17b8974a3957454b3b2cec4301ed6b939a738218c82b760f0cd05b2993075f3b4ae4b76084941cc9ef01b66fab1dd51e51275a2c3a9ea51a97bae2e60cf443533d49e183b76a6a3642a48b978fcba5447c8a2f4d3a7e61e4f35a42f841c6b9caed63a6bfa56edefb05d4fa405da78344d4136f8dbd1dc5e750598e38ac5dbf3daaa2bb37b04bafdb61c3c1fd54809affdd2aba2ed2014f1598e5c056b59c097ecff3cd17abab0fce84b3f5a95117842edf8b6dac2e8d4ffbea6b4bae9a91d1e94192def05a5f6103e10cae9ec13309b10fae243ab0b8b90df1f4f3bb83d94ebac819984304f5e55ef35d1e1dcd500d50a56c1caa63d88ea75fc4a414993a8a088017e592b22d56104f9f0f288224fac20cccdf4329976346da0e03c2b3c8fa1d8b5d75a59cab0aff104529de3a3f6b1d4cf756cbab25cc96a2cc3f2688a59901da223d83f91a773bdf1926804538772b31aba68a16a94d0ba4d71233ce9c33f456217153914b53b1806c131e022cd62298d6f4729b5bf039fab4a6cd9e2535e995a0892afe47e5a1bda5809e3c0551b629c589299cc341787cab86f8e225215a4875c9a7daf83a18a36a77585d2d018b3195ddd38e397fb5082b257f6181f7e0714ead660474481caf3ee383c00355cfff90c2820e06bd85b07ff4b740b372e7e17fca9bb023c12b89d520bdd2c8e84a6c7e8a516736b4b1ebc102d496e9477fdc1fc8ff4084955849bdb201fcfc99a6da711f3578f723a594db7b551e0bef110fd6bebdc7875cdf51d1756eb1d724175e2a51d0302e4399c88234bd79d26925d5669543df99a3e36affb50d621f797043d0f4bb7e6e314b905d45385ad7f4cbb23ecdad5ec69b19bbf3ec27c857654e625eb4c112bf53169bad5498d619cc73fc75e13c8148bbd93adbf2a7e6698301d7043216ebe885b75393f175d28861614307ff95672438d575a48cd04312d91af34f66e8e82ec05aa9b451c78f85d21f101d7ed1c111b93c0c52322687349e884cfd24dc786980468ad197c9aa965efb4207c4765a1ace35aa0fb60585d4fc44472f2099c91eb2475eac4a55475c97e937818d5ac54e52a4a9754ebc5d6d8148de43df11bfcbcf379ebe9fdd44ae69c4e23bb68c707b8c9f0f674ad5efabe4d3241cda6ad301101e8e9a689cd0b40b51ceee60934508d766e42c48629de21b269a4f554faf4817ea7fd5384f960092b76d64fe7bf0121dc2d537fecc048384eac7a79dbac50d392a73cb5f56d0693526eb38b09ec86ed9fe6c795970db33f818f89a688a107b135e7cdd77ceb0a3f21939c44f7d391dbd02fc1ee1f9d0eaf9e8bdc979c7160024fc557faffc1a8a16d81723563a33c63244265cf2de47fcc4c3211b3a022044dd30bf4136dc417334e75e696facb0ca185f25dfcd55bf8d8997219766d7a7f548c6e612919938ee14b1642b0c591aa74ac2c1f3f64042af3ef211e2e447f90b9d7cbcca9e64018fbef0ae5954f2bc0d4e9fcf999ad1ff11f438a8a293ea36f891a0e7c971f2555771761c66a20cb7b63d1d8c23e9ae8462ce544d0c402ef1d4de99ebbf29b46afd58d0aaa0ba6b29372ee8a94809061501b0a4bc8a04073fc4b16f180c680394676b9b2c836cdf09b80387b5d209eef548be451f7d0e4c951508b9876c06009301155c6bab28272dfb351db42bff76d8016aacbce81dc0cd51b7e5704521ecb47d3d7cb4a1704fe5cc24184b600bf820282b2371b017c6e2b6295834b59526f731e0d9836bc4a5140756f6471e5b0b8f98f6346ddbd936caf92b67a22d2a23cc926a00d7e9036e7198800ea650afa8ff28a5149084ce4923ab6659d6b2fa18c1fbace1a3e3705e53cb303ebdb7b6ce0c8f5abd33b05fdde0f10ef1118e88da73ced453ae738f0e58c66401f2646ac580da09775c8e57b9843be1994f2c562ac8647ec9c03a1474c1fe615032f86b0e3eb45c3737c32f0c6d67c99acafb03803be4f7f3940003e8efdf8e375b350633985b415956a996e61da77139a5f69c55f2fed2f9cd1caf63781b7bd444b61ea9cab2a8ad075c19b874f9682f4241a897bd66e5f37e316b1d6b33c146f2d2438488ea530bfc8b5f0baeea5e6c16a017ce904d814f8c6c77f3bfb5d6b0c9f815afe32dc37c0b5e9d7b47e68a2f277e747db26f6f1399f0b7197a9e07ae6149c6b74b01b5ce35539d5d7d200063e570d2474b91d165d9b1faac1ded6b436d7664a4222ace727960ad11c6f3a7312fa017690b7a855cdf6ada2695321f48e4e1253ef7dd14e76575f57a651c49d1b1834ae2a74fa02d45709c130bca1bf88cfdc27f286975d9ce09824e0d2c22d29416eab9c08c014646fdf5c4dcc5d533336f7c35d94bb18e7c246d80ecbd2b53e232cc0adf9675ebd79353fbda197d4ba9207df57f88f5e525989ecb9393b19fc7c8e0abf68ce7cf368c7403b705a6700e04074e0f927c2646cb43867a63db7006afec993c15086557467dbbc37756ed887cfe7d991c768b9ebdb8dd461bae93cd2f31fafe199ed661cadfcab10516dea24998dd3acb5cdaa5a1e746e5a968ba66191578cd39d413fdb705e41fef000a516d2c3d1046b6bbe451952506479324a9687f4abca3fa3700aca63487ba8e91f53600562f68c86015c756c0ba1a88ae4d7d9e3bba6c0421349c4064abdba975b7413b4436411fb7e6c52fcd5820e6b81613e5247dc725ff7777571136ee792781fc28301903c53e685ff84364be1e2dd9e875cf762a0359d1d8c2f16fad160d4ee7bdf0457894a5554efe3b7f3ef0ba4bad8aec396cc0b0bcc330f191c3217c2e8c57a7dd386ddbf03719cc62eb3da9bfa995f327450c24e21cea27642c1cf48ac1b9ac6888ccec16c0943b997d854eaf3178108218b269057fd169beaf0f032faf27722d1dcb0cf81e69a132e754680863f2804a9adc901b020aa89f7f24bfb2a32d2252860b28109473f48aaadcab7bc7ff78cc63aa26cad3730bfd432600717e380d264316bef92c33294ec9e563b5881e8f11cf03f8918dff363d34777a35cd286585aa6ed2f032813f6f91fb49077febdb4d7bef8cba1996ae5d9a43d7f637ba79aa373f28d2291680e02ed82cec771a6ee5610f7d05c4c995b6dfb407686d415142683f2cc34e90df47bc9c12262d6a8bf3f83b52fd954cd9b1e588b6339f55b4cc3184c4e363526d3c388beaf04ab1e4bd63bd6ea8dc49a9541eaa7cb2f9b16d17eebe37e7822a303a0dc0955e961f5d5cd46a741070c3eb06f6d10c8cc3d069d91870e70b86671e1b6809fdfa78ada135b24f3fff846a419477ed24186a9df3f5d1665ac6a4a9701c4a4e830a98e03864ec5cf190ca0debda22352c8da14a9fa4cf314e2c975491cf018c70ad94f9038b10b5d4a6c290248c02b468a8237f1b3eb0e7a72e806d02f26292af25fc1e07cb4e8690d13d72caf57e8c9c5a72c60413ed987d672948be3b44d4516c6a2484e8d920da712332f3163eee6452f32ba54bc8e294e4c03dc3530d0b100b1fda1ce207932edafd8b5baf30cf43c8458651b936bf9054d04d65693a6ef7afc30be203d2725cd805887c2c05c1dfc9c4ea465187b653112aca020266f8faa8bbb9026752121cd439e23a1232427520f5df40fbf733d7a6a5868ed2aabc713f0c865c9e4fc393286b081799e7f5bd8a77546665dd53d5f07647ad77c53c01a031366585f59f3facc2d10cb1b30291589e0cb73d747ec9ebfadf0a97f23321c158e5fa565bde6ac2ac689e4382a055b8e58035b6c49ac9222c7273648b5b2a7e58a927d93e9bd047a77ff481b51882d48c0c92ecb2b256a1a9f97e1027f03fe4b1b1495c447d003645350bcb45f9f2c7b3bed05d89992d368c91f59e52a6033da6896e81dc095ed4f1211cf270eb3e2125244cd8857e36b7f9603d7bcebdf15b417295f04740b9c01843dc51f7e718cc5849e4c16aa27b0e12c299f3f15d2be94fd31f3c5f0b5241825e53da5a48b65bc0f03b1247eac482cc4f731ed67becb9337f9f6716f4acb8a7157714a2a65900c75bc58cafa9f27cb87ad66630c710507844a5f727396f0f696f46375ea32b0ed340a1765e7b3d039994c8f8c6e66221db6153090e1f27a706697c1ce3e78c4811cc3a515ed133bd14b85326dba5d426aa7859a3753f21a6990d870966d7015833f98b98051aeb489d660c6bc6bf7e758535a6a48dbc60a47e887be709ac9095da5524be328da114203b4e4e3c8e9c9761e99a2d4461ca5114eb4fd33b0387dc848403fbf2c8b7bd94464e279f1b15d203acc25704986796468742ea348c5565000d04deb93bec0612cf54a86e90386184ac98c6f14362b3d9c883223034a37ea4b75988da84dfc501d6c717ba2749c5ccf7ff8dcc7e18fb5b0f7598596f69c924213967403a8a3f362825eef18e591782a0a1a518f1bf2931b1ba8c5ab5dcb90b83fefd18700ec702df790368673e1378f4b64a747f36df4bb8c7e11253e8a1eca59f86f5d731cb8cba007f40bd4390369bfbc3280f5cd2866652276f92e5edd25dca8301ed0b5002e1aeb034e36c55ca9bc0d5fc1d9686908b757cb69ba8869c29e848d3288e35001061f9546e45edf37d72c823ef957537703dd4c03b76bfd90f1ca04d79312b83c834f0d2889675a442d6fc2795165299a6a67b4e6c9c09859c5b44b09dde3ad485faa6ba7a3eb766f3761be8b9aa7d9e2465259aeb5285b766cd64c2566ffe59c89f19010d3676d66957ed659935dd34c8239baaf7984b36c0c03ed078fc1e5e7b9bd6b58e5b198e4b1d2e6e78e1b7ce949e634242916de7db61e7e2905964547c52d2565f1160bd947a2c6928d7941c9b869c48c29efd7b67a84340ab029f66790ebd86956445c001cdc6d32dcfa2c2cf0d56233f87b034cb1e415c7fb199d848aea2379b9babdaca65ec50618dbae9662e91cc92cfd79401d311dea3702195d00b045eacdb11e267e5eb919c73bd28b0420391c608bdcc91516b5f1535f61d1c2ff76e3f1dbc1a602d4906414a386d13480039ad586987b87ed14d01c69bc9d54cb46171cf7ebaea599674f4ae4860b680517b3774c7848a46fecb85a14d707ca6ce4321d6bbd7f096a3aa98e7686f38ed5a9ec15225a6f8de6a275f05d83f62aeb914455349f92e6b96eb637d6c4d7e8643c4de2b269acc9cf8eeff6ef105c1429b7a05de61108d148e155b6c1091b528decbb3a281deedfe6b25f2e74e90350553181bb33f305da9415c1efa0f35aeaec1baae532606387512c460a0da78d897a039d5bae02d55cf694e10a4dfcb48006ff00c4d5fcfa5d51af7dc5a60114228cd0096a195a03c62970893a80a3b289caef5e4c27bc9bcee1255630cda2d9f45fd543782cd569160ff6d371dbe849765b2b820ff971a168a5501f1004a011f60690eb732ac88672a0104bde6c6e9288baa8f3ad793f1e9155c96448f64895da6aeec8e1020b6385213b64720af0392646bc9185e404a32fb46e5f5e14b8dd5c0579dde180d6c4dae0c8be3c9167cdcbfc8ea0c45dc40b06356ccc90203dd5f70e8c1c7ac744f284b86c6f48b8a1b70c6bd8c1fb461788caaf9c86f1762c8c037bde801075ac70d623b171022b8e60e64df8e435e451c71840e24ff576285e29e4deb09dbf138c843babfd93092805d76373f9aa5de21fc2c5a48aed325666802c948fcebc745107419f9b3771d746e0f63e5c515ea2bf90d519d71f3d52161908811d6b1df4f01990fae6d0aa1619d3566b76300d565bda666ca53b842a393dc4b442bfccf4059ee42b1370ed0b7259cc6d5357a70ba7cc73cf60208c47ed08522c1ae15f2850de5189767ba5dc498168cfbb27cdc375b95b4e7db1c2942fc361d9cc0ed7f09c738b2e3c1498806e207e1e29636b2d5c76d7051abd795e4d3b422af91abfdbb7978c4603bdaf46b74948a9c4d78b9d5ee56ae5a77d9e502818e587701a6fcb711d958c0107986cf2fbc83b3eb048cbafa4e26a3fa495b64771818e5f824aa5a0b769d11abea5d48bd373f3430f56f5442e0e79d3f8ff679b61063c823e1599c224ffddda307c9992fc22e3325ebf20d38f3c14bb8771061c4f69a832bd7ec103a67a638dfa245d6bc1e5cc2879526919f1a5ef377fe87e2bde5f2df05f4a490a213208e54edbcd98ac52ea411dea87f69745aee39e76e581e26359936c998e2a17a801ca5956c412a82f2c54d2b6ee07df36ae564f50c632f139e6933c7cf9f8e37067191bcce579889b4b4d9d126b56e832142e6f1528f92bff3d9b62124a337330f2b746afabedcc0388d0582958c13cc31125dddf81f25d13a9413ef2982a202eef1fe72524f336ae8ad2b9454822892212d3f1fd96e80fda73b14b5d4968045aaf22e278855da5c573fb97ba1786403ed64b773bc306cf9507349dba40ef591338d30114ea0376714f37b8228e8f13ef415cf471e237dd249ef7f9d2288c5e6d1dfca3b0f7422131bb5d93e7b148876cd0a05ff43043dfae6d410aff8a31265d9be3322167bc385773a237a9f9ca508bdd9fd719f952a78ec18322f16a35c1eee4bd30693428ee9643050fcfe2f6a789cbe6e02d17c3bd2717eef4d4f84db8dddcb25b4aed427e8eb8e3b3553cee36b6fa9b8cd2e378d3db28d9e59af00ecc7e8757945d6dae6ed92b83c0df39c526ebed272b678d8e681bb7644542d2b50a18c8a988fa4c941988886ec45a82394c57b59d99d09e09a07f6add9b59c3d297466c288dd3e031bb074e09862a555826151fd9c5c1ec398481fba5eebd89cfc6ba153f67e81c290cce80ea7ef927621322aab9088c866cb0a837ba1de09a17c46487a91fb4a765e39bcd4e3684881927c4e2d7a31fbef725ca6a4b09f99ce684fbf86ed99e8b82b8e15dbb411f6b191c0f0d72dde8bdc566df754bf704c1e1de8bdf9ac4b7097c925e95a9a96375ab5f924c1864483817ef1de379a5156c4f718186f8729bcf86e837e0cdacaf9faf5f998ed88e93fc77ffea12d808eaf62e219878fe0f562938d119e26963ced006fc56d584870eb43fd72a55feeac36b6c19d6318f614c230bb95e625a9ded52f25382849ab4c9169e7721520fda3bc2ce0eb2ded5c1643e370bcd1f2ff2566d9711d2bc894ddd301283504699ee015ed31b66ff7b08554f209e7336add740adc96f686c58a2bf5f334c1d04863fd88ed893fd7e9d77dbd0090094aafe3f04fc417b5af85d7f6dc82363afba4365cfcfdac099c55ee71adc99b974362e97ef820cfe2e1c6634232eadb54e06f57a10dc9154a5c9fce16ff707b02411b5fd413811637177b4279450bf6bf801e8816854cbae7e1e3180643e243c3254c16edf5a43359e4581e123e27980acddcae578ee65409e982dd6a3fedfc6f6118dbb3cd1b952940fa63a110a7e830c96c5976f2ab38d9d8afaa0dbf414bc80ec5acad5bbc3090b8d1a4ce816bf6790c8bde29f3f8edf94482e802c623e97e1bda18d0253617495e7ae1d55d8acf2cb3f3e6b214330268aed95b4f28faadf925bc679593fd18aa67c3f1e793c2030ae29ac26abd4007e75e53997bde4f7566a50731b5ff5d31639e15032ad82f55012f065abe7c4990b549377de163d90753e7c939dd29632018fd709636b3e00ca6cce348984e55d8b6ab00a46d74b8407969641eb0c1493564bd63fa2114b14777502fb75912597234550294dfc2ad0d43043709bc0bf5c9c1a98baeeb9d98c9f6085d661679c45dc1f9a802f2c8828f3675ad25455528a35a990a9e3e15f78bb5af71bebabb8a414ae4d4c6407028334d9d484785df5cd7466087762ca403f1425e9c6db05aab03184c435c5066b629c009bb3fa1a55071249122b556ea4d1eef1eb0d9ee6128628ae47eb54d96665c92d80b52c65133b3a96b95eeaa267ad9d65cebc649d8af8f8e5f8460263e4f31599f07187810c8ff93aa2b5866755390b278791375a48162b1766ef861cf3ada80fc54a9e30e2747b60ea11daf99ed2e87666ff1b9dc5b84c27a4efa41aa3f910b21f293551fa3042ae4f948ea92e9939d9a8ca9a139fb1e69085f5aceb6ea0be593b1ed488392ab17a5ace1d8d565afa276c48991bb16a11e21118fe23a57cc3929298b75e2e208b51726ee39f9add9b54cc9c595f8044fdc48b57af3a511c198e492a3537825ef539be2506a1a07ddd35124bf0aaf7d3947eaf55fe419dc0a6ed2ef43b438ead8924babb8536dbb33b39c09eb515f7594233d476bf28514acd792931756cd16e3c631ae78261aa22e0b5671f4c9430bdb9e25229fb30db52fcb2ee9cdde69389703513ce541b23097e23d2424d996a570e80b6f8c466ca3fe5276be31c65ad76df9355bdd9c10987d47190bf5c8d9a1da589f1cc32ff3757727db9638678f448cae090789bb144ed1dcb3ff015cd7c130455a0f6710021e26ed4e4962dc85e4d4c14bb6a41a80b098b4285d211696637716a6c957c1b7f48cb421d2bb9f7ddafb8cdfe7b3b77d86cb705f7ea4c5e2b448934ec934e537d1c69ac83eeb1745e0ff2928c2a0432f139356fea82c9172f65250b4c58ff945308d5b0cb02af452db54f347d98cdee3f25e811dcd975bd3f2e6602aaff17798949c3b87a3a80ffe07ac3fc306e4b541d4290ca2bc510546e2784ea8e30593471f9aa503d4bd2630502f07976dcf44c4206b32330bdc4cabc568789ab79bc58da6f37f07a6a3fba39f1d843924fc28c396ab6ca1fb2573636f82e97723a00ddfd41237befa1dcf7ceb4be91c557d932debcdf99f4c1aef2cfab3c780b113b5e8d1b1a22019251f723801843ee4294ba5244a4579a85a8ce0452d7df84464ae011ac5172033487b71b1390a002ac369e953462954a92904d7bfcd02460973ca619727e6e25d60f98528999c3e8b0dbadceae4b94f9d61d3682ddf4636e5954f71abf8b346b4b7dc5ea0f5765412a7a909ee07a35a1f45868e8bd40fcbd441a79cb09ae3c6c323de6b5d6dd1639f089192974994890247add5a530514f87aea54bcaa89954da3f1f155582327cf19b2823e28fae25ed8d2e61e4bdaaf8977c701cbf848e5fd798417b7ca77aee2fe49350c3139ef1686569f996335d5cfbd6c766d69af5544dc2c5ec887ceb3da19057714a5b454f27c33afe8759c2699c195bbf0a1fe6209ca3a66455812a0d5579658b651605ba9e5da7b7c5a7d5a1d4ed8aa590d4d2b5f95f1aa8ade0ad9bb6e1c588f1c3706af00255d42026b911d1b716ae3873aff2add9ed71d83024f200e92af4a3c4097706a960ec1bd1248ae54a7a29c29c967985dfad9f62042b0732350012772cfa2a5c58fe9208ca0ceddf95c353b8a8dd5879c481097acc4537c594720baad68e02c3b5c0514c2b56fbebf93bdb2f73f202afbf741e4ccb6e0fcdb3904b76c75e9989be1b18bbcdcfa80ad1a82aedb28aedef48b68af6a2aa6df7a3622537a77b34265661288748cac85d4a7b0fca958c625a75de58a744b189a870a26dcacc6d5c644abd688a5f28ea29eb70777b12d34827f88a1ec5d00faab10cbf245e32c4cdf7968bcbf35611adcea9c1dc948caedd38f30e819d52bc659a9647cf4ec0fe9c44b6c4c0a31667478a874ae0958d1e7582a05340cef6720ec38adb5dd799f2fd48b6fd0e67b274a2a02d133fb15080d5fd8e60df9bbd9ec4a9ff36057118113158568e8ae3d8122c80cea980531220c70cc95958e18f0b8b2ce5b01fbc45a9184ff4c61e3e4ade55f4bbe941c648ba97a3b649135989635465ffac15d676940b442ade9c10f701eab6cc7e7e2d1183b3b3487b7bf9eed42eb0f53bbac65ef4f830705e5cee22cceb28e763848b96ab4f2162c2d74df41e287613b278d6577601fec8a66a649169ca3d07f7b7f04e457522d727f1f0787688eeebec8fd775974a01d03be9820751178fad78305058b2cad9954f87e286699e4e700b53ad4393283789f7289c6247d2ae8d8474bfad3e53197b66114be5e7ed54fd9c088bf238661009d0675eb9e31b5c04860a6471c837d05fa05ee72d98aeed149b9a167def6112f7142fd5446c5b1c2de4254665d4982a2bd1e17f80cb64961106db23d1668f8afaaf84e9b7006e8cfce453dfe0067259f15e74ac1ffa03161689e39c6532972cc940a9910081b9ac00f6d8cc4cf0a6be084a719fc823fc6a8f5dd1cdfb94fb5be29e570dd8fcdae3590e7c5025da39ca351bf9e6d28a1966c0ad874817b701428ee098c765fc3a8c418e74f63cef6c63046b11bacc169bdba3b4c6f0fcfa2bdf2df309ebaeb8ed910e040bd4fad58c9080a62985b59554bbd95ae8cbeb9f0f141e4c2eb5bde137fda3f268eb941e9d40b0e097ea98db91b1626c997761e408de073265cfcd3c46624bb8248219ffbef5a7f7fe79bcef5dec8e33be5d5aa4be495a93305765d62501444340dd70ffc2a504712f7515263bd9c17044621b5b636996f387a260bc0f63ada1647c99597016577d7665827f4bb6d54594968e37e975dcba87e4a84bf89b0addcbc923e809e2346efc8c21713acd62e0ae7eefcbf8942f82a888c2cd3218ed2df85a84a8f8077730bf5dd9001b816ce10f286d56a6cdeca89639a082e16f723f6720b4367334520b5840189dd1de87d9a7a8c5c764cc569e0626d5abc2f9f6126124bc28718a104be224c8a88f04c5360237ccc1bcaa01b88b2a3603cd8a266dd3b0afa402e54f6b95d6ea6df91bd8bddf001839fc37021da2fe146da299f432b13094daf9165f0281c7a8e0caee7f37d9411442d8ee6ce7bf8881382ae94f0e9663839d87febc15b022f66febffd1b151d4f3ca12a4925b739bb8639bc75933d2ac856f7caf698f35b6be555c1a3f72b05abd6bf10a9846a3bfb8f31e02da0b5ed8a36110e002ce337f43068489516a781b63255ab92a144fa97b1a6ea697ae6f6a21e45385ecd82392d232c8853411d90887119be80140b8036b7a58be2174a398f50fc21bcfc0f1230b657ce41deec0230776c6b281d9d6a3e237d927f9c59da3ea78b7583dd29faea399102bdef12469facc6e3cb52978765d2532daf8b47da71fb007369a08d6be18fad2c9999b11569f38dfbf5e5609c6a55370ea424535b67242650827947fdfe6b5560080d9fe17199ff40e475da9dca8b13257716ccab012d11c9c99ab086ed712c86d62bcf091d5305a1a9647dab8eb8aa90230990ce16c7420f3fa95b4bb4e9dc84318d9d1c58a8be9ab63f19ad2b8593e32a8751280ed852f582c499a1cdb8f676d1780da447589a6bc2e05ee6ab8cdca394060c1d385d2b1cf3c2b8bdbcd6f361674167d42901ebada4c457662b72b7ae07c94661ebb10a2daac5f16e9d858e784eabd31bf563a7c0e6001fcf668647fd4a42f723066e59abaef61846ad80ce74fde3ffc1963b447fdba927df537b2d4c0004a7ddd8a4ba1dc042ba6a6e8cd3792df8d7d3ffe1189a5f429af3b2c2b74c74e7e74454013963d90feeb08b0f014eb0ddba093c5f1e1802df5b3973525f416f540d19fc4d84990849afa320de6c426ee223840453bada9cdedb7e567fa673ab52b5fe3b9a7e4e77f0ad5013c55729718fbfb6269a87c76109fc602ef246df217bbd3002c9d09326b042ddf6638ae820d7fca01b0f1b92433d0d09900f8d35eb2933f2309daf619d7d048b6a00033974cf88a513fdc035347bb5d7b278a86e18d1f7d49f9d632a9cebd023f822c561c11e559c1e3999be011df22b3fc68242c1f5dc23f856dbe3fcb59583e60b6fca2aa378c781dd2c7164ecace32c215ef8c9b23ad17f5b6af2a29721035725078b7a91672dc0455679e50df831add5bb132371363d3834e1d5ff88d0a3d3d637ae90c06b26a92477c17e7d76857b4f49188fd202b187525e5cadfe4c2710d7a944304df9e590938f5cbae4aca2e6a5f6b44fd1f126bef7f37314f8b830043d604ba88027972c6470ade76328893323c9546fd9fc4d54ce48c09e019cdfee7457f4286380ab303bf0d3021745895351d89dfacceff349f03a20b17cbeabf01e71d8251f82c2688627243a834aeed4f14cf7103202903af39e1e16ce412c9b8caf63a2afc83409a2e8c42d2f214e19f04ca458533daefdfca70541d73cf2fc103d3e1516c2e075861279d5464b9ce6d7b4d9790337a1a8cee427018a56169861d376c79e688dab057f7515dbe48591a06e055f11a18796635e6e9e9d48bb6c055e8a4185f6d60d4a317ab1bb5400008b487c9efa9eca2710051549b67049314974b4995771f69d82c0ab3cb9025bb27fa52c3fe30b8fb2f93f410e931d4a72b9260e5afe1505070771cfe7b789a7a6ddd7bd799bfb824225511ac58b36c65d61c45e0912c5ba4294c6902e3b5aaaabcbf927c0248ab9c9679fc00ab425db714d70e4bf34dfac7e1c005ebe289bd3a1811a29c0db9a21e79e89211eb750522fcb8c6803184e3b3ae29d0d6270f7a0afca7649a8c023a106ec5ac1bc421bbd015df1efe2e7868e3bc17386d567d006ee4973e653e3369a15b83a9d4bcd1ac9640ffe7e51e87ad0f1e1eadaffa6d080dfb5da00307f6dcc6cd7696254815dd859fce471dd6227785787bb9a38f8cc31309a73d870519daa070648adf06b19b4315b33be7d8580bbd2dd2a18f594f0d27fcee370e8c07938ab1f22f3853b977ca71528310814b9874da303194912e6e28e3bea6fbbcba4073a1cbcb6b2b74735d0dead0c922a90d109c6977a9014deba9cb0e23b09d97144193e92ed15ec5ddcf9decfe5cc5fe501781c20023ea6177580112ac2e55f18ec06822909aa9d24afd5aa75e37db99e11f4d6b1a4a6a737cb9196a48c0becc5acc0cedfc021f9b692f0593724146e0b9697d29593b223602527f3e4a4473e9f7bd4cb5ad226979547538641de111d5e4bc2d62bd5bf2c87019b82be79b1809aa76ea88b2b9c78b749799b76fc8ac8ffa13d9eb4fdbbebc825c5d968eded2e565f2a903bf143594797b5b652e45a861e9280a63c76a9bd915b39c8518ddfa3ef759a6d50db437a486f7979798d972cec1f996f91824d9dd2613ae913dc97c88274033963248ee7f8638f2b8422b03b55251102e6580cfae025909a1e3a31eabea4531962590863e4b8939281c977b3e1495b4c1b02662114494dbe009f2fca5c2583f3230c9797c49e0e6e62d92da0a605890f5c993d709f071d21e12f99583b3d65aa4a5a228e94a7ec01c50223f04c354e7d902ece5d3f52e706d7e9a73e75311ca26a3590f518a16ad3125723f7bffdc10991b8a7ce9af3d20e046dde709fb454864823812cf849058aed485376433f27311c9099f60792f8a96c9a7d0da5e7e431e227e4f935a27169642e78a56a8d1839849d6fcc806b174005cbb009c3a02b8151e3e9bafe6e725d6e78f2d5c761a8d7fd4b77de6276d2e9af8806833b062f2190474d62e1996d93dc4b43b58c32c15cb6a2187f1d505450f1b5455d838dc0bf819c377dfea2c00438c68e38ac22e23fd417615471bd6775be08fe5b508623023ef5b51ead63934839d08484fd69c8002d873024aabaeeb31c7f2915f59db923f1865ad15ef0be37e365e9f6448466408778c2b3e8ea4d30e59f3d078da06893a72c454d93c956fa366782fc726a00b54fc6b7ec5d1738a2228afa12ce480c3468b4c66f49a44ae1b65b072d83e303b0241132c16039452eb2c4fb6cb9a08a1d0988e33c8a065434c4a5cf6bc183d3d241a9d76c75ffebe2022907a1ee7d25fb9e2f917236e83654345983ff5d53b6bab89eceb128dd64f61d9917c46852ad5b48a4114304bf9fe24bd128fe7e968ddf283f4cc3d8ebb924a3f68aea908fffbbbe686fee7cb81e9eb7280d455f85b5e9943b7b0b4f0a0bcefaf66d1ec6e45306f94a9f6be8d8b55dc44033169757f7b102b729173f6bf8c29529e3b40b2f215accf850b54627bcb0a3c433c7cf7080b535b181cf508ea0adf7ec8246a99f490f6da330e8ebc68c6110dbd9a37ad3ee57dba6e366484fd90e52be355b201d965761b492653c6d1e9049ccab1d01c945a5608c4cf61d90e0f28156a34dfcbfb5cad0389cc51d7f76f7481e67dd23cb7a87b35e1818ef37ad30ccbf01c268e55c0cc3aaf3ca37d3c7a72df22dd7627370e8f286cd862559050ab6fe5732bb0bab2b56aa1d181baef0c155d2a23d193cac031bc6276c79bbfc1098b7362eafc959e877f4fb8a93e473356c72d07f57325f2f3073f621a4c60d62f33329d3ee50911e75e82a1f09bb7f9e9eaaf4ffd157e72642fce1c576feff2954a9b71781660370e5e632395e01db63c4a539b882981adfda6099ff00ec90f6a786120c1346e7e081d0fcfab742ddf7a779b37c1fdc8b3e71970497318b03051fc6225b1319b0f9778bda6223abba4d0e1a05dc9abf620782063d10b6fc728c4450716ee5c94b5ebe726ed65676c7790bd5eaea57ef7120b3cc5760e4b69b11dce169cf8a2fb11e0781552fe776abed01c3a3bd31f50881b742a40f5e9fc8d0e3ae2c6410fc4470691fa5b168f09e1c09c052bcb928679a4300567707305ce7c0fa6143e835286b15f4b4da8593599bf2ad09233343f9b5c5de725050271144b79012a3d2aa047dd01ecd69975f8a38ec15e78749165f0fc896d9f9ff0bcf078628ee2d66ceb0ec1c57ef8b13cf320c0e4ff85ad9987c1157d311ed04b5ccbac186ecc8e24cad355c82c95b5ae6f48e5d90ee1ce6a8cffb3ea6c88dd6bba41462157bfe8700cf5b0fa74dee31caed7edde414a7548b9a8a158d28c3529ace9a491d4c1c61fe6ff103f698735d9d808ee7a066e537f5afcbbd4bda294f2f09d8a86a65776e0d69336779a6a03c75eebb7ad23bdc9418625c29fecb31f8e33ff4845c68ff306fc8b6d788ee0b04aad1086c1b479ecc8ff7607ba4850e1bf09bec4120e5957d14e3a860f0d28784715767bd1c75396c4bbde5a00d66e7f2b1bb1e11aa599c1c13990caba40a88eed4842726d0ee478005de2c8f5645765a4b64e012fc447df34b713219a4f6cd454bd085065b0a551e194ba4de01be843f7f9cfe96f02df5bfb517fce4e7b7bbaa2d4d51ba9cf87b988d4dd40cac356d05756399b93909a1cddef27c49be844e679accb4b3fba59695795ccef39fdb65d2763f117a9bf20ab55383fd7e06dd047f32304abc8a641ab841672662b15395221cfa56fe3cea506193917ca0c5ecb7a2666c214a036818f2ed8ceaa436524a17171a54f2dc0f32be0ead6ba1587e82a43c6941f6c3b2a84e66892e59dfc2774ac6d741a6d8ef60760b2ec9037cb25bb4e39c4d75860c3e7e979c860af0056271e7df1a8bdcc29c8bae2e97ee525b07545119956a72c36c1c84a9302b5f104b77465b2474961f2f4288e5632563920e5cd5369e790d49397f0b2d368e28428957b3e4822ff18395eb58d53aee14a7a4366327b59bc7646f4ba16bd8ac9bd3e945e5542998ec07249f5f875c60fe03c72e4623f0bc220f9b36580efb5dc52baad508b3b96bcf0c0161055076ea2daa6b9d7a55ab5cf23e4856cb43da64bd0b16bed53b23590ece663fe128e4430665dacdb98b6298c80891bae63df66b7476f9fa0f13247b820f72cdd458fbbd4f03a50a7da659f9254f651c1f12a6547135432ba21447570eaf82fc6e6b2cbc3907d696f1f9f8ede3a9607873c47a302e461fcc29a40e8aa5f3607fd2b755a1dd63d267d4cc96babf17ff0af0cbf0d76788d75e2ab20cceeb1fcaa5b9be29c21b50e7273867f0caa605352d465ecc3e8f60afac5e9f93ddde05008c4110cd54772dc04b024e03071bdfe9fb4e18fdbda179423018cd7da4118fe113eef8bdea6f3cf6ad5dc05b69a42d5b49ca5c5a7134e33c076f0b987b3e6b5d8e6cb909b3a8927fc7ab2ddaf17d4927067b4ceb3c8aff9f6c2f13558d32d33101427845bca50886fbbd69fbd71427396cd44142af60dc03216994623cfda6db4eb40e2c0ca52ee9faae54b8ec2809873cf1a7885d9fdb0b00276093a82c5f78ada6c7fcf25cdbfd2aca1bbd47d68a387a153a51807c2d515aec1620aa11cb7b3d0850d68439b01b2f046e71f2f9bd3fc710601dd95c1e2f500d1f8591be02f13c7d663b91d4cb99500090cbcd00a70def4bd9f175e82798cda8b8cf07f5a4765e00a5c3a9027966ecc0a4039cd6935c2d2923598eaa519c9ca08e239746a15b8172ce01db5f79ab8a50818c8f37cfdb4cd79cb7e8c6af83aa1b7471094ed4ce9c99f56d5857afce924ca324eb5367499d16cdf431e36beac257d1b5a50ab0a6b8ee1efccdef432980f8fc902b4fe5e4cfd36d5665fe813ac9419ab7b7ef50b2753f3396c652de4293ba4ebe493827ef687d6624ef072d7e8aa4f258313db41f39d9b67a815c334b14c5031a6d0f20faf677a6b1569a3abc5b6740f81c00c35fe895cbebfe5de7a50045c538aafb27abac5e8e09622ff542a07299a9ce250014e2e21a7f911302c964c82b2ff6fd76bc7dcbb6f2ea3324c0877ec5b996fcc09bfaeffedcd09a39d0244c770d09d4a408b03cabd7ced6862cfcad8c799cfb283917048a9c72c7716c18a3d086384a4d7be04ea0a39aa56fdfb2a47e019552221bcb128cca5bf230b9c65b88ed1d2fb59349a543cad439e05af8ca802319bd01e86d82d8850b435770fa5cc82561be52b2622f7fffb02328b87ae5982009691102168630db672d9b1179d03daa78cbd1a16bb5eb17d17c9e0b11c138f0e0b944805927ba00299eb296eca079ed545a907153cc8abbb2b4b6466a20176e106fc106ee0a3edbbad23eea49024c461570493bac51a0db929ef698b6f466e09d07f02a2e00f0f98492d8ec59bc97fa52f52e06ad24b3c456a68a356f1cd55bcb3c738b643ed6cb504bfd698aaae1e525401a0f535d4304b8dd86b824f00d9685274789c5382cea478441153820425e83fa05aeb2186f3ce72196b88b0de107e9514dafdec46aa3ca25fce7990f1075b7541d9888a68a9e98327cc64d1c56ab95b962754d434463cd6c67c87b889fa2f5aae8f101aac04e61ecac11cb39f477f0e800a6cf43b9752bb24ca68c75dcb4c9bfa3c585cc9ce94b49accf5914f67cdf956f2451ddc56a8b0834e47c37f46fbcd94ade8f979264caba35414e34a6cc2c6d94608e9c8b51df3dfae84b68e6cd83aa2b4b6900f28a9bc6696ffc14118aa29c468230b85bcb843010e31b8ae9d25631d490e871f7837bc426bcd238ae35a253a9b779e4eab43f91ca3de17c0732446dc8d3e0b7bcbc439f994d65d15c5d91df4d25099455812aa4b1e8867be929824cf77128a2752caf0c5356e46988a0a97b3f6a3beb413350fe90ce48adb079656ea926815fc8f9a4d533b3204fffa8fbdb502616cd2edd4d663d1ea3786f4da3f857b7b772eb00b8d48a8b7a9c25e4a72bd2b079fa832b7aad6b377922b989cbd0cc718865f4517b1235d01b2878f42f6ae949182022dc9ab7dfc5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 线代 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谢希仁计算机网络06-应用层</title>
      <link href="/2023/11/25/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C06-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2023/11/25/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C06-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>应用层许多协议都是基于<strong>客户服务器方式</strong>。即便是 P2P 实质上也是一种特殊的客户服务器方式，客户 (clinet) 和服务器 (server) 都是指通信中涉及的两个<strong>应用进程</strong>。</p><h4 id="域名系统-dns">6.1 域名系统 DNS</h4><h5 id="概述">6.1.1 概述</h5><p>​ 域名系统 DNS 能把互联网上的主机名字转换为 IP 地址。互联网采用层次树状结构的命名方法，并使用分布式的域名系统 DNS。DNS 使大多数名字都在本地进行<strong>解析 (resolve)</strong>，仅少量解析需要在互联网上进行通信。</p><p>​ 域名到 IP 地址的解析是由分布在互联网上的许多<strong>域名服务器程序</strong>共同完成的，人们也常讲运行域名服务器程序的机器称为<strong>域名服务器</strong>。</p><p>​ 域名解析的请求以 UDP 用户数据报的方式进行传输。具体传输路径待后续探讨。</p><h5 id="互联网域名结构">6.1.2 互联网域名结构</h5><p>​ 互联网采用层次树状结构进行命名，任何一个连接在互联网上的主机或路由器，都有一个唯一的<strong>层次结构的名字</strong>，即<strong>域名 (domain name)</strong>。域还可以划分为子域，这样就形成了顶级域、二级域、三级域等等。每个域名由<strong>标号 (label)</strong> 序列组成，各标号间用<strong>点</strong>隔开，</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123095017782.png" alt="image-20231123095017782" /><figcaption aria-hidden="true">image-20231123095017782</figcaption></figure><ul><li>每个标号不超过 63 字符。</li><li>不区分大小写。</li><li>多标号组成完整域名不超过 255 字符。</li></ul><p>​ 顶级域名分为四大类：</p><ul><li><strong>国家顶级域名 nTLD</strong>：如 cn 表示中国，us 表示美国等等，又常记为 ccTLD (country-code)。</li><li><strong>通用顶级域名 gTLD</strong>：截至 2006 年 12 月，已达 20 个。公司企业 com，网络服务机构 net，非营利性组织 org，国际组织 int，美国专用教育机构 edu，美国政府部门 gov，美国军事部门 mil，等等。</li><li><strong>基础结构域名</strong>：又称反向域名，只有一个 arpa，用于反向域名解析。</li><li><strong>新顶级域名 New gTld</strong>：2011 年正式批准，任何公司机构都有权申请。</li></ul><p>​ 二级域名划分为<strong>类别域名</strong>和<strong>行政区域名</strong>两大类。</p><ul><li>类别域名：7 个，科研机构 ac，工商金融等企业 com，教育机构 edu，政府机构 gov，国防机构 mil，互联网服务机构 net，非营利性组织 org。</li><li>行政区域名：34 个，如江苏省 js，北京 bj，等等。</li></ul><p>​ 一般采用域名树来表示互联网的域名系统，其中根节点无名，如图：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123095841535.png" alt="image-20231123095841535" /><figcaption aria-hidden="true">image-20231123095841535</figcaption></figure><h5 id="域名服务器">6.1.3 域名服务器</h5><p>​ 一个服务器管辖的范围叫做<strong>区 (zone)</strong>，一个区中所有节点必须联通。每一个区设置相应的<strong>权限域名服务器 (authoritative name server)</strong>，用于保存该区主机域名到 IP 的映射。</p><p>​ 按照所起作用，可将域名服务器划分为四种不同类型：</p><ul><li><strong>根域名服务器 (root name server)</strong>：最高层次服务器，也是最重要的服务器。全世界 588 (2016 年 2 月) 个地点安装的跟服务器，只有 13 个域名，a.rootservers.net，...，m.rootservers.net。这表明，互联网是由 13 套装置构成这 13 组域名服务器。每一地点的根服务器往往由多台机器组成。根域名服务器采用<strong>任播 (anycast)</strong> 技术，DNS 客户查询时，路由器就能找到最近的一个根域名服务器。</li><li><strong>顶级域名服务器</strong>：管理在该服务器注册的所有二级域名，收到 DNS 请求时给出回答。</li><li><strong>权限域名服务器</strong>：负责一个区的域名服务器。当一个权限域名服务器还不能给出回答时，便回复客户下一步应当请求哪个服务器。</li><li><strong>本地域名服务器</strong>：并不属于服务器层次结构。主机发出 DNS 请求时，先发往本地服务器。本地服务器若无法作出回应，则继续作为客户方向其他根域名服务器发出查询报文，得到结果后再将回复发送给主机。</li></ul><p>​ 主机向本地服务器查询一般采用<strong>递归查询</strong>，即逐步深入。而本地服务器向根域名服务器查询采用<strong>迭代查询</strong>，即遍历询问。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123101430625.png" alt="image-20231123101430625" /><figcaption aria-hidden="true">image-20231123101430625</figcaption></figure><p>​ 为提高可靠性，DNS 域名服务器还将数据复制到几个域名服务器保存，其中一个为<strong>主域名服务器 (master name server)</strong>，其余为<strong>辅助域名服务器 (secondary name sever)</strong>。</p><p>​ 为提高效率，域名服务器广泛使用<strong>高速缓存</strong>，存放最近查询过的域名以及从何处获得域名映射信息的记录。域名服务器为每项内容设置计时器并处理超时项。</p><h4 id="文件传送协议">6.2 文件传送协议</h4><h5 id="概述-1">6.2.1 概述</h5><p>​ <strong>文件传送协议 FTP (File Transfer Protocol)</strong> 提供交互式访问，允许客户指明文件类型与格式，并允许文件具有存取权限。屏蔽系统细节，适合于在异构网络中任意计算机间传送文件。</p><p>​ 基于 TCP 的 FTP 和基于 UDP 的 TFTP 是文件共享协议的一大类，即<strong>复制整个文件</strong>，欲修改文件，只能修改副本，然后将整个副本传回。</p><p>​ 另一大类是<strong>联机访问 (on-line access)</strong>。由操作系统提供对远地文件进行访问的服务，如同对本地文件访问一样。操作系统提供<strong>透明存取</strong>。透明存取优点为更改远地文件时无需作过多改动。属于该协议的有<strong>网络文件系统 NFS (Network File System)</strong>。</p><h5 id="ftp-工作原理">6.2.2 FTP 工作原理</h5><p>​ 采用客户服务器方式。FTP 服务器进程由两大部分组成：一个负责接收请求的<strong>主进程</strong>和若干个负责处理单个请求的<strong>从属进程</strong>。工作步骤如下：</p><ol type="1"><li>打开熟知端口（端口号 21），以便客户连接。</li><li>等待客户发出连接请求。</li><li>启动从属进程处理请求，建立连接（熟知端口号 20），处理完毕终止该从属进程。</li><li>回到等待状态，继续接受请求。主进程与从属进程是<strong>并发</strong>的。</li></ol><p>​ 主进程即负责<strong>控制连接</strong>，从属进程即负责<strong>数据连接</strong>。FTP 控制信息是<strong>带外 (out of band)</strong> 传送的。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123103128516.png" alt="image-20231123103128516" /><figcaption aria-hidden="true">image-20231123103128516</figcaption></figure><p>​ NFS 允许应用进程打开一个远地文件并从某一特定位置开始读写数据，在网络上传送的仅是少量修改数据。</p><h5 id="简单文件传送协议-tftp">6.2.3 简单文件传送协议 TFTP</h5><p>​ 两个优点：</p><ul><li>可用于 UDP 环境。</li><li>代码所占内存小，可以用于小型机或某些特殊设备。</li></ul><p>​ 主要特点：</p><ul><li>每次传输 512 字节，最后一次可不足。</li><li>报文按序编号，1 开始。</li><li>支持 ASCII 或 二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。</li></ul><p>​ 发送一方在规定时间内收不到确认就需重发数据 PDU。 TFTP 熟知端口号码为 69。</p><h4 id="远程终端协议-telnet">6.3 远程终端协议 TELNET</h4><p>​ TELNET 能将用户击键传到远地主机，也能将远地主机输出通过 TCP 连接返回用户屏幕。又称<strong>终端仿真协议</strong>。</p><p>​ 为了适应不同操作系统的差异，TELNET 定义了数据和命令应怎样通过互联网，这些定义就是所谓的<strong>网络虚拟终端 NVT (Network Virtual Terminal)</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123104246975.png" alt="image-20231123104246975" /><figcaption aria-hidden="true">image-20231123104246975</figcaption></figure><p>​ NVT 的格式定义很简单。所有通信都使用 8 位一个字节。运转时，采用 7 位 ASCII 码传输数据，最高位为 1 时用作控制命令。定义了两字符的 <strong>CR-LF</strong> 作为标准的行结束控制符。</p><h4 id="万维网-www">6.4 万维网 WWW</h4><p>​ 万维网是一个<strong>大规模的、联机式的信息储藏所</strong>。能方便地从一个站点访问（或称<strong>链接</strong>到）另外一个站点。万维网是一个分布式的<strong>超媒体 (hypermedia)</strong> 系统，是<strong>超文本 (hypertext)</strong> 系统的扩充。超文本是指包含指向其它文档的链接的文本。超文本是万维网的基础。</p><p>​ 万维网以客户服务器的方式工作。客户发出请求，服务器返回客户所需的万维网文档。万维网必须解决如下几个问题：</p><ul><li>怎样标志分布在整个互联网上的万维网文档？</li><li>用什么协议实现万维网各种链接？</li><li>如何使不同作者创作不同风格的文档，都能在各种主机上显示出来，同时使用户清楚知道什么地方存在着链接？、</li><li>如何使用户方便找到所需信息？</li></ul><h5 id="统一资源定位符-url">6.4.2 统一资源定位符 URL</h5><p><span class="math display">\[URL:=&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\]</span></p><p>​ 常用协议 http，其次是 ftp。<主机>指出万维网文档的位置，<端口>和<路径>有时可以省略。</p><h6 id="使用-http-的-url">6.4.2.1 使用 HTTP 的 URL</h6><p><span class="math display">\[URL:=http://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\]</span></p><p>​ HTTP 默认端口号 80，通常可省略。若再省略路径，则连接到<strong>主页 (home page)</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123105938675.png" alt="image-20231123105938675" /><figcaption aria-hidden="true">image-20231123105938675</figcaption></figure><h5 id="超文本传送协议-http">6.4.3 超文本传送协议 HTTP</h5><h6 id="http-的操作过程">6.4.3.1 HTTP 的操作过程</h6><p>​ 从层次角度看，HTTP 是<strong>面向事务的 (transaction-oriented)</strong> 应用层协议，可以传输任何可从互联网上得到的信息，如文本、超文本、声音和图像等。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123113251838.png" alt="image-20231123113251838" /><figcaption aria-hidden="true">image-20231123113251838</figcaption></figure><p>​ 每个万维网网点都有一个服务器进程，不断监听 TCP 端口 80，以便发现是否有连接建立请求。一旦监听到连接建立请求并建立 TCP 连接后，浏览器就发出浏览某个页面的请求，服务器就返回页面作为响应。这种交互过程遵循的格式和规则，就是 HTTP。</p><p>​ HTTP 报文通常使用 TCP 的连接传送，但 HTTP 本身是<strong>无连接</strong>的。</p><p>​ HTTP 协议是<strong>无状态的 (stateless)</strong>。每次访问时服务器响应都相同，并不记录曾经的访问。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123113709977.png" alt="image-20231123113709977" /><figcaption aria-hidden="true">image-20231123113709977</figcaption></figure><p>​ 如图所示，请求一个 Web 文档所需时间是传输时间加上两倍往返时间 RTT。</p><p>​ HTTP/1.0 每次请求都有两倍 RTT 开销，加上每建立一次连接都需要分配缓存和变量，开销很大，这种<strong>非持续连接</strong>会使 Web 服务器负担很重。</p><p>​ HTTP/1.1 协议使用了<strong>持续连接</strong>，响应后仍在一段时间内保持该条连接，响应同一个服务器的请求。该协议有两种工作方式，<strong>非流水线方式 (without pipelining)</strong> 和<strong>流水线方式 (with pipelining)</strong>。</p><p>​ 非流水线特点是，客户收到前一个响应后才能发出下一个请求，节省了建立连接所需一个 RTT 时间。</p><p>​ 流水线方式特点是，客户收到响应前就可发送下一个请求，服务器可连续响应，访问<strong>所有对象</strong>只需一个 RTT 时间，提高了效率。</p><h6 id="代理服务器">6.4.3.2 代理服务器</h6><p>​ <strong>代理服务器 (proxy server)</strong> 又称<strong>万维网高速缓存 (Web cache)</strong>。将最近的一些请求和响应暂存于本地磁盘，新请求到达先经代理服务器查询，查询不到则作为客户发送请求。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123114554859.png" alt="image-20231123114554859" /><figcaption aria-hidden="true">image-20231123114554859</figcaption></figure><h6 id="http-报文结构">6.4.3.3 HTTP 报文结构</h6><p>​ HTTP 有两类报文：请求报文和响应报文。</p><p>​ HTTP 是<strong>面向文本的 (text-oriented)</strong>，因此报文每个字段都是一些 ASCII 码。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123114745262.png" alt="image-20231123114745262" /><figcaption aria-hidden="true">image-20231123114745262</figcaption></figure><p>​ <strong>开始行</strong>：请求报文称<strong>请求行 (Request-Line)</strong>，响应报文称<strong>状态行 (Status-Line)</strong>。最后 CR 和 LF 分别代表回车和换行。</p><ul><li><del>==有点复杂，先咕咕了==</del></li></ul><h5 id="web-文档">6.4.4 Web 文档</h5><h6 id="静态-web-文档">6.4.4.1 静态 Web 文档</h6><p>​ 超文本标记语言 HTML 是一种制作 Web 页面的标准语言。其中插入链接的终端可以是其它网站页面，称<strong>远程链接</strong>；亦可为本地计算机的某一个文件或文件某处，称<strong>本地连接</strong>。</p><p>​ XML (Extensible Markup Language) 是<strong>可扩展标记语言</strong>，设计宗旨是传输数据。</p><p>​ XHTML (Extensible HTML) 是可扩展超文本标记语言，是更严格的 HTML 版本，并将逐渐取代 HTML。</p><p>​ CSS 是<strong>层叠样式表</strong>。HTML 负责结构化内容，CSS 负责格式化结构化的内容。</p><p>​ 以上都是<strong>静态文档 (static document)</strong>，创建完即不会改变。缺点是不够灵活，但 HTML 可以由不懂程序设计的人员创建，优点是简单。</p><h6 id="动态-web-文档">6.4.4.2 动态 Web 文档</h6><p>​ <strong>动态文档 (dynamic document)</strong> 是指文档内容是在浏览器访问万维网服务器时才由应用程序动态创建的。动态文档的开发是编写用于生成文档的应用程序，因此开发难度更大。实现动态文档需要对 Web 服务器的功能进行扩充：</p><ul><li>增加一个应用程序用来处理浏览器发来的数据并创建动态文档。</li><li>增加一个机制，使 Web 服务器将浏览器发来的数据传送给该程序，Web 服务器解释该应用程序输出并向浏览器返回 HTML 文档。</li></ul><p>​ <strong>通用网关接口 CGI (Common Gateway Interface)</strong> 是一种标准，定义动态文档该如何创建，输入数据该如何提供给应用程序，输出结果应如何使用。 CGI 的正式名是 <strong>CGI 脚本 (script)</strong>，又称 cgi-bin 脚本，因为在许多 Web 服务器上，为便于找到 CGI 程序，就放在 /cgi-bin 目录下。</p><p>6.4.4.3 活动 Web 文档</p><p>​ 有两种技术可用于浏览器屏幕显示的连续更新：</p><ul><li><strong>服务器推送 (sever push)</strong>：将所有工作交给服务器，服务器不断运行与动态文档相关应用程序并定期更新发送。<ul><li>服务器开销过大。</li><li>要求 TCP 保持连接，TCP 连接数目增加导致平均带宽下降，时延增大。</li></ul></li><li><strong>活动文档 (active document)</strong>：把所有工作转移给浏览器端。传送角度看，浏览器和服务器都将活动文档看成静态文档。</li></ul><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123175807768.png" alt="image-20231123175807768" /><figcaption aria-hidden="true">image-20231123175807768</figcaption></figure><p>​ Java 技术是用于创建和运行活动文档的技术，是活动文档技术的一部分。</p><h5 id="web-信息检索系统">6.4.5 Web 信息检索系统</h5><p>​ 工具是<strong>搜索引擎 (search engine)</strong>，分两大类，<strong>全文检索</strong>搜索引擎和<strong>分类目录</strong>搜索引擎。</p><p>​ 全文搜索引擎通过搜索软件到互联网上各网站收集信息，建立一个在线索引数据库供用户查询，这种索引数据库必须及时更新以剔除过时信息。全文检索可以检索出大量信息，但缺点是结果不够准确。</p><p>​ 分类搜索引擎并不采集任何信息，而是用个网站向搜索引擎提交网站信息时填写的关键词和网站描述等信息，经审核后输入到分类目录数据库中，供用户查询。查询时无需使用关键词，只需按照分类，因而查询准确性较好。</p><p>​ 目前出现了<strong>垂直搜索引擎</strong>，在关键词检索基础上限制搜索领域，返回结果更倾向于信息、消息、条目等。</p><p>​ 还有<strong>元搜索引擎</strong>，将用户提交的检索发送到多个独立的搜索引擎上，处理结果并返回，重在提高搜索速度、智能化搜索结果、个性化搜索。查全率和准确率都较高。</p><p>​ Google 搜索软件同时进行许多运算，核心技术是 <strong>PageRank</strong>，即<strong>网页排名</strong>。PageRank 对链接数目进行加权统计。Larry Page 和 Sergey Brin 两人利用稀疏矩阵技巧，大大简化了计算量。</p><h5 id="博客和微博">6.4.6 博客和微博</h5><p>​ blog 使得网民不仅是互联网内容的消费者，亦是<strong>生产者</strong>。</p><p>​ 微博是一种互动及传播极快的工具，实时性、现场感和快捷性往往超过所有媒体。</p><h4 id="电子邮件">6.5 电子邮件</h4><h5 id="概述-2">6.5.1 概述</h5><p>​ 电子邮件两个重要标准：<strong>简单邮件传送协议 SMTP (Simple Mail Transfer Protocol)</strong> 和<strong>互联网文本报文格式</strong>。</p><p>​ SMTP 只能传送可打印的 7 位 ASCII 邮件，因此后来又提出<strong>通用互联网邮件扩充 MIME (Multipurpose Internet Mail Extensions)</strong>，可同时传送多种类型数据，数据类型于首部说明。</p><p>​ 一个电子邮件系统应有三个主要组成构件：<strong>用户代理、邮件服务器、邮件发送协议（如 SMTP）和邮件读取协议（如 POP3）</strong></p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123182738670.png" alt="image-20231123182738670" /><figcaption aria-hidden="true">image-20231123182738670</figcaption></figure><p>​ <strong>用户代理 UA (User Agent)</strong> 是用户与电子邮件系统的接口，又称为<strong>电子邮件客户端软件</strong>，如 Microsoft Outlook 和张小龙的 Foxmail。</p><p>​ 一个 UA 至少应当具有如下四个功能：</p><ul><li>撰写。</li><li>显示。</li><li>处理，包括发送邮件和接收邮件。</li><li>通信。</li></ul><p>​ 互联网上有许多<strong>邮件服务器</strong>，功能是发送和接收邮件并向发件人报告邮件传送结果，使用两种不同的协议，一种用于 UA 向服务器发送邮件或在服务器间发送邮件，如 SMTP；另一种用于 UA 从服务器读取邮件，如 POP3。</p><p>​ SMTP 和 POP3 都是用 TCP 连接来传送邮件的，使用 TCP 是为了保证可靠性。邮件由发送方服务器与接收方服务器间建立 TCP 连接进行传输，<strong>不会在任何中间邮件服务器落地</strong>。</p><p>​ 整个发送过程有两种不同通信方式，一是<strong>推 (push)</strong>，用于 SMTP 客户将邮件推给 SMTP 服务器；一是<strong>拉 (pull)</strong>，POP3 客户将邮件从 POP3 服务器拉过来。来件暂时存储在用户邮件服务器中，方便时便从服务器中读取来信。</p><p>​ TCP/IP 体系电子邮件系统规定<strong>电子邮件地址 (e-mail address)</strong> 格式如下： <span class="math display">\[username@邮件服务器域名\]</span></p><h5 id="smtp">6.5.2 SMTP</h5><p>​ SMTP 分连接建立、邮件传送、连接释放三部分，TCP 连接总是在通讯双方 SMTP 服务器直接建立，且 SMTP 传输的是明文，不利于保密。后来对 SMTP 进行扩充，称为 ESMTP。客户端发送报文时改用发送 EHLO 报文，若被拒绝则表明对方仍是一个标准的 SMTP 邮件服务器，不支持扩展，就采用原来的参数进行 SMTP 传输。</p><h5 id="电子邮件的格式">6.5.3 电子邮件的格式</h5><p>​ 首部包含一些关键字，最重要的是 To 和 Subject（<strong>主题</strong>），还有一项是<strong>抄送</strong>，表明给某某人发送一个副本。某些系统允许用户使用<strong>盲复写副本 Bcc (Blind carbon copy)</strong>，又称<strong>暗送</strong>，使发件人能将副本送与某人，但不希望为收件人知道。</p><h5 id="邮件读取协议-pop3-和-imap">6.5.4 邮件读取协议 POP3 和 IMAP</h5><p>​ 用户从 POP3 服务器读取了邮件，邮件即从服务器删除。容易猜到会有很多不必要的麻烦，因此 POP3 进行了些功能扩充，包括允许用户设置邮件读取后仍在 POP3 服务器中存放的时间。</p><p>​ IMAP 是一个联机协议，用户打开 IMAP 服务器的邮箱时，可以看到邮件首部。若需要打开某个邮件，则该邮件才传送到计算机上。缺点是如果用户没有将邮件复制到计算机上，则邮件一直存放在 IMAP 服务器中，需上网才能查看邮件。</p><h5 id="基于-web-的电子邮件">6.5.5 基于 Web 的电子邮件</h5><p>​ 打开浏览器后即可方便地收发邮件。</p><p>​ 浏览器和邮件服务器间传输用 HTTP 协议，但邮件服务器间仍采用 SMTP 协议。</p><h5 id="通用互联网邮件扩充-mime">6.5.6 通用互联网邮件扩充 MIME</h5><p>​ SMTP 有如下缺点：</p><ul><li>不能传送可执行文件或其它二进制文件。</li><li>限于传输 7 位 ASCII 码。</li><li>SMTP 服务器会拒收超过一定长度的邮件。</li><li>某些 SMTP 实现并未完全按照 SMTP 互联网标准。</li></ul><p>​ 于是提出<strong>通用互联网邮件扩充 MIME</strong>，继续用原来的邮件格式，但增加邮件主体结构，定义传送非 ASCII 编码规则。主要包括三部分：</p><ul><li>5 个新的首部，可包含在原来的首部中，提供了有关邮件主体信息。</li><li>定义了许多邮件内容格式，对多媒体电子邮件表示方法进行格式化。</li><li>定义传送编码，可对任何内容格式转换。</li></ul><p>​ 内容传送编码：</p><ul><li>最简单的是 7 位 ASCII，每行不能超过 1000 字符。</li><li>quoted-printable，适用于存在少量非 ASCII 码的数据，除特殊字符 '=' 之外，都不改变。'=' 和不可打印的 ASCII 以及非 ASCII 编码：二进制代码用两个十六进制数表示，然后在前加上一个等号 '='。'=' 的 quoted-printable 编码是 "=3D"。</li><li>base64 编码，可用于任意二进制文件。先将二进制代码划分为一个个 24 位单元，每个单元分为 4 个 6 位组，每个 6 位组按如下方法转化为 ASCII：0 到 63 的表示：先是 'A' 到 'Z' 26 个大写字母，再是 'a' 到 'z' 26 个小写字母，再是 '0' 到 '9' 10个数字，最后是 '+' 和 '/'。然后用 ASCII 码发送。 24 位的代码编码后变成了 32 位，开销为 25%。</li></ul><h4 id="动态主机配置协议-dhcp">6.6 动态主机配置协议 DHCP</h4><p>​ 在协议软件中给参数赋值的动作叫<strong>协议配置</strong>。连接到互联网的计算机的协议软件需要配置的项目包括：</p><ul><li>IP地址；</li><li>子网掩码；</li><li>默认路由 IP 地址；</li><li>域名服务器 IP 地址。</li></ul><p>​ 用人工进行协议配置很不方便，且易出错，应当采用自动配置方法。现在广泛使用的是<strong>动态主机配置协议 DHCP (Dynamic Host Configuration Protocol)</strong>，提供机制<strong>即插即用联网</strong>，允许计算机加入新的网络获取 IP 地址而不用手工参与。</p><p>​ DHCP 给运行服务器软件而位置固定的计算机指派一个永久地址，重启时地址不变。</p><p>​ DHCP 采用客户服务器方式。需要 IP 地址的计算机启动时就向 DHCP 广播<strong>发现报文 (DHCPDISCOVER)</strong>（目的 IP 地址全置为 1），DHCP 服务器回答报文称为<strong>提供报文 (DHCPOFFER)</strong>，先从数据库中查找配置信息，若找到则返回，找不到则从 IP 地址池中取出一个分配之。</p><p>​ 每个网络至少有一个 DHCP <strong>中继代理 (relay agent)</strong>，收到主机 A 的广播发现报文后，就<strong>单播</strong>向 DHCP 服务器转发报文，收到服务器回答报文后转发给 A。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231123194215241.png" alt="image-20231123194215241" /><figcaption aria-hidden="true">image-20231123194215241</figcaption></figure><p>​ DHCP 客户只能在一段有限时间内使用分配到的 IP，称为<strong>租用期 (lease period)</strong>。DHCP 客户使用的端口号为 68，服务器用的 UDP 端口是 67。</p><ul><li>租用期过了一半，DHCP 发送请求报文请求更新租用期。</li><li>若服务器同意，则发回确认报文。更新计时器。</li><li>不同意，则发回否认报文。客户必须重新申请 IP 地址。</li><li>提前终止租用期，发送释放报文即可。</li></ul><h4 id="简单网络管理协议-snmp">6.7 简单网络管理协议 SNMP</h4><h5 id="基本概念">6.7.1 基本概念</h5><p>​ 网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。</p><p>​ <strong>管理站</strong>又称管理器，是整个网络管理系统的核心，通常是个有着良好图形界面的高性能工作站，并由网络管理员直接操作和控制。</p><p>​ 管理站所在部门常称为<strong>网络运行中心 NOC (Network Operations Center)</strong>，管理站中关键构件是<strong>管理程序</strong>，管理站（硬件）或管理程序（软件）均可称为<strong>管理者 (manager)</strong> 或管理器，网络管理员 (administrator) 才是指人。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124091630752.png" alt="image-20231124091630752" /><figcaption aria-hidden="true">image-20231124091630752</figcaption></figure><p>​ 被管网络中有很多<strong>被管设备</strong>，可以是主机、路由器、打印机、集线器、网桥或网络解调器等。被管设备有时可称<strong>网络元素</strong>或<strong>网元</strong>。每个被管设备都要运行一个程序以便和管理站中的管理程序通信，这些程序称为<strong>网络管理代理程序</strong>或简称<strong>代理 (agent)</strong>。</p><p>​ <strong>简单网络管理协议 SNMP (Simple Network Management Protocol)</strong> 中的管理程序和代理按客户服务器方式工作。管理程序运行 SNMP 客户程序，代理运行 SNMP 服务器程序。被管对象 SNMP 服务器不断监听来自管理站 SNMP 客户的请求，一旦发现就立刻返回i信息或执行某个动作。</p><p>​ 网络管理基本原理：<strong>若要管理某个对象，必然会给该对象添加一些硬件或软件，但这种“添加”对原有对象影响必须小些。</strong></p><p>​ 若网元使用的不是 SNMP 而是另一种网管协议，可使用<strong>委托代理 (proxy agent)</strong> 实现如协议转换和过滤操作等功能对被管对象进行管理。</p><p>​ 下将详细介绍 SMI、MIB 和 SNMP。</p><p>​ SMI 建立规则，MIB 对变量进行说明， SNMP 完成网管的动作。</p><h5 id="管理信息结构-smi">6.7.2 管理信息结构 SMI</h5><p>​ SMI 有三个任务：</p><ul><li>被管对象怎么命名；</li><li>被管对象的数据类型；</li><li>被管对象如何编码。</li></ul><h6 id="被管对象的命名">6.7.2.1 被管对象的命名</h6><p>​ 采用<strong>对象命名树 (object naming tree)</strong>，根无名。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124092730981.png" alt="image-20231124092730981" /><figcaption aria-hidden="true">image-20231124092730981</figcaption></figure><h6 id="被管对象的数据类型">6.7.2.2 被管对象的数据类型</h6><p>​ SMI 使用基本抽象语法记法 1 (ASN.1) 来定义数据类型，也增加了一些新的定义。SMI 把数据类型分为两大类：<strong>简单类型</strong>和<strong>结构化</strong>类型。</p><p>​ 两种结构化类型 sequence 和 sequence of，前者类似于 C 语言的 struct，后者类似于 C 语言的 array。</p><h6 id="编码方法">6.7.2.3 编码方法</h6><p>​ SMI 使用 ASN.1 制定的<strong>基本编码规则 BER (Basic Encoding Rule)</strong> 进行编码。把所有数据元素表示为 T-L-V 三个字段，T (Tag) 定义类型，L (Length) 定义 V 字段长度，V (Value) 定义字段的值。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124093746676.png" alt="image-20231124093746676" /><figcaption aria-hidden="true">image-20231124093746676</figcaption></figure><p>​ T 字段又称为<strong>标记字段</strong>，分为如下三个子字段：</p><ul><li><strong>类别（2 位）</strong>：通用类 (00)，应用类 (01)，上下文类 (10)，专用类 (11)。</li><li>格式（1 位）：简单数据类型 (0)，结构化数据类型 (1)。</li><li>编号（5 位）：用以标志不同数据类型。</li></ul><h5 id="信息管理库-mib">6.7.3 信息管理库 MIB</h5><p>​ 管理程序使用 MIB 中信息的<strong>值</strong>对网络进行管理，只有在 MIB 中的对象才是 SNMP 所能管理的。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124094124719.png" alt="image-20231124094124719" /><figcaption aria-hidden="true">image-20231124094124719</figcaption></figure><p>​ MIB 变量只给出了每个数据项的逻辑定义，而一个路由器使用的内部数据结构可能与 MIB 的定义不同。</p><h5 id="snmp-的协议数据单元和报文">6.7.4 SNMP 的协议数据单元和报文</h5><p>​ SNMP 实际上只有两种基本管理功能：</p><ul><li><strong>读</strong>：Get 报文检测被管对象状况。</li><li><strong>写</strong>：Set 报文改变被管对象状况。</li></ul><p>​ SNMP 不是完全的探寻协议，允许不经过询问发送某些信息，这些信息称之为<strong>陷阱 (trap)</strong>，能捕捉事件，但参数受限。仅在严重事件发生时才发送陷阱，且陷阱所需字节数很少。</p><p>​ SNMP 使用无连接的 UDP，开销很小。在运行代理的服务器端使用熟知端口 <strong>161</strong> 接收 Get 或 Set 报文以及发送响应报文，运行管理程序的客户端使用熟知端口 <strong>162</strong> 接收来自各代理的 trap 报文。</p><p>​ SNMP 报文无固定字段，采用 ASN.1 编码。一个 SNMP 报文由四部分组成：<strong>版本、首部、安全参数、数据部分</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124094913065.png" alt="image-20231124094913065" /><figcaption aria-hidden="true">image-20231124094913065</figcaption></figure><h4 id="p2p">6.9 P2P</h4><p>​ 目前互联网流量中，P2P 文件分发已经占据最大份额。</p><h5 id="集中目录服务器的-p2p-初代-p2p-napster">6.9.1 集中目录服务器的 P2P —— 初代 P2P Napster</h5><p>​ 使用 Napster 可通过互联网免费下载各种 MP3 音乐，运行 Napster 的所有用户，都必须及时向 Napster 的目录服务器报告自己已经存有哪些音乐文件。当用户需要时，便向服务器发出查询，服务器返回存有这一文件的计算机 IP 地址。</p><h5 id="分布式结构的-p2p-文件共享程序">6.9.2 分布式结构的 P2P 文件共享程序</h5><p>​ 二代 P2P Gnutella 使用洪泛法在大量 Gnutella 用户间进行查询。其使用了一种<strong>有限范围的洪泛查询</strong>。</p><p>​ 下介绍更后来的技术——比特洪流 BT (Bit Torrent)。BT 把参与某个文件分发的所有对等方称之为一个<strong>洪流 (torrent)</strong>，对等方下载文件的数据单元称为<strong>文件块 (block)</strong>。</p><p>​ 每个洪流有一个基础设施节点称<strong>追踪器 (tracker)</strong>，一个对等放方加入洪流时必须<strong>登记</strong>（或称<strong>注册</strong>），并周期性通知其仍处于洪流中。</p><p>​ 一个洪流中，文件的需求方和提供方之间通过建立 TCP 连接传输文件块。当一个对等方 A 加入洪流时，追踪器为其指派若干个<strong>相邻对等方</strong>，A 通过 TCP 连接周期性向相邻对等方索取它们拥有的文件块列表。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124100046577.png" alt="image-20231124100046577" /><figcaption aria-hidden="true">image-20231124100046577</figcaption></figure><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124100053260.png" alt="image-20231124100053260" /><figcaption aria-hidden="true">image-20231124100053260</figcaption></figure><p>​ A 必须抉择的是：哪些文件块需要向相邻对等放请求？在众多请求中，应向哪些相邻对等放发送所请求的文件块？</p><p>​ 对于前者，A 采用<strong>最稀有的优先 (rarest first)</strong> 技术，凡是 A 所缺少而相邻对等方已拥有的块，都应当去索取。</p><p>​ 对于后者，采用算法：凡当前有以最高数据率向 A 传送文件块的某相邻对等方， A 就优先将请求块传送给它。</p><h5 id="在-p2p-对等方中搜索对象">6.9.4 在 P2P 对等方中搜索对象</h5><p>​ 数据库中存储信息仅两个部分：<strong>资源名 K</strong>（又称关键字）、存放该对象的节点的 IP 地址 N（有的 IP 还附有端口号）。</p><p>​ 现在广泛使用的索引和查找技术叫<strong>分布式散列表 DHT (Distributed Hash Table)</strong>，是由大量对等方共同维护的哈希表。基于 DHT 的算法如 Chord，把资源名 K 及 IP 地址 N 分别映射到<strong>资源名标识符 KID</strong> 和<strong>节点标识符 NID</strong>。把结点标识符从小到大沿顺时针排列成一个环形覆盖网络 Chord 环并按规则映射：</p><ul><li>NID 按照标识符值映射到 Chord 环上对应的点。</li><li>KID 按照其标识符值映射到最近的下一个 NID。</li></ul><p>​ 举例说明： K31 和 K2 都放在 N4，表示要找资源 K31 或 K2 的结点的 IP，应当到 N4 去找。即按 K 映射到 KID，从 KID 找到 NID，在 NID 中寻找 IP 地址 N。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124101342545.png" alt="image-20231124101342545" /><figcaption aria-hidden="true">image-20231124101342545</figcaption></figure><p>​ 定位一个资源，平均沿环发送查找报文 N/2 个或遍历所有结点，显然效率很低。</p><p>​ 为加速查找，可以采用倍增算法，每个结点 x 指向 <span class="math inline">\(x+1, x+2, x+4, x+8...\)</span> 的结点，这样当欲定位某个编号的结点时，即可在 log 的开销内查找。举例：</p><p>​ 当前在结点 <span class="math inline">\(1\)</span>，欲定位到结点 <span class="math inline">\(28\)</span>，则 <span class="math inline">\(1 + 16 = 17\)</span>, <span class="math inline">\(17 + 8 = 25\)</span>, <span class="math inline">\(25 + 2 = 27\)</span>, <span class="math inline">\(27 + 1 = 28\)</span>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231124101751582.png" alt="image-20231124101751582" /><figcaption aria-hidden="true">image-20231124101751582</figcaption></figure><p>​ P2P 存在一些关键的问题，一是知识产权，二是 P2P 流量管理，处理网上一些灰色资源，三是网络资源占据。</p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谢希仁计算机网络05-运输层</title>
      <link href="/2023/11/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C05-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2023/11/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C05-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="运输层概述">5.1 运输层概述</h3><h5 id="基础知识补充">5.1.1 基础知识补充</h5><p>​ 从 IP 层来说，通讯主体是两台主机。但从运输层的视角来看，真正进行通信的实体一台主机中的一个<strong>进程</strong>与另一台主机一个的<strong>进程</strong>。</p><p>​ 因此，运输层有一个比较重要的功能——<strong>复用 (multiplexing) </strong>和<strong>分用 (demultiplexing)</strong>。复用是指发送端不同应用程序可以使用同一个运输层传输协议。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121160059831.png" alt="image-20231121160059831" /><figcaption aria-hidden="true">image-20231121160059831</figcaption></figure><p>​ 由图观之，网络层为主机之间提供逻辑通信，而运输层为进程之间提供逻辑通信。</p><h5 id="运输层的端口">5.1.2 运输层的端口</h5><p>​ 单个计算机用的是进程标识符，但由于计算机操作系统种类很多，因此使用该种进程标识符来表示进程并不合适。</p><p>​ 此外，由于进程创建撤销均是动态的，通信一方几乎无法识别对方机器上的进程，因而将特定进程指名为终点是不可行的。</p><p>​ 解决方案是运输层采用<strong>协议端口号 (protocol port number)</strong>，或简称为<strong>端口 (port)</strong>。这种抽象的协议端口是<strong>软件端口</strong>。端口号只具有<strong>本地意义</strong>，只是为了标志<strong>本计算机</strong>应用层中的各个进程在运输层交互时的层间接口。不同计算机相同端口号是<strong>没有关联</strong>的。</p><p>​ 运输层端口号分为两大类：</p><ul><li><strong>服务器端使用的端口号</strong>：又分为两种<ul><li>熟知端口号：又称<strong>系统端口号</strong>。</li><li>系统端口号：又称<strong>短暂端口号</strong>，通信结束就回收可给其它进程使用。</li></ul></li></ul><h5 id="运输层两个协议">5.1.3 运输层两个协议</h5><p>​ <strong>用户数据报协议 UDP (User Datagram Protocol)</strong>：传输前无需建立连接，不提供可靠交付，且较为简单。</p><p>​ <strong>传输控制协议 TCP (Transmission Control Protocol)</strong>：提供<strong>面向连接</strong>的服务，但不提供广播或多播服务，较为复杂。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121162255202.png" alt="image-20231121162255202" /><figcaption aria-hidden="true">image-20231121162255202</figcaption></figure><p>​ 接下来将详细阐述两个协议的内容及要点。</p><h4 id="用户数据报协议-udp">5.2 用户数据报协议 UDP</h4><p>​ UDP 有主要特点如：</p><ul><li>UDP 是无连接的。</li><li>UDP 使用尽最大努力的交付。</li><li>UDP 是面向报文的。直接将来自应用程序的报文添加首部后即交付 IP 层，因此报文大小的缺点需由应用程序负责。</li><li>UDP 无拥塞控制。</li><li>UDP 支持<strong>一对一</strong>、<strong>一对多</strong>、<strong>多对一</strong>和<strong>多对多</strong>交互通信。</li><li>UDP 首部开销小，止 8 字节。</li></ul><p>​ 首部格式如图：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121162325100.png" alt="image-20231121162325100" /><figcaption aria-hidden="true">image-20231121162325100</figcaption></figure><p>​ 若接收方发现收到端口号不正确，则丢弃并由网际控制报文协议 ICMP 发送”端口不可达“差错报文。</p><p>​ ”伪首部“的出现是为了计算检验和，在实际传输中并不存在。检验和为 UDP 数据报每一个 16 位字之和的反码，到接收端再与每一 16 位字相加，最终结果为全 1 即无差错。</p><h4 id="传输控制协议-tcp-概述">5.3 传输控制协议 TCP 概述</h4><h5 id="tcp-协议主要特点">5.3.1 TCP 协议主要特点</h5><ol type="1"><li><strong>面向连接</strong>，使用前建立连接，使用后释放连接。</li><li>只能是<strong>点对点</strong>的通信。</li><li>提供<strong>可靠交付</strong>，无差错，不丢失，不重复，且按序到达。</li><li>提供<strong>全双工通信</strong>。</li><li>面向<strong>字节流</strong>。流是指<strong>流入到进程或从进程流出的字节序列</strong>。</li></ol><h5 id="tcp-的连接">5.3.2 TCP 的连接</h5><p>​ TCP 连接的端点叫<strong>套接字 (socket)</strong> 或<strong>插口</strong>，我们由： <span class="math display">\[socket = (IP:port)\\TCP\ link::=\{socket1,socket_2\}=\{(IP_1:port_1),(IP_2:port_2)\}\]</span></p><h4 id="可靠传输工作原理">5.4 可靠传输工作原理</h4><p>​ 理想传输条件两大特点：</p><ul><li>传输信道不产生差错。</li><li>不论发送端以多快速度发送数据，接收端总来得及处理收到数据。</li></ul><h5 id="停止等待协议">5.4.1 停止等待协议</h5><p>​ 假定 A 与 B 之间进行通讯。</p><h6 id="无差错情况">5.4.1.1 无差错情况</h6><p>​ 无差错时，A 发予 B 一个分组，B 接受后对 A 发送该分组的确认，A 收到确认后继续发送下一分组，如此往复。</p><h6 id="出现差错">5.4.1.2 出现差错</h6><p>​ B 接受到分组时除了差错并丢弃，或是分组在传输中丢失，B 都不会发送任何消息。A 过了一段时间没收到确认，就执行<strong>超时重传</strong>。为实现超时重传，每发送一个分组设置一个<strong>超时计时器</strong>。若计时器到期前收到确认，则撤销计时器。</p><ul><li>A 发送完分组必须保存副本以备重传。</li><li>分组与确认分组必须<strong>编号</strong>。</li><li>重传时间应稍大于平均往返时间，提升效率节省资源。</li></ul><h6 id="确认丢失与确认迟到">5.4.1.3 确认丢失与确认迟到</h6><p>​ 倘如 B 接收到分组 <span class="math inline">\(M_1\)</span>，但发回 A 的确认丢失，A 执行重传，B 又收到了相同的分组，此时应作两个动作：</p><ul><li><strong>丢弃重复分组。</strong></li><li><strong>向 A 发送确认。</strong></li></ul><p>​ 这种可靠传输协议通常称<strong>自动重传请求 ARQ (Automatic Repeat reQuest)</strong>。</p><p>​ 重传协议的优点是简单，但缺点是信道利用率低。 <span class="math display">\[U = \frac{T_D}{T_D+RTT+T_A}\]</span> <img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121184735026.png" alt="image-20231121184735026" /></p><p>​ 为了提高传输效率，我们采用<strong>流水线传输</strong>。为此引出下面一堆芝士。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121184822027.png" alt="image-20231121184822027" /><figcaption aria-hidden="true">image-20231121184822027</figcaption></figure><h5 id="连续-arq-协议">5.4.2 连续 ARQ 协议</h5><p>​ 核心概念是<strong>窗口</strong>，窗口大小设定为 size。</p><p>每次，发送端将窗口内连续的分组全部发送出去，接收端采用<strong>累计确认</strong>方式，对按序到达的最后一个分组发送确认。发送端每收到一个确认，就进行调整把滑动窗口前移。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121184940413.png" alt="image-20231121184940413" /><figcaption aria-hidden="true">image-20231121184940413</figcaption></figure><h4 id="tcp-报文段首部格式">5.5 TCP 报文段首部格式</h4><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121185758124.png" alt="image-20231121185758124" /><figcaption aria-hidden="true">image-20231121185758124</figcaption></figure><ul><li><strong>确认号</strong>：期望收到下一个报文段的第一个数据字节的序号。</li></ul><blockquote><p>若确认号 = N，则表明：到序号 N-1 为止所有的数据都已经收到。</p></blockquote><ul><li><strong>紧急 URG (URGent)</strong>：置为 1 时，紧急指针字段有效，应尽快传送。</li><li><strong>确认 ACK (ACKnowledgment)</strong>：置为 1 时确认号才有效。TCP 规定建立连接后所有报文段 ACK 都必须置为 1。</li><li><strong>同步 SYN (SYNchronization)</strong>：置为 1 表示是一个连接请求或连接接受报文。</li><li><strong>窗口</strong>：接收方让发送方设置其发送窗口的依据。窗口字段指出了现在允许对方发送的数据量。窗口值经常动态变化着。</li><li><strong>紧急指针</strong>：指出紧急数据字节数。</li><li>选项<ul><li>TCP 最初只规定一种选项，<strong>最大报文长度 MSS (Maximum Segment Size)</strong>，指的是每一个 TCP 报文段<strong>数据字段最大长度</strong>，默认值为 536 字节。</li><li>后续增加<strong>窗口扩大</strong>选项，TCP 首部窗口是 16 位，窗口扩大选项占 3 字节，其中一个字节表示移位值 S，位数从 16 增大到 (16 + S)，且 S 最大值为 14。无需扩大时，可以发送 S = 0 的选项。</li><li><strong>时间戳</strong>，一是用于计算往返时间 RTT，二是处理 TCP 序号溢出的情况。</li></ul></li></ul><h4 id="tcp-可靠传输的实现">5.6 TCP 可靠传输的实现</h4><h5 id="补充">5.6.1 补充</h5><p>​ TCP 滑动窗口也有可能后缩，但 TCP 标准<strong>墙裂不推荐这么做</strong>。重传机制已如上讲述。</p><p>​ 发送缓存暂时存放：</p><ul><li>发送程序传送给发送方 TCP 准备发送的数据；</li><li>TCP 已发送但未收到确认的数据。</li></ul><p>​ 接收缓存暂时存放：</p><ul><li>按序到达但尚未被接收程序读取的数据；</li><li>未按序到达的数据。</li></ul><p>​ 对于未按序到达的数据，TCP 标注并无明确规定如何处理。一般是待缺失的数据流收到后，再按序交付上层。</p><h5 id="超时重传时间的选择">5.6.2 超时重传时间的选择</h5><p>​ 采用自适应算法。<strong>RTT：往返时间。RTO：超时重传时间</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121192544945.png" alt="image-20231121192544945" /><figcaption aria-hidden="true">image-20231121192544945</figcaption></figure><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231229104747507.png" alt="image-20231229104747507" /><figcaption aria-hidden="true">image-20231229104747507</figcaption></figure><p>​ <strong>Karn 算法及修正</strong>：计算加权 RTTS 时，不考虑重传段。每重传一次，将 RTO 加倍。</p><h4 id="tcp-流量控制">5.7 TCP 流量控制</h4><p>​ 流量控制就是<strong>让发送方发送速率不要太快，让接收方来得及接收</strong>。</p><p>​ 发送方的窗口不能超过接收方给出的接收窗口的数值。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121194421960.png" alt="image-20231121194421960" /><figcaption aria-hidden="true">image-20231121194421960</figcaption></figure><p>​ 若 B 向 A 发送零窗口后， 又有了存储空间，继续发送 rwnd = 400 的报文段，却于传输途中丢失，A 一直等待 B 的通知，而 B 也一直等待 A 的报文段，若没有其它措施，死锁局面将一直持续下去。为此，TCP 为每个连接设有一个<strong>持续计时器 (persistence timer)</strong>。只要一方收到对方零窗口通知则启动计时器，时间到期则发送零窗口<strong>探测报文段（仅携带 1 字节数据）</strong>。若窗口值确实为 0，就重置，否则死锁局面被打破。</p><p>​ TCP 的实现广泛使用 Nagle 算法：若进程把数据逐字节发送到 TCP 缓存，则发送方把第一个数据字节先发送出去，把后面到达的全部缓存。当收到第一个数据字符确认后，再把缓存中所有数据组装成一个报文发送出去，对随后到达的数据缓存。仅当收到前一个段的确认后才发送下一个段。当到达数据已经到达发送窗口大小一般或最大报文长度，就立即发送。 这种算法可以有效提高网络吞吐量。</p><p>​ <strong>窗口糊涂综合征：</strong>TCP 接收方缓存已满，而交互式应用进程每次只从接收缓存中读取 1 字节。接收方发回确认，将窗口置位 1 字节。如此下去，效率很低。为解决此问题，可以让接收方等待一段时间，待缓存能容纳一个最长报文段或有一半闲余空间，发出确认报文，并通知当前窗口大小。</p><h4 id="tcp-拥塞控制">5.8 TCP 拥塞控制</h4><h5 id="拥塞控制一般原理">5.8.1 拥塞控制一般原理</h5><p><span class="math display">\[\sum对资源需求&gt;可用资源\]</span></p><p>​ 拥塞控制即<strong>防止过多数据注入到网络中，可以使网络中路由器或链路不至过载</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121202516053.png" alt="image-20231121202516053" /><figcaption aria-hidden="true">image-20231121202516053</figcaption></figure><p>​ 拥塞控制分为<strong>开环控制</strong>与<strong>闭环控制</strong>两种。开环控制是在设计网络时事先将有关发生拥塞的因素考虑到，但系统运行后就不做改变了。</p><p>​ 闭环控制基于环路反馈，有如下措施：</p><ul><li>检测网络系统以定位拥塞。</li><li>将拥塞信息传送到可采取行动的地方。</li><li>调整网络系统运行以解决问题。</li></ul><h5 id="拥塞控制方法">5.8.2 拥塞控制方法</h5><p>​ <strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong>四种算法。</p><ul><li>慢开始：发送方维护一个<strong>拥塞窗口 cwnd (congestion winodw)</strong> 变量，发送时<strong>发送窗口等于拥塞窗口</strong>。以超时为依据判断网络拥塞，自小到大采用倍增增大拥塞窗口。</li></ul><p><span class="math display">\[\Delta cwnd =min(N,SMSS)\]</span></p><p>​ 用报文段个数作为窗口大小单位，每经过一个传输轮次，cwnd 加倍。SMSS (Sender Maximum Segment Size) 是指发送方的最大报文段。</p><ul><li>拥塞避免算法：每经过一个 RTT 就让 cwnd 加 1，呈线性缓慢增长。</li></ul><p>​ 实际操作中，慢开始和拥塞避免是配合使用的。设定一个 ssthresh 值，cwnd 小于该值，用慢启动；cwnd 大于该值，用拥塞避免；等于二者均可。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121203427954.png" alt="image-20231121203427954" /><figcaption aria-hidden="true">image-20231121203427954</figcaption></figure><p>​ 超时则门限值置为当前 cwnd 的一半。当 B 端收到无序帧时，仍然发送对最前端已确认帧的确认，当 A 端收到一连三个确认帧，即可视为发生了数据丢失。</p><p>​ <strong>快恢复算法</strong>：发送端得知丢失个别报文段，便不进行慢启动，二是置拥塞窗口 sstresh = cwnd = cwnd / 2，并执行拥塞避免算法。</p><p>​ 拥塞避免阶段窗口线性增大，称为<strong>加法增大 AI (Additive Increase)</strong>。出现拥塞将门限值调整为原来一半，称为<strong>乘法减小 MD (Multiplicative Decrease)</strong>。二者结合即 AIMD 算法。</p><p>​ 同时发送窗口不得超过接收端窗口上限 rwnd。故有： <span class="math display">\[发送窗口上限 = min[rwnd,cwnd]\]</span></p><h5 id="主动队列管理-aqm">5.8.3 主动队列管理 AQM</h5><p>​ 路由器队列管理通常按照<strong>先进先出 FIFO</strong> 规则处理到来数据，当队列满时丢弃后续到达所有分组，称为<strong>尾部丢弃策略</strong>。但这种做法会导致短时间内大量连接同时进入满开始阶段，称为<strong>全局同步 (global syncronization)</strong>。</p><p>​ 为避免这种情况。出现了<strong>主动队列管理 AQM (Active Queue Management)</strong>，当队列长度达到某个警惕值时丢弃到达分组。曾流行的实现方法是<strong>随即早期检测 RED (Random Early Detection)</strong>，描述如下：</p><ul><li>若平均队列长小于最小门限，则将新分组加入队列。</li><li>若超过最大门限，则丢弃新分组。</li><li>若介于二者之间，则按某一丢弃概率 p 将新分组丢弃。</li></ul><h4 id="tcp-运输连接管理">5.9 TCP 运输连接管理</h4><p>​ 主动发起连接的进程称为<strong>客户 (client)</strong>，被动等待连接的进程称为<strong>服务器 (sever)</strong>。</p><h5 id="tcp-连接的建立">5.9.1 TCP 连接的建立</h5><p>​ 三次握手协议：（来自亲爱的 ChatGPT）</p><ul><li><strong>第一步 - 客户端发送连接请求：</strong><ul><li>客户端首先向服务器发送一个TCP报文，标志位中设置了SYN（同步）标志，并选择一个初始序列号（Initial Sequence Number）。</li><li>这个报文包含了客户端的一些连接参数，如MSS（Maximum Segment Size），表示客户端能够接受的最大报文段大小。</li></ul></li><li><strong>第二步 - 服务器确认请求并发送自己的连接请求：</strong><ul><li>服务器接收到客户端的SYN报文后，会回复一个确认报文，其中设置了SYN和ACK（确认）标志。</li><li>服务器也会选择一个自己的初始序列号，并在确认中包含自己的一些连接参数，如MSS。</li></ul></li><li><strong>第三步 - 客户端确认服务器的连接请求：</strong><ul><li>客户端接收到服务器的确认后，会向服务器发送一个确认报文，其中设置了ACK标志。</li><li>这个确认报文不包含SYN标志，因为连接已经建立。</li><li>服务器收到这个确认后，连接建立完成。</li></ul></li></ul><h5 id="tcp-连接释放">5.9.2 TCP 连接释放</h5><ol type="1"><li>A 的进程线向其 TCP 发出连接释放报文段，并停止发送数据，主动关闭 TCP 连接。FIN 报文消耗一个序号，即使不携带数据。</li><li>B 收到报文段后立即发出确认，确认号 ack = u + 1，从 A 到 B 的连接即释放了，但从 B 到 A 的连接仍未释放，TCP 处于<strong>半关闭</strong>状态。</li><li>若 B 依据没有要向 A 发送数据，则发出释放报文，假定序号为 w。A 收到后，必须发出确认，ack = w + 1，序号为 seq = u + 1，经过<strong>等待计时器</strong>设置的时间 2MSL 后， A 进入 CLOSED 状态。，MSL 是<strong>最长报文段寿命</strong>。</li></ol><p>​ 此外，TCP 设有一个<strong>保活计时器</strong>，每个一段时间发送探测字段，若一连几个都收不到回应，则关闭连接。</p><h5 id="tcp-有限状态机">5.9.3 TCP 有限状态机</h5><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231122081330855.png" alt="image-20231122081330855" /><figcaption aria-hidden="true">image-20231122081330855</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谢希仁计算机网络04-网络层</title>
      <link href="/2023/11/20/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C04-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2023/11/20/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C04-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h4 id="网络层提供的两种服务">4.1 网络层提供的两种服务</h4><p>​ 电信网采用<strong>面向连接</strong>的通信方式，并在此基础上使用可靠传输协议，当有通信需求时，双方建立<strong>虚电路</strong>进行实时通讯，通讯结束后释放通讯资源。由于终端电话机结构简单，无处理差错能力，因此此方案对电话业务来说是十分合适的。</p><p>​ 但计算机网络的终端具有很强的处理差错能力，因此网络层的设计思路为：<strong>网络层向上只提供简单灵活的、无连接、尽最大努力的数据报服务</strong>。<strong>网络层不提供服务质量的承诺</strong>，可靠传输由网络主机中的运输层保障。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118144200510.png" alt="image-20231118144200510" /><figcaption aria-hidden="true">image-20231118144200510</figcaption></figure><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118163954841.png" alt="image-20231118163954841" /><figcaption aria-hidden="true">image-20231118163954841</figcaption></figure><h4 id="网际协议-ip">4.2 网际协议 IP</h4><p>​ 与 IP 协议配套的三个协议：</p><ul><li><strong>地址解析协议 ARP (Address Resolution Protocol)</strong></li><li><strong>网际控制报文协议 ICMP (Internet Control Message Protocol)</strong></li><li><strong>网际组管理协议 IGMP (Internet Group Management Protocol)</strong></li></ul><p>​ 三协议关系如下：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118164422575.png" alt="image-20231118164422575" /><figcaption aria-hidden="true">image-20231118164422575</figcaption></figure><p>​ TCP/IP 协议中的网络层常常被称为<strong>网际层</strong>或 <strong>IP 层</strong>。</p><h5 id="虚拟互联网络">4.2.1 虚拟互联网络</h5><p>​ <strong>没有一种单一的网络能够适应所有用户的需求</strong>。将网络连接起来需要一些不同的中间设备，一般有如下四种：</p><ul><li>物理层：<strong>转发器 (repeater)</strong></li><li>数据链路层：<strong>网桥</strong>或<strong>桥接器 (bridge)</strong></li><li>网络层：<strong>路由器</strong></li><li>网络层以上：<strong>网关 (gateway)</strong></li></ul><p>​ 由于历史原因，许多 TCP/IP 的文献曾把网络层使用的路由器称为网关。</p><p>​ 参与互连的计算机网络都是用相同的网际协议 IP，因此可以看作一个大的虚拟互连网络。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118170200174.png" alt="image-20231118170200174" /><figcaption aria-hidden="true">image-20231118170200174</figcaption></figure><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118181737412.png" alt="image-20231118181737412" /><figcaption aria-hidden="true">image-20231118181737412</figcaption></figure><h5 id="分类的-ip-地址">4.2.2 分类的 IP 地址</h5><p><span class="math display">\[IP地址 ::=\{&lt;网络号&gt;,&lt;主机号&gt;\}\]</span></p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118181859665.png" alt="image-20231118181859665" /><figcaption aria-hidden="true">image-20231118181859665</figcaption></figure><p>​ 其中 D 类地址用于<strong>多播</strong>。</p><p>​ <strong>点分十进制表示法</strong>：32 位 IPv4 地址，八位一段点分隔，每段十进制表示。</p><p>​ 常用的三种类别 IP 地址</p><ul><li>A 类地址：<ul><li>网络号占一个字节，第一位固定为 0，共 126 (<span class="math inline">\(2^7-2\)</span>) 个可分配，全 0 表示 "this"，意为“本网络”， 127 (01111111) 保留作为本地软件<strong>环回测试</strong>本主机进程之间通信之用。</li><li>主机号占三个字节，因此一个 A 类网络号最大主机数为 <span class="math inline">\(2^{24}-2\)</span> 。全 0 表示本主机连接到的单个网络地址，全 1 表示该网络上的所有主机。</li></ul></li><li>B 类地址：<ul><li>网络号占两个字节，前两位固定为 10，共 <span class="math inline">\(2^{14}-1\)</span> 个可分配，128.0.0.0不指派。最大主机数 65534，扣除全 0 和全 1。</li></ul></li><li>C类地址：<ul><li>网络号占三个字节，前三位固定 110，192.0.0.0 不指派，因此 <span class="math inline">\(2^{21}-1\)</span> 个网络号。每个 C 类地址最大主机数 254。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118183641070.png" alt="image-20231118183641070" /><figcaption aria-hidden="true">image-20231118183641070</figcaption></figure><p>​ 两个路由器相连，在连线两端的接口处可分配也可不分配 IP 地址。节省资源则不分配，常称为 <strong>无编号网络</strong>或<strong>无名网络</strong>。</p><h5 id="ip-地址与硬件地址">4.2.3 IP 地址与硬件地址</h5><p>​ <strong>物理地址是数据链路层和物理层使用的地址，</strong>而 <strong>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</strong></p><p>​ 在通讯过程，数据从高层下到低层，层层封装，然后才到链路上传输。设备在收到 MAC 帧时，根据首部硬件地址决定收下或丢弃。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118184141275.png" alt="image-20231118184141275" /><figcaption aria-hidden="true">image-20231118184141275</figcaption></figure><p>​ <strong>IP 层抽象的互联网上只能看到 IP 数据报</strong>。</p><p>​ <strong>虽然 IP 数据报有源地址，但路由器只根据目的站 IP 地址的网络号进行路由选择</strong>。</p><h5 id="地址解析协议-arp">4.2.4 地址解析协议 ARP</h5><p>​ 知道 IP 地址，找出其相应的硬件地址。ARP 在主机 ARP 高速缓存 (<strong>APR cache</strong>) 中存放一个有<strong>本局域网</strong>上的各主机和路由器 IP 到硬件地址的映射表，并且映射表经常动态更新。</p><p>​ 当 A 向 B 发送 IP 数据报时，先在其 ARP cache 中查找，若查不到，则 ARP 进程广播 ARP 请求分组，除 B 外的主机不响应，B 则响应并向 A 发送 ARP 响应分组（单播），且 B 也将 A 的物理地址写入 cache 中。</p><p>​ ARP 解决的是<strong>同一个局域网</strong>上的映射问题。</p><h5 id="ip-数据报的格式">4.2.5 IP 数据报的格式</h5><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118200817531.png" alt="image-20231118200817531" /><figcaption aria-hidden="true">image-20231118200817531</figcaption></figure><ul><li><strong>版本</strong>：4 位，指版本号，实际使用的只有 IPv4 和 IPv6。</li><li><strong>首部长度</strong>：4 位，单位是 32 位字（即 4 字节）</li><li><strong>区分服务</strong>：8 位，一般情况不使用</li><li><strong>总长度</strong>：首部和数据之和的长度，16 位，因此数据报最大长度为 65535 字节。数据链路层中还有<strong>最大传送单元 MTU (Maximum Transfer Unit)</strong>。</li><li><strong>标识</strong>：16 位，每产生一个数据报，计数器 +1，并赋值给标识。</li><li><strong>标志</strong>：3 位，但目前只有两位有意义<ul><li>低位 <strong>MF</strong>。 MF = 1 表示后面“<strong>还有分片</strong>”的数据表， MF = 0 则表示当前已是最后一片。</li><li>中间为 <strong>DF</strong>。当前仅当 DF = 0 时允许分片。</li></ul></li><li><strong>片偏移</strong>：13 位，顾名思义，该片从何处开始。</li><li><strong>生存时间</strong>：8 位，没经过一个路由， TTL 减去 1，减为 0 时，就丢弃数据报。</li><li><strong>协议</strong>：8 位，指出使用的协议</li><li><strong>首部检验和</strong>：16 位，，只检验数据报首部，但不包括数据部分。发送方，检验和置位剩余 16 位字的反码之和。接收方将检验和在内的所有 16 位字相加，若首部未变化，其和必为 0。</li></ul><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118202056828.png" alt="image-20231118202056828" /><figcaption aria-hidden="true">image-20231118202056828</figcaption></figure><ul><li><strong>源地址</strong>：32 位</li><li><strong>目的地址</strong>：32 位</li></ul><h5 id="ip-层转发分组的流程">4.2.6 IP 层转发分组的流程</h5><p>​ 路由表信息： <span class="math display">\[(目的网络地址, 下一跳地址)\]</span> <img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118202909343.png" alt="image-20231118202909343" /></p><p>​ 存在<strong>特定主机路由</strong>，对特定的主机指明一个路由，以便管理人员控制网络和测试网络。</p><p>​ 存在<strong>默认路由</strong>，减小路由表所占的空间和搜索路由表所用的时间。</p><blockquote><p>默认路由（Default Route）是网络中的一种路由设置，用于指定当路由表中没有匹配的路由项时，数据包应该被发送到的下一个跃点或下一跳。默认路由通常用于简化路由表，特别是在大型网络中。</p></blockquote><blockquote><p>在IPv4网络中，默认路由通常使用0.0.0.0/0表示，这表示所有目标地址。当路由表中没有与目标地址匹配的具体路由项时，数据包将被发送到默认路由指定的下一个跃点。这有助于简化路由表，特别是在较大的网络中，减少路由表的大小和复杂性。</p></blockquote><blockquote><p>在IPv6网络中，类似的概念是使用::/0来表示所有IPv6地址。当没有与目标IPv6地址匹配的具体路由项时，数据包将被发送到默认路由指定的下一个跃点。</p></blockquote><p>​</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118203422006.png" alt="image-20231118203422006" /><figcaption aria-hidden="true">image-20231118203422006</figcaption></figure><p>​ <strong>分组转发算法的流程</strong>：</p><ol type="1"><li>从数据报首部提取目的主机 IP 地址 D，得出网络地址 N。</li><li>若 N 就是与此路由连接的某个网络，则 <strong>直接交付</strong>；否则执行 3。</li><li>若路由表有目的地址为 D 的特定主机路由，则交给其指明的下一跳；否则 4。</li><li>若路由表中有到达 N 的路由，则交给其指明的下一跳，否则 5。</li><li>默认路由，否则 6。</li><li>报错</li></ol><h4 id="划分子网与构造超网">4.3 划分子网与构造超网</h4><h5 id="划分子网">4.3.1 划分子网</h5><p>​ IP 地址设计不合理之处：</p><ul><li>IP 地址空间利用率有时很低，一个网络号所连接的主机可能并不多。</li><li>每个物理网络分配一个网络号会使得路由表太大而使网络性能变坏。</li><li>两级 IP 不够灵活，有时需要开辟一个新的网络，此时只能申请一个新的网络号。</li></ul><p>​ 划分子网的方法： <span class="math display">\[IP地址:=\{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;\}\]</span> ​ 从 IP 数据报首部<strong>无法看出</strong>源主机或目的主机所连接的网络是否进行了子网划分，<strong>子网掩码</strong>正是用于解决这个问题的。</p><p>​ 子网掩码一般由一串连续的 1 和一串连续的 0 构成，且 1 的长度等于网络号与子网号位数之和，因此与 IP 地址进行<strong>与</strong>操作即可得出子网地址。 如果一个网络不划分子网，则使用默认子网掩码，显然，</p><p>​ A 类地址默认掩码为 255.0.0.0，或 0xFF000000。</p><p>​ B 类地址默认掩码为 255.255.0.0，或 0xFFFF0000。</p><p>​ C 类地址默认掩码为 255.255.255.0，或 0xFFFFFF00。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119102550234.png" alt="image-20231119102550234" /><figcaption aria-hidden="true">image-20231119102550234</figcaption></figure><h5 id="使用子网时的分组转发算法">4.3.2 使用子网时的分组转发算法</h5><p>​ 路由表包含：<strong>目的网络地址、子网掩码</strong>和<strong>下一跳地址</strong>。</p><ol type="1"><li>从收到的数据报提取 IP 地址 D。</li><li>各网络子网掩码与 D 相与，看看是否匹配，若匹配则直接交付，否则 3。</li><li>若路由表中有目的地址为 D 的特定主机路由，则交付之，否则 4。</li><li>对路由表每一行子网掩码与 D 相与，结果为 N，若 N 与该行目的网络的地址匹配，则交付给下一跳，否则 5。</li><li>默认路由，否则 6。</li><li>报错。</li></ol><h5 id="无分类编址-cidr-超网">4.3.3 无分类编址 CIDR （超网）</h5><p><span class="math display">\[IP 地址:=\{&lt;网络前缀&gt;,&lt;主机号&gt;\}\]</span></p><p>​ 网络前缀相同的连续 IP 地址组成一个 ”CIDR 地址块”。</p><p>​ CIDR 使用斜线激发，即 IP 地址后加上斜线 “/”，后写上前缀位数。</p><p>​ CIDR 还使用 32 位的地址掩码，其中前一串 1 就代表前缀。</p><p>​ 路由表中用 CIDR 地址块来查找目的网络，称为<strong>路由聚合</strong>或<strong>构造超网</strong>。</p><p>​ 在查找下一跳时，可能有多个 CIDR 地址块都能够与目的地址匹配，此时则根据<strong>最长前缀匹配</strong>原则确定下一跳。</p><p>​ 由于要进行最长前缀匹配，故最方便的方法即是在构造路由表时采用<strong>二叉线索</strong>，即 01-Trie，然后查询时即可迅速进行前缀匹配。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119105513490.png" alt="image-20231119105513490" /><figcaption aria-hidden="true">image-20231119105513490</figcaption></figure><p>​ 为了提高效率，还可采用各式<strong>压缩技术</strong>。</p><h4 id="网际控制报文协议-icmp">4.4 网际控制报文协议 ICMP</h4><p>​ ICMP 报文分为 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</p><p>​ ICMP 报文前 4 个字节是统一的格式，三个字段：类型、代码和检验和。接着 4 个字节与 ICMP 类型有关。最后面是数据字段，长度取决于 ICMP 类型。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119150429359.png" alt="image-20231119150429359" /><figcaption aria-hidden="true">image-20231119150429359</figcaption></figure><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119150446519.png" alt="image-20231119150446519" /><figcaption aria-hidden="true">image-20231119150446519</figcaption></figure><p>​ <strong>改变路由（重定向）：</strong> 路由器把改变路由报文发送给主机，让主机知道下次该将数据报发送给另外的路由器（可通过更好的路由）。</p><p>​ 不应发送 ICMP 差错报告的情况：</p><ul><li>对 ICMP 差错报文，不再发送 ICMP 差错报文</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 报文。</li><li>对具有多播地址的数据报，都不发送。</li><li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 报文。</li></ul><p>​ ICMP 的一个重要应用就是<strong>分组网间探测 PING (Packet InterNet Groper)</strong>，是应用层直接使用网络层 ICMP 的一个例子。</p><p>​ 另一个重要应用是 traceroute (UNIX) / tracert (windows)，用于跟踪一个分组源点到终点的路径。下介绍其原理：</p><p>​ 主要采用数据报中的生存时间 TTL，先发送 TTL 为 1，收到<strong>时间超过</strong>差错报文则 TTL + 1 重新发送，否则收到<strong>终点不可达</strong>报文，且长度即 TTL。</p><h4 id="互联网的路由选择协议">4.5 互联网的路由选择协议</h4><h5 id="几个基本概念">4.5.1 几个基本概念</h5><h6 id="理想路由算法">4.5.1.1 理想路由算法</h6><p>​ <strong>理想路由算法</strong>几个特点：</p><ul><li>必须是正确的和完整的。</li><li>计算上应简单。</li><li>应能适应通信量和网络拓扑的变化（稳健性）。</li><li>应具有稳定性，通信量和网络拓扑相对稳定的情况下，应该收敛于一个可接受的解。</li><li>算法应该是最佳的。</li></ul><h6 id="分层次的路由选择">4.5.1.2 分层次的路由选择</h6><p>​ 互联网采用<strong>分层次的路由选择</strong>，原因：</p><ul><li>互联网规模非常大。</li><li>许多单位不愿外界了解自己内部网络的细节。</li></ul><p>​ 为此，把互联网划分为许多小的<strong>自治系统 AS (autonomous system)</strong>。一个 AS 对其他的 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</p><p>​ 故此，路由选择协议可以划分为两类：<strong>内部网关协议 IGP (Interior Gateway Protocol)</strong> 和<strong>外部网关协议 EGP (External Gateway Protocol)</strong>。常用的 IGP 有 RIP 和 OSPF 协议，常用的 EGP 有 BGP-4。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119160651490.png" alt="image-20231119160651490" /><figcaption aria-hidden="true">image-20231119160651490</figcaption></figure><p>​ 此外，路由选择协议还可依照路由表更新方分为<strong>静态路由协议</strong>和<strong>动态路由协议</strong>，常见的动态路由协议有 RIP、OSPF、BGP 等。</p><h5 id="rip">4.5.2 RIP</h5><p>​ RIP 是一种<strong>基于距离向量的路由选择协议</strong>，最大优点是简单。其中的“距离”是指“<strong>跳数</strong>” (hop count)。但 RIP 一条路径最多只能包含 15 个路由器，因此 RIP 只适用于小型互联网。</p><h6 id="rip-特点">4.5.2.1 RIP 特点</h6><p>​ RIP 特点：</p><ul><li>仅和相邻路由器交换信息。</li><li>路由器交换的信息是当前本路由器的路由表。</li><li>按照固定的时间间隔交换路由信息，如 30 秒。</li></ul><p>路由表信息为： <span class="math display">\[(路由表,距离,下一跳)\]</span></p><p>​ 下介绍路由更新算法：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119161304200.png" alt="image-20231119161304200" /><figcaption aria-hidden="true">image-20231119161304200</figcaption></figure><p>​ 其实就是 Bellman-Fold 算法，不断遍历，能松弛即松弛。</p><p>​ 对于解释 3，书中的解释是无论距离是增大减小亦或不变，都要更新为最新的信息。</p><h6 id="rip-报文格式">4.5.2.2 RIP 报文格式</h6><p>​ RIP 报文格式：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119161732197.png" alt="image-20231119161732197" /><figcaption aria-hidden="true">image-20231119161732197</figcaption></figure><ul><li><p>首部 4 字节，命令字段指出报文意义。</p></li><li><p>路由部分由若干路由信息组成，每个路由信息 20 字节。</p><ul><li><strong>地址标识符</strong> 标志所用地址协议。 <strong>路由标记</strong>填入自治系统号 ASN。</li><li>网络地址、子网掩码、下一跳路由地址、距离。</li></ul><p>一个 RIP 报文最多 25 个路由，故而最大长度 <span class="math inline">\(4+20\times 25=504\)</span> 字节。</p></li></ul><p>RIP 存在的问题：<strong>当网络出现故障，需要经过比较长的时间才能将此信息传送到所有的路由器</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119163624180.png" alt="image-20231119163624180" /><figcaption aria-hidden="true">image-20231119163624180</figcaption></figure><p>​ RIP 特点总结：<strong>实现简单开销小，距离有限，坏消息传播慢</strong>。</p><h5 id="内部网关协议-ospf">4.5.3 内部网关协议 OSPF</h5><p>​ <strong>OSPF 开放最短路径优先</strong> 使用了 Dijkstra 提出的<strong>最短路径算法 SPF</strong>。OSPF 三个要点如下：</p><ul><li>洪泛法：向本自治系统<strong>所有</strong>路由器发送信息。</li><li>发送的信息是与本路由器相邻所有路由器的链路状态。</li><li>当且仅当链路发生变化，才使用洪泛。</li></ul><p>​ 由此，每个路由器都能够得到本网完整的网络拓扑，采用 djikstra 算法即可得出最短路径从而构造路由表。</p><p>​ 而且 OSPF 将一个自治系统再划分为若干个小的范围，称为<strong>区域 (area)</strong>。连接不同区域的路由器叫<strong>区域边界路由器</strong>。主干区域的路由器称<strong>主干路由器</strong>。OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119170556159.png" alt="image-20231119170556159" /><figcaption aria-hidden="true">image-20231119170556159</figcaption></figure><p>​ OSPF 其它特点：</p><ul><li>允许管理员指派不同代价，代价占 16 位，十分灵活。</li><li>若一个目的网络有多条相同代价路径，则可以分配通信量，达到<strong>负载平衡 (load balancing)</strong>。</li><li>支持可变长子网划分与 CIDR。</li><li>链路可能经常变变化，每条链路带上一个序号，序号越大链路越新。</li></ul><p>​ OSPF 五种分组类型：</p><ul><li><p><strong>类型1 问候 (hello) </strong>分组，用于发现维持邻站可达性。</p></li><li><p><strong>类型2 数据库描述 (Database Description) </strong>分组，向邻站给出自己库中所有链路状态项目的摘要。</p></li><li><p><strong>类型3 链路状态请求 (Link State Request)</strong> 顾名思义</p></li><li><p><strong>类型4 链路状态更新 (Link State Update)</strong> 洪泛</p></li><li><p><strong>类型5 链路状态确认 (Link State Acknowledgement)</strong> 对更新分组的确认</p></li></ul><h5 id="外部网关协议-bgp">4.5.4 外部网关协议 BGP</h5><p>​ <strong>边界网关协议 BGP</strong>。不同自治系统之间使用 BGP 的缘由：</p><ul><li>互联网<strong>规模太大</strong>，使得自治系统 AS 之间路由选择非常困难。</li><li>自治系统 AS 之间的路由选择必须考虑有关策略。</li></ul><p>​ BGP 的目的寻找一条能够到达目的且网络条件比较好的路由而非最佳路由，采用<strong>路径向量 (path vector) 路由选择协议</strong>。每个自治系统至少选定一 <strong>BGP 发言人</strong>，往往选定<strong>边界路由器</strong>。发言人之间采用 BGP 协议。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main//newPath/image-20231120080108690.png" alt="image-20231120080108690" /><figcaption aria-hidden="true">image-20231120080108690</figcaption></figure><p>​ 在 RFC 4271 中规定了 BGP-4 的四种报文：</p><ul><li>OPEN 报文，用来与相邻 BGP 发言人建立关系，使其初始化。</li><li>UPDATE 报文，通告某一路由信息，以及列出要撤销的多路由。</li><li>KEEPALIVE 报文，周期性证实邻站连通信。</li><li>NOTIFICATION 报文，发送检测到的差错。</li></ul><p>​ BGP 报文格式：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120080845868.png" alt="image-20231120080845868" /><figcaption aria-hidden="true">image-20231120080845868</figcaption></figure><p>​ 标记 (marker) 段 16 字节长，用于鉴别，不需鉴别是置全 1。</p><p>​ 长度字段指出包括首部在内整个 BGP 报文<strong>字节</strong>为单位的长度，最小 19，最大 4096。（查了下，是根据 TCP 协议的滑动窗口决定的 <a href="https://zhidao.baidu.com/question/428983149?bd_page_type=0&amp;pu=&amp;init=middle">这里</a>)</p><p>​ UPDATE 和 OPEN 报文的格式暂时不赘述。</p><h5 id="路由器的构成">4.5.5 路由器的构成</h5><p>​ 路由器结构划分为两大部分：<strong>路由选择部分</strong>和<strong>分组转发部分</strong>。</p><p>​ 路由选择部分也称为<strong>控制部分</strong>，核心构建为选择处理机，任务是根据协议构造出路由表，同时不断更新维护路由表。</p><p>​ 分组转发部分有三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>。</p><p>​ 交换结构 (switching fabric) 又称<strong>交换组织</strong>，作用是根据转发表处理分组，把输入的分组从魔偶个端口输出出去。</p><p>​ 为了使交换功能分散化，往往把复制到转发表放在每个输入端口中，称为<strong>"影子副本"</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083022304.png" alt="image-20231120083022304" /><figcaption aria-hidden="true">image-20231120083022304</figcaption></figure><p>​ 最早使用的路由器是普通的计算机，采用 CPU 作为路由选择处理机，利用中断机制启动处理。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083350315.png" alt="image-20231120083350315" /><figcaption aria-hidden="true">image-20231120083350315</figcaption></figure><h4 id="ipv6">4.6 IPv6</h4><p>​ 变化：</p><ul><li><strong>允许协议继续扩充</strong>。</li><li>灵活的首部格式</li><li>扩展的地址层次结构</li></ul><p>​ IPv6 数据报有 <strong>基本首部</strong>和<strong>有效载荷</strong>两部分组成，有效载荷也成为<strong>净载荷</strong>。有效载荷允许零个或多个<strong>扩展首部</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083649979.png" alt="image-20231120083649979" /><figcaption aria-hidden="true">image-20231120083649979</figcaption></figure><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083714488.png" alt="image-20231120083714488" /><figcaption aria-hidden="true">image-20231120083714488</figcaption></figure><ul><li><strong>通信量类：</strong> 8 位，区分不同 IPv6 数据报类别或优先级。</li><li>流标号 (traffic class)：20 位。</li><li>有效载荷长度：除基本首部外的字节数。</li></ul><p>​ 扩展首部在传输中不进行处理，交给两端计算机处理，大大提高路由器处理效率。</p><p>​ IPv6 增加了任播 (anycast) 地址，终点是一组计算机，但数据报只交付其中一个，通常是最接近一个。</p><p>​ IPv6 采用<strong>冒号十六进制记法</strong>，如 <span class="math display">\[68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF\]</span></p><ul><li>允许省略前导 0。</li><li>可以将一串连续的 0 用一对冒号取代。</li><li>仅允许一次零压缩。</li><li>仍可采用 CDR 斜线表示法。</li></ul><p>​ 地址分类：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120084419498.png" alt="image-20231120084419498" /><figcaption aria-hidden="true">image-20231120084419498</figcaption></figure><h5 id="ipv4-向-ipv6-过渡">4.6.3 IPv4 向 IPv6 过渡</h5><p>​ 策略一：<strong>双协议栈</strong>。装有双协议栈的主机或路由器既能与 IPv4 主机通信，又能与 IPv6 主机通信。根据域名系统 DNS 返回的地址类型确定主机使用的地址类型。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120103834796.png" alt="image-20231120103834796" /><figcaption aria-hidden="true">image-20231120103834796</figcaption></figure><p>​ 策略二：<strong>隧道技术</strong>。IPv6 数据报进入 IPv4 网络时，把 IPv6 数据报封装成 IPv4 数据报。要使得双协议栈主机知道 IPv4 数据报内封装的时 IPv6 数据报，则需要将 IPv4 首部的协议字段值设置为 41。</p><h5 id="icmpv6">4.6.4 ICMPv6</h5><p>​ IPv6 也不保证数据可靠交付，因此采用 ICMP 来反馈差错。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120104137961.png" alt="image-20231120104137961" /><figcaption aria-hidden="true">image-20231120104137961</figcaption></figure><h4 id="ip-多播">4.7 IP 多播</h4><p>​ 与单播相比，一对多的网络通信中，多播可大大节约网络资源。</p><p>​ 多播组的标识符是 IP 地址中的 D 类地址，范围是 224.0.0.0 到 239.255.255.255。多播地址只能用于目的地址而不能用于源地址。一个 D 类地址表示一个多播组。</p><h5 id="网际组管理协-igmp-和-多播路由选择协议">4.7.3 网际组管理协 IGMP 和 多播路由选择协议</h5><p>​ IGMP (Internet Group Management Protocol) 网际组管理协议：是让连接在本地局域网上的多播路由器知道本局域网上<strong>是否</strong>有主机参加或退出了某个多播组。</p><p>​ 多播路由选择协议：多播转发必须动态适应多播组成员的变化，在转发数据报时，不能仅仅根据数据报中的目的地址，而是考虑从什么地方来到什么地方去。</p><p>​ IGMP 属于整个网际协议 IP 的一个组成部分。</p><p>​ 多播路由选择协议：洪泛与剪除、隧道技术、基于核心的发现技术。</p><h4 id="虚拟专用网-vpn-和网络地址转换-nat">4.8 虚拟专用网 VPN 和网络地址转换 NAT</h4><h5 id="vpn">4.8.1 VPN</h5><p>​ RFC 1918 指明了一些<strong>专用地址</strong>，只用于机构内部通信，互联网中所有路由器对目的地址为专用地址的数据报一律不予转发。</p><p>​ VPN 的作用是对内部数据报进行加密，然后在公网上传输，使得效果跟内网通信一样。</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120142854286.png" /></p><h5 id="nat">4.8.2 NAT</h5><p>​ 已经分配到本地 IP 地址，又想进行全球通信，则可使用 NAT。NAT 将每台计算机映射到 NAT 路由器的一个端口（每个端口具有一个全球 IP 地址），由此便可进行互联网通讯，此时目的主机只能知道 NAT 路由器端口的地址而不知发送端的地址。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120142901992.png" alt="image-20231120142901992" /><figcaption aria-hidden="true">image-20231120142901992</figcaption></figure><h4 id="mlps">4.9 MLPS</h4><p>​ MLPS 作为一种 IP 增强技术，广泛应用在互联网中。特点如下：</p><ul><li>支持面向连接的服务质量。</li><li>支持流量工程，平衡网络负载。</li><li>有效地支持 VPN。</li></ul><h5 id="工作原理">4.9.1 工作原理</h5><p>​ 在 MPLS 域入口处打上固定长的 MPLS 标记，然后对打上标记的 IP 数据报用硬件转发，只经过第二层，称为<strong>标记交换</strong>。</p><p>​ MPLS 域是指该域中有许多彼此相邻路由器，且均为支持 MPLS 技术的<strong>标记路由器 LSR</strong>。一个标记仅在两个 LSR 间才有意义。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120143602027.png" alt="image-20231120143602027" /><figcaption aria-hidden="true">image-20231120143602027</figcaption></figure><p>​ 如入接口 0 收到一个标记为 3 的 IP 数据报，路由器就知道应从出接口 1 转发且打上标记 1。</p><h5 id="转发等价类-fec">4.9.2 转发等价类 FEC</h5><p>​ IP 数据报的集合，对路由器来说具有相同的性质，如下一跳，相同服务类别，同样丢弃优先级等。</p><p>​ 例子：</p><ul><li>目的 IP 与某一特定 IP 地址前缀匹配的 IP 数据报</li><li>所有源地址与目的地址相同的数据报</li><li>具有某种服务质量需求的数据报</li></ul><h5 id="mpls-首部的格式">4.9.3 MPLS 首部的格式</h5><p>​</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120144102987.png" alt="image-20231120144102987" /><figcaption aria-hidden="true">image-20231120144102987</figcaption></figure><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120144109443.png" alt="image-20231120144109443" /><figcaption aria-hidden="true">image-20231120144109443</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谢希仁计算机网络03-数据链路层</title>
      <link href="/2023/11/02/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2023/11/02/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h4 id="使用点对点信道的数据链路层">3.1 使用点对点信道的数据链路层</h4><h5 id="数据链路和帧">3.1.1 数据链路和帧</h5><p>​ <strong>链路</strong>是指从一个结点到相邻节点的一段物理线路（有限或无线），而中间没有其它交换结点。链路是一条路径的组成部分。</p><p>​ 传输数据时，不仅需要物理线路，还需要一些必要的通信协议控制数据传输。若把<strong>实现该些协议的硬件与软件</strong>加到链路上，就构成了<strong>数据链路</strong>。现在最常用的方法是使用<strong>网络适配器（既有硬件也有软件）</strong>来实现这些协议。</p><p>​ 早期数据通信协议曾叫做<strong>规程 (procedure)</strong>。因此在数据链路层，规程与协议是同义语。</p><p>​ 数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的<strong>帧</strong>中的数据取出并上交给网络层。互联网中，网络层协议数据单元是 <strong>IP 数据报（或简称为数据报、分组或包）</strong>。</p><p>​ 点对点信道通信时的主要步骤：</p><p>​ (1) 结点 A 的数据链路层把网络层叫下来的 IP 数据报添加首部和尾部封装成帧。</p><p>​ (2) 结点 A 把封装好的帧发送给结点 B 的数据链路层。</p><p>​ (3) 若结点 B 数据链路层收到的帧无差错，则提取 IP 数据报并交给网络层，否则弃帧。</p><h5 id="三个基本问题">3.1.2 三个基本问题</h5><p>​ 三个基本问题：<strong>封装成帧</strong>、<strong>透明传输</strong>和<strong>差错检测</strong>。</p><h6 id="封装成帧">3.1.2.1 封装成帧</h6><p>​ <strong>封装成帧 (framing)</strong> 是指在一段数据前后分别添加首部和尾部，构成一个帧。首部和尾部的一个重要作用是进行<strong>帧界定</strong>。每一种链路协议都规定所能传送的帧的<strong>数据部分最大长度上限——最大传送单元 MTU (Maximum Transfer Unit)</strong>。</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261052318.png" /></p><p>​ 帧界定使用特殊的<strong>帧界定符</strong>，帧开始符 SOH （十六制编码 01）放于首部，帧结束符 EOT （十六进制编码 04)放于尾部。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261058141.png" alt="image-20231026105820053" /><figcaption aria-hidden="true">image-20231026105820053</figcaption></figure><h6 id="透明传输">3.1.2.2 透明传输</h6><p>​ 当传输数据是非 ASCII 码的文件时，如果数据中某个字节二进制代码恰好和 SOH 和 EOT 这种控制字符一样，则会产生错误。<strong>透明传输</strong>的概念是指，无论怎样的数据通过，数据链路层都能原样无差错传输该数据。</p><p>​ 为实现透明传输，发送端的数据链路层在发送数据中出现控制字符的位置前插入一个转义字符 ESC （十六进制编码 1B），接收端的数据链路层在将其送往网络层前提前删除这个插入的转义字符。此方法叫做<strong>字节填充</strong>或<strong>字符填充</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261441992.png" alt="image-20231026144110932" /><figcaption aria-hidden="true">image-20231026144110932</figcaption></figure><h6 id="差错检测">3.1.2.3 差错检测</h6><p>​ 比特在传输过程中可能会产生差错，<span class="math inline">\(0\)</span> 变成 <span class="math inline">\(1\)</span>，<span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>，这种情况叫<strong>比特差错</strong>。同一时间传输错误的比特占总传输比特数的比率叫做<strong>误码率 BER (Bit Error Rate)</strong>。但实际数据传输误码率不可能降为零，因此位保证可靠传输，必须进行差错检测。目前广泛采用<strong>循环冗余检验 CRC (Cyclic Redundancy Check)</strong> 检错技术。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261446007.png" alt="image-20231026144652892" /><figcaption aria-hidden="true">image-20231026144652892</figcaption></figure><p>​ 传输差错可分为两大类，一类是基本的比特差错，里另一类是更复杂些的<strong>帧丢失</strong>、<strong>帧重复</strong>或<strong>帧失序</strong>。因此出现比特差错与出现传输差错并不等价。为实现可靠传输，在 CRC 检错的基础上，增加了<strong>帧编号</strong>、<strong>确认</strong>和<strong>重传机制</strong>。现在互联网采用区别对待方法，对于通信质量良好的传输线路，不适用确认和重传机制，即要求数据链路层向上提供可靠传输；对于通信质量较差的链路，则采用确认重传机制，数据链路层向上提供可靠传输。</p><h4 id="点对点协议-ppp">3.2 点对点协议 PPP</h4><p>​ 通信质量较差的年代，采用可靠传输协议是一种好办法，因此当时比较流行能实现可靠传输协议的<strong>高级数据链路控制 HDLC (High-level Data Link Control)</strong>。目前对于点对点的链路，则广泛采用简单得多的 <strong>点对点协议 PPP (Point-to-Point Protocol)</strong> 。</p><h5 id="ppp-协议的特点">3.2.1 PPP 协议的特点</h5><ol type="1"><li><p>应满足需求：</p><ul><li>简单</li><li>封装成帧</li><li>透明性</li><li>多种网络层协议兼容</li><li>多种类型链路，如串行或并行，同步或异步，低速或高速</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul></li><li><p>PPP 协议的组成</p><ol type="1"><li>一个将 IP 数据报封装到串行链路的方法。</li><li>一个用来建立、配置和测试数据链路连接的 <strong>链路控制协议 LCP (Link Control Protocol)</strong>。</li><li>一套<strong>网络控制协议 NCP (Network Control Protocol)</strong>，其中每一个协议支持不同网络层协议。</li></ol></li></ol><h5 id="ppp-协议的帧格式">3.2.2 PPP 协议的帧格式</h5><h6 id="各字段意义">1. 各字段意义</h6><p>​ 首部第一字段和尾部第二字段为标志字段 F 。</p><p>​ 首部第二、三字段无具体含义，未定义。</p><p>​ 首部第四字段是 <span class="math inline">\(2\)</span> 字节的协议字段。协议字段为 <span class="math inline">\(0x0021\)</span> 时，PPP 帧的信息字段就是 IP 数据报；协议字段为 <span class="math inline">\(0xC021\)</span>，则信息字段是 PPP 链路控制协议 LCP 的数据；而 <span class="math inline">\(0x8021\)</span> 表示这是网络层的控制数据。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261532003.png" alt="image-20231026153257957" /><figcaption aria-hidden="true">image-20231026153257957</figcaption></figure><h6 id="字节填充">2. 字节填充</h6><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261534633.png" alt="image-20231026153411583" /><figcaption aria-hidden="true">image-20231026153411583</figcaption></figure><h6 id="零比特填充">3. <strong>零比特填充</strong></h6><p>​ 发送端每遇见 <span class="math inline">\(5\)</span> 个连续的 <span class="math inline">\(1\)</span> ，则插入一个 <span class="math inline">\(0\)</span>；接收端采取相反操作。</p><h5 id="ppp-协议的工作状态">3.2.3 PPP 协议的工作状态</h5><p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261610078.png" alt="image-20231026161026019" /></p><h4 id="使用广播信道的数据链路层">3.3 使用广播信道的数据链路层</h4><h5 id="局域网的数据链路层">3.3.1 局域网的数据链路层</h5><p>​ 局域网最主要特点：<strong>网络为一个单位所有，且地理范围和站点数目均有限</strong>。</p><p>​ 局域网优点：</p><p>​ (1) 可广播，一个站点可以很方便访问全网，主机可共享连接在局域网上的各种硬件和资源。</p><p>​ (2) 便于系统的扩展和演变，各设备位置可灵活调整或改变。</p><p>​ (3) 提高系统的可靠性 (reliability)、可用性 (availability) 和生存性 (survivability)。</p><p>​ 局域网可按网络拓扑进行分类，分为<strong>星形网</strong>（核心设备<strong>集线器</strong>）、<strong>环形网</strong>、<strong>总线网</strong>几类，其中总线网以传统以太网最为著名。经过几十年发展，以太网已经在局域网市场中占据绝对优势，以太网几乎成为局域网同义词。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310270907254.png" alt="image-20231027090759182" /><figcaption aria-hidden="true">image-20231027090759182</figcaption></figure><p>​ 从 <span class="math inline">\(10\ Mbit/s\)</span> 到 <span class="math inline">\(10\ Gbit/s\)</span> 的局域网均可用双绞线。双绞线已成为局域网中的主流传输媒体。数据率很高时，往往需要使用光纤作为传输媒体。</p><p>​ 共享信道在技术上有两种方法：</p><p>​ (1) <strong>静态划分信道</strong>，如 2.4 中的频分复用、时分复用、波分复用和码分复用，但是这种划分代价较高，不适合局域网使用。</p><p>​ (2) <strong>动态媒体接入</strong>，又称<strong>多点接入 (multiple access)</strong>，特点是信道并非在用户通信时固定分配给用户。又分为两类：</p><ul><li><strong>随机接入</strong> 所有用户可以随机发送信息，但如果恰巧有两个或多个用户同一时刻发送信息，则会产生<strong>碰撞</strong>（即<strong>冲突</strong>），使得这些用户全部发送失败。因此需要有解决碰撞的协议。</li><li><strong>受控接入</strong> 用户服从控制而不能随机发送信息，代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询 (polling)</strong>，或称<strong>轮询</strong>。</li></ul><p>​ 现在用“<strong>传统以太网</strong>”表示最初流行的 <span class="math inline">\(10 Mbit/s\)</span> 的以太网。</p><h6 id="以太网的两个标准">3.3.1.1 以太网的两个标准</h6><p>​ 世界上第一个局域网产品规约—— DIX Ethernet V2； 第一个 IEEE 的以太网标准 IEEE 802.3，数据率为 <span class="math inline">\(10\ Mbit/s\)</span>。这两个标准区别很小，因此也常把 IEEE 802.3 局域网简称以太网。</p><p>​ 为了使得数据链路层能更好适应多种局域网标准，IEEE 802 委员会将局域网的数据链路层拆成两个子层，即 <strong>逻辑链路控制 LLC (Logical Link Control)</strong> 子层和<strong>媒体接入控制 MAC (Medium Access Control)</strong> 子层。与接入媒体相关内容全部放在 MAC 子层，LLC 子层与传输媒体无关， MAC 子层对 LLC 子层来说是透明的。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310270955977.png" alt="image-20231027095503914" /><figcaption aria-hidden="true">image-20231027095503914</figcaption></figure><p>​ 现代 TCP/IP 体系经常使用的局域网只剩下 DIX Ethernet V2 而非 IEEE 802.3 中的局域网，因此逻辑链路子层 LLC（即 IEEE 802.2 标准）作用已经消失，很多厂商生产适配器上仅有 MAC 协议而没有 LLC 协议。</p><h6 id="适配器的作用">3.3.1.2 适配器的作用</h6><p>​ 适配器实现功能包含物理层和数据链路层两部分。</p><p>​ 计算机与外界局域网的连接是通过<strong>适配器 (adapter)</strong>进行的。适配器本来是主机箱内插入的一块网络接口板，又称<strong>网络接口卡 NIC (Network Interface Card)</strong>，或<strong>网卡</strong>。现在计算机主板上都已经嵌入该种适配器，不再使用单独的网卡，因此采用适配器这个术语更准确些。</p><p>​ 适配器与局域网之间通过电缆或双绞线以串行传输方式进行通信，与主机则通过计算机主板上的 I/O 总线以并行传输进行通信，因此适配器一个重要功能是<strong>进行数据串行传输与并行传输的转换</strong>。</p><p>​ 计算机的硬件地址在适配器的 ROM 中，而软件地址——IP 地址，则在计算机存储器中。</p><h5 id="csmacd-协议">3.3.2 CSMA/CD 协议</h5><p>​ 局域网上的计算机称为“<strong>主机</strong>”、“<strong>工作站</strong>”、“<strong>站点</strong>”或“<strong>站</strong>”。</p><p>​ 为了通信减半，以太网采取以下两种措施：</p><p>​ 第一，采用<strong>无连接</strong>工作方式，不必先建立连接即可发送数据。适配器对发送帧<strong>不进行编号，也不要求对方发回确认</strong>。因此以太网提供的服务随时<strong>尽最大努力的交付，即不可靠的交付</strong>。若目的站收到有差错帧，则丢，是否需要重传则<strong>有高层决定</strong>。</p><p>​ 总线同一时间只允许一台计算机发送数据，否则会产生碰撞。以太网采用最简单的随机接入，但同时使用 CSMA/CD 协议处理碰撞，意思是<strong>载波监听多点接入/碰撞检测 (Carrier Sense Multiple Access with Collision Detection)</strong>。</p><p>​ 第二，以太网发送数据采用<strong>曼彻斯特 (Manchester) 编码</strong>的信号。优点是每个码元都出现一次电压变换，可以很方便地把位同步信号提取出来；缺点则是所占频带宽度比原始基带信号增加一倍。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310271025170.png" alt="image-20231027102549093" /><figcaption aria-hidden="true">image-20231027102549093</figcaption></figure><p>​ 介绍下 CSMA/CD 协议要点。</p><p>​ “<strong>多点接入</strong>”说明其是总线型网络。</p><p>​ “<strong>载波监听</strong>”是用电子技术检测总线上有无其它计算机在发送，其实就是<strong>检测信道</strong>。发送前和发送中都必须进行信道检测。发送前检测是为了获得发送权。发送中检测则是为了及时发现碰撞，即碰撞检测。</p><p>​ “<strong>碰撞检测</strong>“亦即“<strong>边发送边监听</strong>”，几个站同时在总线上发送数据时，总线上信号电压变化幅度会增大，超过一定阈值时，就视为产生了碰撞。一旦出现碰撞，适配器立即停止发送，等待一段随机时间后再次发送。</p><p>​ <strong>电磁波在 <span class="math inline">\(1\ km\)</span> 电缆的传播时延约为 <span class="math inline">\(5\ \mu s\)</span></strong>。把总线上的<strong>单程端到端传播时延记为<span class="math inline">\(\tau\)</span></strong>。最迟经过 <span class="math inline">\(2\tau\)</span> 的时延即可确认是否发生碰撞（信息来回一次最大可能时延）。</p><p>​ 在使用 CSMA/CD 协议时，一个站不可能同时进行发送和接收，因此使用 CSMA/CD 协议的以太网只能进行<strong>半双工通信</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310271605705.png" alt="image-20231027160531598" /><figcaption aria-hidden="true">image-20231027160531598</figcaption></figure><p>​ 每一个站在发送数据后的一小段时间内，存在遭遇碰撞的可能性，这段时间是不确定的，因此称为以太网<strong>发送的不确定性</strong>。端到端往返时间 <span class="math inline">\(2\tau\)</span> 称为<strong>争用期</strong>。经过争用期检验后，才能肯定此次发送是否发生碰撞。</p><p>​ 以太网使用<strong>截断二进制指数退避 (truncated binary exponential backoff)</strong> 算法确定碰撞后重传时机，这里不多赘述。</p><p>​ 以太网规定一个最短帧长 64 字节，即 512 bit，这样发送一个帧的时间也至少需要一个争用期。凡是长度小于 64 字节的帧都是<strong>由于冲突而异常终止的无效帧</strong>。</p><p>​ <strong>强化碰撞</strong>是指发送数据一旦发生碰撞，除立即停止发送数据外，继续发送 32 或 48 比特的<strong>人为干扰信号 (jamming signal)</strong>，以便让所有用户都知道发生碰撞。</p><p>​ 以太网还规定<strong>帧间最小间隔</strong>为 <span class="math inline">\(9.6\ \mu s\)</span>，相当于 96 比特时间，是为了使得刚刚受到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><p>​ 由此，CSMA/CD 协议总结如下：</p><p>​ (1) 准备发送：组装成帧</p><p>​ (2) 检测信道：检测到信道忙，则不停检测，直至信道空闲</p><p>​ (3) 发送：边发送边监听，发送成功则回到 (1) ；发生碰撞则执行指数退避算法，等待一定时间后回到 (2)，若重传 16 次仍失败，则停止重传并向上报错。</p><h5 id="使用集线器的星形拓扑">3.3.3 使用集线器的星形拓扑</h5><p>​ <strong>集线器 (hub)</strong> 是一个<strong>物理层网络设备</strong>，通常与双绞线以太网相配合使用。10BASE-T 双绞线以太网的出现，是局域网发展史上一个非常重要的里程碑，从此以太网的拓扑就从总线型变为更加方便的星形网络，以太网也在局域网中占据统治地位。</p><p>​ 集线器有如下特点：</p><ul><li>使用集线器的以太网逻辑上仍是一个总线网，各站共享逻辑总线，仍使用 CSMA/CD 协议，同一时刻至多允许一个站发送数据。</li><li>一个集线器有多个<strong>接口</strong>，每个接口通过 RJ-45 插头用两对双绞线与一台计算机上的适配器相连。集线器像一个<strong>多接口的转发器</strong>。</li><li>集线器工作在<strong>物理层</strong>，每个接口仅仅简单转发比特，不进行碰撞检测。若发生碰撞，则所有接口都收不到正确的帧。</li><li>采用专门芯片进行自适应串音回波抵消，减少近端串音干扰（发出去的强信号对受到的弱信号的干扰）。</li></ul><p>​ <strong>堆叠式 (stackable)</strong> 集线器由 4~8 个集线器堆叠使用。</p><p>​ IEEE 802.3 标准还可以使用光纤作为传输媒体，主要作用于集线器之间的连接。</p><h5 id="以太网的信道利用率">3.3.4 以太网的信道利用率</h5><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310271654367.png" alt="image-20231027165412308" /> <span class="math display">\[a = \frac{\tau}{T_0}\]</span> ​ <span class="math inline">\(a\)</span> 趋近于 <span class="math inline">\(0\)</span>，表示一发生碰撞即可检测出来，信道资源被浪费时间非常少。因此为了使 <span class="math inline">\(a\)</span> 值尽量小，<strong>以太网的长度受到限制</strong>（<span class="math inline">\(\tau\)</span> 不能太大），同时<strong>以太网的帧长不能太短</strong> （否则 <span class="math inline">\(T_0\)</span> 太小）。</p><p>​ 理想状况下，不发生任何碰撞，则发送一帧时延为 <span class="math inline">\(T_0+\tau\)</span>，而帧本身发送时延为 <span class="math inline">\(T_0\)</span>，因此有极限信道利用率 <span class="math display">\[S_{max}=\frac{T_0}{T_0+\tau}=\frac{1}{1+a}\]</span> ​ 因此只有当 <span class="math inline">\(a\)</span> 远小于 <span class="math inline">\(1\)</span> 时才能得到尽可能高的极限信道利用率。</p><h5 id="以太网的-mac-层">3.3.5 以太网的 MAC 层</h5><h6 id="mac-层的硬件地址">3.3.5.1 MAC 层的硬件地址</h6><p>​ 局域网中，<strong>硬件地址</strong>又称<strong>物理地址</strong>或 <strong>MAC 地址</strong>（因地址用在 MAC 帧中）。</p><p>​ IEEE 802 标准为局域网规定一种 48 位的全球地址，是指局域网上每一台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。</p><p>​ IEEE 的<strong>注册管理机构 RA (Registration Authority)</strong> 是局域网全球地址的法定管理机构，负责分配地址字段 6 字节中的前三字节（即最高 24 位）。世界上生产适配器的厂家都必须向 IEEE 购买由这三个字节构成的号，名称为 <strong>组织唯一标识符 OUI (Organizationally Unique Identifier)</strong>，通常也称<strong>公司标识符 (company_id)</strong>。地址中后三个字节由厂家自行指派，称为<strong>扩展标识符 (extended identifier)</strong>。</p><p>​ IEEE 规定地址字段第一字节的最低位为 I/G 位。I/G 表示 Individual/Group。该位为 0 时，地址字段表示一个<strong>单个站地址</strong>。该位为 1 时表示<strong>组地址</strong>，用来进行<strong>多播</strong>。因此 IEEE 只分配前三字节中的 23 位。</p><p>​ 第一字节低 2 位规定位 G/L 位，该位为 0 时是<strong>全球管理</strong>（保证全球没有相同地址），厂商向 IEEE 购买的 OUI 均属于全球管理。</p><p>​ 适配器有<strong>过滤</strong>功能，适配器收下的帧包括以下三种：</p><p>​ (1) <strong>单播 (unicast) 帧</strong>，收到的帧的 MAC 与本站硬件地址相同。</p><p>​ (2) <strong>广播 (broadcast) 帧</strong>，发送给本局域网所有站点的帧（全 1 地址）。</p><p>​ (3) <strong>多播 (multicast) 帧</strong>，发送给本局域网上一部分站点的帧。</p><p>​ 所有适配器都应能够识别前两种帧，有的适配器可用编程方法识别第三种帧。</p><p>​ 适配器还可设置为一种特殊的工作方式即<strong>混杂方式 (promiscuous mode)</strong>。窃听所有的帧，经常为黑客所使用。</p><h6 id="mac-帧的格式">3.3.5.2 MAC 帧的格式</h6><p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202311021938027.png" alt="image-20231102193850945" /></p><p>​ 数据字段小于 64 字节时，MAC 子层会在其后加入一个填充字段。</p><p>​ MAC 子层向下传到物理层时还要在帧前插入 8 字段，第一字段为 7 个字节的<strong>前同步码 （1 和 0 的交替码）</strong>，使得适配器接受 MAC 帧时迅速调整时钟频率。第二字段为<strong>帧开始定界符</strong>，定义为 <code>10101011</code>，前 6 位作用与前同步码相同，最后两个连续 1 预告信息接收。</p><p>​ 由于曼彻斯特码的使用，以太网不需要着帧结束定界符，由此也不需要插入字节来保证传输透明。</p><h4 id="扩展的以太网">3.4 扩展的以太网</h4><p>​ <strong>扩展的以太网在网络层看来仍然是一个网络</strong>。</p><h5 id="物理层扩展">3.4.1 物理层扩展</h5><p>​ 扩展主机与集线器之间距离一种简单方法是使用光纤和一对光纤调制解调器。</p><p>​ 使用多个集线器，可以构成覆盖范围更大的多级星形结构以太网。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202311021954027.png" alt="image-20231102195453931" /><figcaption aria-hidden="true">image-20231102195453931</figcaption></figure><p>​ 但这种多级结构的集线器以太网也有一些缺点。</p><p>​ (1) 多个系以太网相连把多个碰撞与变成一个，但此时最大吞吐量仍然是一个系的吞吐量 10 Mbits/s。</p><p>​ (2) 若不同系用不同以太网技术（如数据率不同），则无法互连。</p><h5 id="数据链路层扩展">3.4.2 数据链路层扩展</h5><p>​ 最初使用<strong>网桥 (bridge)</strong>，对 MAC 帧的目的地址进行 <strong>转发</strong> 和 <strong>过滤</strong>。</p><p>​ <strong>交换式集线器 (switching hub)</strong> 也称<strong>交换机 (switch)</strong> 或 <strong>第二层交换机 (L2 switch)</strong> 很快淘汰了网桥，这种设备<strong>工作在数据链路层</strong>。</p><h6 id="交换机特点">3.4.2.1 交换机特点</h6><p>​ 实质上是一个<strong>多接口网桥</strong>，通常有十几个或更多接口。具有<strong>并行性</strong>，能同时连通多对主机进行通信，相互通信主机<strong>独占传输媒体，无碰撞地传输数据</strong>。</p><p>​ 交换机的接口还有存储器，能在输出端口繁忙时将到来的帧进行缓存。</p><p>​ 交换机即插即用，内部<strong>帧交换表</strong>是通过<strong>自学习</strong>算法自动逐渐建立。</p><p>​ 许多交换机对收到的帧采用存储转发，但有些交换机用<strong>直通</strong>的交换方式，提高了帧的转发速度，但缺点是少了检查差错步骤。</p><h6 id="交换机的自学习功能">3.4.2.2 交换机的自学习功能</h6><p>​ <del>懒得写，看书吧。</del></p><p>​ 为防止环状网络拓扑导致的资源浪费，IEEE 的 802.1D 标准制定了<strong>生成树协议 STP (Spanning Tree Protocol)</strong>，不改变物理上的网络拓扑，但从逻辑上切断某些链路，消除环状结构的存在。</p><p>​ 随着站点数目增多和交换机成本的下降，传统总线以太网迅速为星形以太网所取代，但由于<strong>仍采用以太网的帧结构</strong>，故仍称以太网。</p><h5 id="虚拟局域网">3.4.3 虚拟局域网</h5><p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202311022019173.png" alt="image-20231102201909117" /></p><p>​ 利用交换机能方便地实现<strong>虚拟局域网 VLAN (Virtual LAN) </strong>，虚拟局域网限制接收广播信息的计算机数，使得网络不会因传播过多的广播信息（即“<strong>广播风暴</strong>”）而引起性能恶化。</p><p>​ 1988 年 IEEE 批准了 802.3ac 标准，该标准定义了以太网帧格式的扩展，以支持虚拟局域网。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202311022022437.png" alt="image-20231102202204367" /><figcaption aria-hidden="true">image-20231102202204367</figcaption></figure><p>​ 以太网最大帧长从原来的 1518 字节变为 1522 字节。</p><h4 id="高速以太网">3.5 高速以太网</h4><h5 id="base-t-以太网">3.5.1 100BASE-T 以太网</h5><p>​ 在双绞线上传输 100 Mbit/s 基带信号的星形拓扑以太网，但仍使用 IEEE 802.3 的 CSMA/CD 协议，又称<strong>快速以太网 (Fast Ethernet)</strong>。现在快速以太网正式标准为 IEEE 802.3u。</p><p>​ IEEE 802.3u 标准并未包括对同轴电缆支持，由细缆以太网升级到快速以太网必须重新布线，因此现在 10/100 Mbit/s 的以太网均无屏蔽双绞线布线。</p><p><del>更快的以太网就不写了，看书看吐了。。。。。</del>#</p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程作业 code</title>
      <link href="/2023/10/22/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
      <url>/2023/10/22/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>本页面将<strong>计组</strong>和<strong>数据结构与算法</strong>两门课的编程作业代码于 ddl /发布三周后公布，仅供参考。如有错误或可改进之处，敬请联系 Lg，直接 qq 联系或 <code>1370120724@qq.com</code> 均可。</p><table><thead><tr class="header"><th>计组</th><th>writer</th></tr></thead><tbody><tr class="odd"><td><a href="https://box.nju.edu.cn/f/1929f5477a814e68aa56/?dl=1">COA_hw1</a></td><td>Lg</td></tr><tr class="even"><td><a href="https://box.nju.edu.cn/f/1950f62a50374ff9b2d0/?dl=1">COA_hw2</a></td><td>Lg</td></tr><tr class="odd"><td><a href="https://box.nju.edu.cn/f/010a76d95c1545d29262/?dl=1">COA_hw3</a></td><td>zz</td></tr><tr class="even"><td><a href="https://box.nju.edu.cn/f/6b70dfe587634842bea5/?dl=1">COA_hw4</a></td><td>Lg</td></tr><tr class="odd"><td><a href="https://box.nju.edu.cn/f/7932ebf9e0ec48dca483/?dl=1">COA_hw5</a></td><td>Lg</td></tr><tr class="even"><td><a href="https://box.nju.edu.cn/f/8fef2c4fbe6c4c2a8df2/?dl=1">COA_hw6</a></td><td>Lg</td></tr><tr class="odd"><td><a href="https://box.nju.edu.cn/f/5a95c20bc470455787de/?dl=1">COA_hw7（含 pdf 附件）</a></td><td>Lg</td></tr></tbody></table><table><thead><tr class="header"><th>数据结构与算法</th><th>writer</th></tr></thead><tbody><tr class="odd"><td><a href="https://box.nju.edu.cn/f/0aa0a872c19a4b4a8af9/?dl=1">DS_hw1</a></td><td>Lg</td></tr><tr class="even"><td><a href="https://box.nju.edu.cn/f/eaca1c8b47874f1caf43/?dl=1">DS_hw2</a></td><td>Lg</td></tr><tr class="odd"><td><a href="https://box.nju.edu.cn/f/2e65d5aa45e84fd5815f/?dl=1">DS_hw3</a></td><td>Lg</td></tr><tr class="even"><td><a href="https://box.nju.edu.cn/f/31ecfa006910450d881d/?dl=1">DS_hw4</a></td><td>Lg</td></tr></tbody></table><blockquote><p>​ 也许你感觉自己的努力总是徒劳无功，但不必怀疑，你每天都离顶点更进一步。今天的你离顶点还遥遥无期。但你通过今天的努力，积蓄了明天勇攀高峰的力量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谢希仁计算机网络02-物理层</title>
      <link href="/2023/10/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02-%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2023/10/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02-%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h4 id="物理层的基本概念">2.1 物理层的基本概念</h4><p>​ 用于物理层的协议也称为<strong>规程(procedure)</strong>。</p><p>​ 可将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：</p><p>​ (1) <strong>机械特性</strong>：指明接口所用接线器的形状尺寸、引脚数目排列等。</p><p>​ (2) <strong>电气特性</strong>：指明接口电缆各条线电压范围。</p><p>​ (3) <strong>功能特性</strong>：指明某条线某电平的电压的意义。</p><p>​ (4) <strong>过程特性</strong>：指明不同功能的各种可能事件的出现顺序。</p><p>​ 数据在计算机内部采用<strong>并行传输</strong>，但在通信线路上一般采用<strong>串行传输</strong>，因此物理层还要完成传输方式的转换。</p><h4 id="数据通信的基础知识">2.2 数据通信的基础知识</h4><h5 id="数据通信系统的模型">2.2.1 数据通信系统的模型</h5><p>​ 数据通信系统可划分为三大部分：<strong>源系统</strong>（或<strong>发送端、发送方</strong>）、<strong>传输系统</strong>（或<strong>传输网络</strong>）和<strong>目的系统</strong>（或<strong>接收端、接收方</strong>）</p><p>​ 源系统一般包含两部分：</p><ul><li><strong>源点(source)</strong>：产生要传输的数据。又称<strong>源站</strong>或<strong>信源</strong>。</li><li><strong>发送器</strong>：将源点产生数据进行编码，之后才能进行传输。如<strong>调制器</strong>。</li></ul><p>​ 目的系统一般包含两部分：</p><ul><li><strong>接收器</strong>：接受传输信号，并转化为目标设备能处理的信息。如<strong>解调器</strong>。</li><li><strong>终点(destination)</strong>：接受比特流</li></ul><p>​ 现在很多计算机使用内置的调制解调器，用户在计算机外看不见调制解调器。</p><p>​</p><p>通信的目的是传送<strong>消息(message)</strong>。<strong>数据(data)</strong>是运送消息的实体。<strong>信号(signal)</strong>是数据的电气或电磁表现。信号可分为两大类：</p><p>​ (1) <strong>模拟信号</strong>，或<strong>连续信号</strong>：如用户家中的调制解调器到电话端局之间的用户线上的信号。</p><p>​ (2) <strong>数字信号</strong>，或<strong>离散信号</strong>：如用户家中计算机到调制解调器之间，或电话网中继线上传送的信号。使用时间域（或称时域）的波形表示数字信号时，取不同离散数值的基本波形称为<strong>码元</strong>。</p><h5 id="有关信道channel的几个基本概念">2.2.2 有关<strong>信道(channel)</strong>的几个基本概念</h5><p>​ 从通信双方的交互方式来看，有三种基本通信方式：</p><p>​ (1) <strong>单向通信</strong>：也称<strong>单工通信</strong>。如无线电广播，或有线电广播及电视广播。</p><p>​ (2) <strong>双向交替通信</strong>：也称<strong>半双工通信</strong>，双方均可发送，但不可同时发送。</p><p>​ (3) <strong>双向同时通信</strong>：也称<strong>全双工通信</strong>。</p><p>​ 单向通信仅需一条信道，而双向交替通信和双向同时通信均需两条。全双工通信效率最高。</p><p>​</p><p>​ 来自信源的信号称为<strong>基带信号</strong>，往往含有较多低频成分甚至直流成分，而许多信道并不能传输这种低频或直流分量，因此必须对基带信号进行<strong>调制(coding)</strong>。使用<strong>载波(carrier)</strong>进行调制，把基带信号频率搬移到较高频段，并转化为模拟信号，便可更好在模拟信道中传输。载波调制后信号称<strong>带通信号</strong>，调制称为<strong>载波调制</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211254285.jpg" alt="0d28fb91042f8ce7aa2ce716249dd2d" /><figcaption aria-hidden="true">0d28fb91042f8ce7aa2ce716249dd2d</figcaption></figure><h5 id="信道极限容量">2.2.3 信道极限容量</h5><p>​ 限制码元在信道上传输速率的因素：</p><p>​ (1) 信道可通过频率范围</p><p>​ 信道能通过频率范围有限，高频分量往往无法通过信道。高频分量传输时受衰减，接收端受到信号便失去了码元间的清晰界限，此现象称<strong>码间串扰</strong>。</p><p>​ 奈氏准则告诉我们：<strong>任何信道中，码元传输速率有上限，超过该上限，则会出现严重码间串扰问题，使接收端对码元的判决称为不可能。</strong></p><p>​ (2) 信噪比</p><p>​ 信噪比是信号的平均功率与噪声的平均功率比值，记作 <strong>S/N</strong>，度量单位为<strong>分贝</strong>。</p><p>​ 香农公式指出，信道的<strong>极限传输速率 C </strong>为 <span class="math display">\[C = W\log_2(1+S/N)\ \ \ (bit/s)\]</span> ​ 其中 <span class="math inline">\(W\)</span> 为信道带宽， <span class="math inline">\(S\)</span> 和 <span class="math inline">\(N\)</span> 分别表示信号与噪声的平均功率。</p><p>​ 香农公式表面，信噪比越大，极限传输速率越高。对于频带宽度已确定的信道，信噪比也无法继续提高，码元传输速率也达上界，欲提升传输速率，可通过编码的方法<strong>让每一个码元携带更多比特信息量</strong>。</p><h4 id="物理层下面的传输媒体">2.3 物理层下面的传输媒体</h4><p>​ <strong>传输媒体</strong>分为<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>两大类。</p><h5 id="导引型传输媒体">2.3.1 导引型传输媒体</h5><h6 id="双绞线">1. <strong>双绞线</strong></h6><p>​ 两根互相绝缘铜导线绞合，以减少对相邻导线的电磁干扰。使用最多地方为电话系统。</p><p>​ 模拟运输和数字运输均可使用双绞线，通信距离为几到十几公里。</p><p>​ 为提升抗电磁干扰能力，可在外面加上一层用金属丝编织成的屏蔽层，称为<strong>屏蔽双绞线</strong>，简称 <strong>STP(Shielded Twisted Pair)</strong>。<strong>无屏蔽双绞线</strong>简称 <strong>UTP(Unshielded Twisted Pair)</strong> 。</p><p>​ “商用建筑物电信布线标准”—— <strong>EIA/TIA-568-A</strong> ——规定了 5 个种类的 UTP 标准，最常用的是 5 类线。</p><p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211404631.png" alt="image-20231021140449514" /></p><h6 id="同轴电缆">2. <strong>同轴电缆</strong></h6><p>​ 由内导体铜质芯线、绝缘层、网状编织外导体屏蔽层以及保护塑料外层组成。具有良好抗干扰特性，被广泛用于传输较高速率的数据。</p><p>​ 目前主要用在有线电视网的居民小区中。</p><h6 id="光缆">3. <strong>光缆</strong></h6><p>​ <strong>光纤</strong>在发送端有光源，可采用发光二极管或半导体激光器。接收端用光电二极管做成光检测器，可还原出电脉冲。原理是利用光的全反射。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211409293.png" alt="image-20231021140938197" /><figcaption aria-hidden="true">image-20231021140938197</figcaption></figure><p>​ 现代工艺可制造出超低损耗光纤，即做到传输数公里而没什么衰耗。这是光纤通信飞速发展的最关键因素。</p><p>​ 可以存在多条不同角度入射光线在同一光纤中传输，称为<strong>多模光纤</strong>。但光脉冲传输时会展宽，因此多模光纤<strong>仅适用于近距离传输</strong>。</p><p>​ 光纤优点：</p><p>​ (1) 通信容量大。</p><p>​ (2) 传输损耗小，中继距离长，对远距离传输经济。</p><p>​ (3) 抗雷和电磁干扰性能好，在大电流脉冲干扰下尤为重要。</p><p>​ (4) 无串音干扰，保密性好。</p><p>​ (5) 体积小，重量轻。</p><h6 id="架空明线">4. <strong>架空明线</strong></h6><p>​ 在电线杆上架设互相绝缘的明线（铜线或铁线）。许多国家都已经停止铺设，目前我国一些农村与边远地区仍使用。</p><h5 id="非导引型传输媒体">2.3.2 非导引型传输媒体</h5><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211418400.png" alt="image-20231021141801277" /><figcaption aria-hidden="true">image-20231021141801277</figcaption></figure><p>​ 无线传输可使用频段很广，紫外线和更高的波段目前还不能用于通信。</p><p>​ 短波通信（即高频通信）主要靠电离层反射，但电离层不稳定产生的衰落现象和反射产生的多径效应，使得短波通信质量较差。因此短波无线电台一般采用低速传输。</p><h6 id="微波通信">2.3.2.1 微波通信</h6><p>​ <strong>无线电微波通信</strong>在数据通信中具有重要地位，频率范围为 <span class="math inline">\(300\ MHz\sim 300\ GHz\)</span> （波长 <span class="math inline">\(1\ m\sim1\ mm\)</span>），主要用 <span class="math inline">\(2\sim40\ GHz\)</span> 范围。微波在空间主要是直线传播，会穿过电离层进入宇宙空间，因此不像短波可以反射到地面很远地方。微波通信主要分为<strong>地面微波接力通信</strong>和<strong>卫星通信</strong>两种方式。</p><p>​ 由于地球是个曲面，微波直线传输距离受到限制，因此需要在两个通讯点间建立若干中继站，进行<strong>接力</strong>。微波接力通信可传输电话、电报、图像、数据等信息，特点是：</p><p>​ (1) 频率高，频段范围宽，通信信道容量大。</p><p>​ (2) 受到干扰小，质量高。</p><p>​ (3) 建设投资少，见效快，易于跨越山区、江河。</p><p>​ 但也有如下缺点：</p><p>​ (1) 相邻站必须直视，不可有障碍物。有时一个天线发出信号也会分成几条略有差别路径，造成失真。</p><p>​ (2) 有时会受到恶劣天气影响。</p><p>​ (3) 隐蔽性和保密性差</p><p>​ (4) 大量中继站使用和维护需要耗费大量人力物力。</p><h6 id="卫星通信">2.3.2.2 卫星通信</h6><p>​ 利用位于约 <span class="math inline">\(3\)</span> 万 <span class="math inline">\(6\)</span> 千公里高空的同步卫星作为中继器。主要优缺点与地面微波通信差不多。但<strong>具有较大传播时延</strong>。费用较高。</p><p>​ 由于在同步卫星轨道架设卫星数量有限，因此在卫星上使用不同频段来进行通信，保证大的通信容量资源。</p><p>​ 红外通信、激光通信也用于非导引型媒体。可用于近距离笔记本电脑相互传送数据。</p><h4 id="信道复用技术">2.4 信道复用技术</h4><h5 id="频分复用时分复用与统计时分复用">2.4.1 频分复用、时分复用与统计时分复用</h5><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211436769.png" alt="image-20231021143631664" /><figcaption aria-hidden="true">image-20231021143631664</figcaption></figure><p>​ <strong>频分复用 FDM (Frequency Division Multiplexing)</strong> 的所有用户<strong>在同样时间占用不同带宽资源</strong>。</p><p>​ <strong>时分复用 TDM (Time Division Multiplexing)</strong> 则是将时间划分为一段段等长的 TDM 帧，所有用户<strong>在不同时间占用同样的频带宽度</strong>。</p><p>​ <strong>复用器(multiplexer)</strong> 和<strong>分用器(demultiplexer)</strong> 成对使用。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211439720.png" alt="image-20231021143935600" /><figcaption aria-hidden="true">image-20231021143935600</figcaption></figure><p>​ <strong>统计时分复用 STDM (Statistic TDM)</strong> 是一种改进的时分复用，能明显提高信道利用率。使用<strong>集中器(concentrator)</strong> 进行复用。集中器也称<strong>智能复用器</strong>。</p><p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211444418.png" alt="image-20231021144401327" /></p><h5 id="波分复用">2.4.2 波分复用</h5><p>​ <strong>波分复用 WDM (Wavelength Division Multiplexing)</strong> 就是<strong>光的频分复用</strong>。一根光纤复用几十路或更多路光载波信号，使用<strong>密集波分复用 DWDM (Dense WDM)</strong> 这一名词。</p><p>​ <strong>掺铒光纤放大器 EDFA (Erbium Doped Fiber Amplifier)</strong> 不需要进行光电转化直接对光信号进行放大。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211448096.png" alt="image-20231021144822976" /><figcaption aria-hidden="true">image-20231021144822976</figcaption></figure><h5 id="码分复用">2.4.3 码分复用</h5><p>​ <strong>码分复用 CDM (Code Division Multiplexing)</strong> 是另一种共享信道方法，也称<strong>码分多址 CDMA (Code Division Multiple Access)</strong> 。每个用户可以在同一时间用同样频带进行通信。<strong>各用户间不会造成干扰，具有很强抗干扰能力，频谱类似于白噪声，不易被敌人发现</strong>。</p><p>​ CDMA 中，每一个比特时间再划分为 <span class="math inline">\(m\)</span> 个短的间隔，称为<strong>码片 (chip)</strong>。通常 <span class="math inline">\(m\)</span> 取 <span class="math inline">\(64\)</span> 或 <span class="math inline">\(128\)</span>。一个站如果发送比特 <span class="math inline">\(1\)</span> ，则表示发送该码片，发送 <span class="math inline">\(0\)</span> 则表示该码片的反码。如此每发送 <span class="math inline">\(b\)</span> 个比特，实际信息则<strong>扩频</strong>为 <span class="math inline">\(mb\)</span> 个比特。该种扩频方式属于<strong>直接序列扩频 DDSS (Direct Sequence Spread Spectrum)</strong>。另一种扩频方式为 <strong>调频扩频 FHSS (Frequency Hopping Spread Spectrum)</strong>。</p><p>​ CDMA 要求每一个站分配的码片向量各不相同且<strong>相互正交</strong>。实际系统采用<strong>伪随机码序列</strong>。</p><p>​ 任何一个码片与自身内积为 <span class="math inline">\(1\)</span>，与其反码内积为 <span class="math inline">\(-1\)</span> 。</p><p>​ 结合<strong>全球定位系统 GPS</strong>，所有的站可以同步发送码片序列。若 X 站接受 S 站发送的数据，则需预先知道 S 站特有的码片序列，然后将接受到的信号与 S 站的码片序列作内积，即可解码。</p><h4 id="数字传输系统">2.5 数字传输系统</h4><p>​ 早期数字传输系统缺点：</p><p>​ (1) <strong>速率标准不统一。</strong></p><p>​ (2) <strong>不是同步传输。</strong></p><p>​ 为解决上述问题，美国于 1988 年首先推出一个数字传输标准，叫<strong>同步光纤网 SONET (Synchronous Optical Network)</strong>。</p><p>​ ITU-T 以 SONET 为基础，制定国际标准<strong>同步数字系列 SDH (Synchronous Digital Hierarchy)</strong>。 SDH/SONET 标准的制定及各国的统一运用，实现了数字传输体制上的世界性标准。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211642004.png" alt="image-20231021164224886" /><figcaption aria-hidden="true">image-20231021164224886</figcaption></figure><h4 id="宽带接入技术">2.6 宽带接入技术</h4><h5 id="adsl-技术">2.6.1 ADSL 技术</h5><p>​ <strong>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line)</strong> 技术是用数字技术<strong>对现有的模拟电话用户线进行改造</strong>，使它能够承载宽带数字业务。 下行带宽（从 ISP 到用户）远远大于上行带宽（从用户到 ISP ）。传输距离取决于数据率与线径。</p><p>​ ADSL 在用户线两端各安装一个 ADSL 调制解调器，我国目前采用的实现方法是 <strong>离散多音调 DMT (Discrete Multi-Tone) 调制技术</strong>。 ADSL 并不能保证固定的数据率。 其最大优点是不需要重新布线。</p><p>​ 基于 ADSL 的接入网三大组成部分：<strong>数字用户线接入复用器 DSLAM (DSL Access Multiplexer)</strong>，用户线和用户家中一些设施。 ADSL 调制解调器必须成对使用，把端局和用户家中的 ADSL 调制解调器分别记为 ATU-C（C 代表<strong>端局 (Central Office)</strong>）和 ATU-R （R代表<strong>远端 (Remote)</strong>）。用户电话通过<strong>分离器 (Splitter)</strong> 与 ATU-R 连在一起。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310220934571.png" alt="image-20231022093405458" /><figcaption aria-hidden="true">image-20231022093405458</figcaption></figure><p>​ ADSL 技术也在发展，第二代 ADSL 改进的地方主要为：</p><p>​ (1) 通过提高调制效率得到更高的数据率。</p><p>​ (2) 采用<strong>无缝速率自适应技术 SRA (Seamless Rate Adaptation)</strong>，自适应调整速率。</p><p>​ (3) 改善线路质量测评和故障定位功能。</p><p>​ ADSL 技术并不适用于企业，原因在于企业通常需要使用上行信道发送大量数据给用户。为满足企业需要，ADSL 技术有几种变型，记为 xDSL。</p><h5 id="光纤同轴混合网">2.6.2 光纤同轴混合网</h5><p>​ <strong>光纤同轴混合网 （HFC 网，HFC 是 Hybrid Fiber Coax 缩写）</strong>是基于有线电视网基础上开发的一种居民宽带接入网，主要特点如下：</p><p>​ 把原有有线电视网同轴电缆主干部分该换为光纤，从头端连接到<strong>光纤节点 (fiber node)</strong>。光纤节点光信号转化为电信号，通过同轴电缆传输到每个家庭。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310220944400.png" alt="image-20231022094401301" /><figcaption aria-hidden="true">image-20231022094401301</figcaption></figure><p>​ 模拟电视机要能够接受数字电视信号，需要一个<strong>机顶盒 (set-top box)</strong>连接在同轴电缆与电视机之间。若欲接入互联网，还需增加 HFC 网所使用的调制解调器，称为 <strong>电缆调制解调器 (cable modem)</strong>。</p><h5 id="fttx-技术">2.6.3 FTTx 技术</h5><p>​ <strong>光纤到户 FTTH (Fiber To The Home)</strong> 两个问题：</p><p>​ (1) 价格高昂。</p><p>​ (2) 一般家庭用户没有这样高的数据率需求。</p><p>​ 这种情况下，出现了多种宽带光纤接入方式，称为 FTTx ，x 表示不同的光纤接入地点。</p><p>​ 为有效利用光纤资源，光纤干线和用户之间，需要铺设一段中间转换装置即 <strong>光配线网 ODN (Optical Distribution Network)</strong>，使得数十个家庭用户可以共享一根光纤。 五元的逛配线网称为<strong>无源光网络 PON (Passive Optical Network)</strong>。</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310221001923.png" alt="image-20231022100126778" /><figcaption aria-hidden="true">image-20231022100126778</figcaption></figure><p>​ 光纤干线与<strong>光线路终端 OLT (Optical Line Terminal)</strong> 相连，OLT 把收到的下行数据发往无源的 1:N <strong>光分路器 (splitter)</strong> ，然后以广播方式向所有用户端的<strong>光网络单元 ONU (Optical Network Unit)</strong> 发送。</p><p>​ 光配线网采用波分复用，上行和下行分别使用不同的波长。</p><p>​ 目前已实现了多种不同的 FTTx， 如 <strong>光纤到路边 FTTC（C 表示 Curb）</strong>、<strong>光纤到小区 FTTZ（Z 表示 Zone）</strong>、<strong>光纤到大楼 FTTB（B 表示 Building）</strong>、<strong>光纤到楼层 FTTF（F 表示 Floor）</strong>、<strong>光纤到办公室 FTTO （O 表示 Office）</strong>、<strong>光纤到桌面 FTTD（D 表示 Desk）</strong>等等。</p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组01-计算机系统概述</title>
      <link href="/2023/09/08/%E8%AE%A1%E7%BB%8401-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/09/08/%E8%AE%A1%E7%BB%8401-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="概念">1.1 概念</h4><ul><li>何为计算机：计算机是指“<strong>通用电子计算机</strong>”<ul><li>通用：不是专用设备</li><li>电子：采用电子元器件</li><li>数字：信息采用数字化形式表示</li></ul></li><li>计算机系统：硬件和软件</li><li>何为计算机“<strong>组织</strong>”：操作单元及其互联连接<ul><li>对编程人员不可见</li><li>包括：控制信号，存储技术等</li></ul></li><li>何为计算机”<strong>结构</strong>“：直接影响逻辑程序执行的属性<ul><li>对编程人员可见</li><li>包括：指令集，表示数据类型的位数等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202309081604546.png" /></p><ul><li><strong>指令集体系结构</strong>： <strong>ISA</strong> ，有时称为<strong>指令系统</strong>。 ISA 是一种规约，规定如何使用硬件。<ul><li>可执行指令的集合，包含指令格式、操作种类及操作数的规定</li><li>指令可以接受的操作数类型</li><li>操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、长度和用途</li><li>操作数所能存放的<strong>存储空间的大小和编址方式</strong></li><li>操作数在存储空间存放时按照<strong>大端还是小端方式存放</strong></li><li>指令获取操作数的方式，即<strong>寻址方式</strong></li><li>指令执行过程的控制方式，包括<strong>程序计数器（PC）、条件码定义</strong>等</li></ul></li><li>ISA 与组成之间的关系：计算机组成必须能够<strong>实现 ISA 规定的功能</strong>，如提供 GPR 、标志、运算电路等，<strong>一种 ISA 可以有不同的计算机组成</strong>。</li></ul><h4 id="计算机简史">1.2 计算机简史</h4><h5 id="第一代真空管">1.2.1 第一代：真空管</h5><ul><li>ENIAC ：第一台<strong>通用</strong>计算机，十进制，手动编程</li><li>ABC ：第一台<strong>电子</strong>计算机，不可编程</li><li>EDVAC ：冯·诺伊曼架构（普林斯顿架构）</li><li>三个基本原则：<ul><li>二进制</li><li>存储程序</li><li>5个组成部分<ul><li>主存储器：地址和存储内容</li><li>算术逻辑单元 / 处理单元：执行信息处理</li><li>程序控制单元 / 控制单元：指挥信息处理</li><li>输入设备</li><li>输出设备</li></ul></li></ul></li></ul><h5 id="第二代晶体管">1.2.2 第二代：晶体管</h5><ul><li>体积更小、更便宜、发热更少</li><li>使用高级语言编程，并为计算机提供了系统软件</li></ul><h5 id="第三代中小规模集成电路">1.2.3 第三代：中小规模集成电路</h5><h5 id="第四代超大规模集成电路">1.2.4 第四代：（超）大规模集成电路</h5><ul><li>思想：<ul><li>将整个电路安装在很小的硅片上，而不是用分立元件搭成的等价电路</li><li>晶体管可以通过金属化相互连接，形成电路</li></ul></li><li><ul><li></li></ul></li></ul><h4 id="计算机发展">1.3 计算机发展</h4><h5 id="摩尔定律">1.3.1 摩尔定律</h5><ul><li>价格不变时，单芯片上所能包含的晶体管数量每年翻一番 (1965-1969) / 1970年起减慢为每18个月翻一番</li><li>影响：<ul><li>更小尺寸带来更多<strong>灵活性</strong>与<strong>可能性</strong></li><li>成本下降</li><li><strong>减小电能损耗与冷却要求</strong></li><li><strong>芯片间连接更少</strong>，更可靠</li></ul></li></ul><h4 id="计算机性能">1.4 计算机性能</h4><h5 id="cpu-性能">1.4.1 CPU 性能</h5><ul><li>计算机设计主要目标：提升 CPU 性能</li><li>系统时钟<ul><li>时钟频率： 1s 内执行基本操作的次数</li><li>始终周期：执行每次最基本操作的时间</li></ul></li><li>指令执行： <span class="math inline">\(CPI_i\)</span> 表示第 <span class="math inline">\(i\)</span> 种指令需要周期数， <span class="math inline">\(I_i\)</span> 表示第 <span class="math inline">\(i\)</span> 类指令条数，则有</li></ul><p><span class="math display">\[CPI=\frac{\sum_{i=1}^n(CPI_i \times I_i)}{I_c},I_c=\sum_{i=1}^n I_i\]</span></p><p>​ 执行一个程序的处理时间表示为 <span class="math display">\[T=I_c\times CPI \times t\]</span></p><ul><li>每秒百万条指令（ MIPS ）：</li></ul><p><span class="math display">\[MIPS = \frac{I_c}{T\times 10^6}=\frac{f}{CPI\times 10^6}\]</span></p><ul><li>每秒百万条浮点操作（ MFLOPS ）：</li></ul><p><span class="math display">\[MFLOPS=\frac{N_{floating-point\ op}}{T\times 10^6}\]</span></p><h5 id="性能设计的基本原则">1.4.2 性能设计的基本原则</h5><ul><li><strong>大概率事件优先原则</strong>：对于大概率事件，赋予优先的处理权与资源使用权。</li></ul><p><span class="math display">\[系统加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}\]</span></p><ul><li><strong>Amdahl</strong> 定律：<ul><li>部件系统加速比受限于其在系统中所占重要性比例。</li><li>性能增加的递减规则：改进越，系统获得效果越小</li></ul></li></ul><p><span class="math display">\[系统加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}=\frac{1}{(1-局部占比)+\frac{局部占比}{提升的性能}}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 计组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络01</title>
      <link href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="第1章-概述">第1章 概述</h4><h4 id="计算机网络在信息时代的作用">1.1 计算机网络在信息时代的作用</h4><p>​ 21世纪<strong>数字化</strong>、<strong>网络化</strong>、<strong>信息化</strong>，形成<strong>以网络为核心的信息时代</strong>。</p><p>​ 三大类网络：电信网络、有线电视网络、计算机网络</p><p>​ 互联网两个基本特点：<strong>连通性</strong>和<strong>共享</strong></p><ul><li>连通性：不论多远，都可便捷地交换各种信息</li><li>资源共享：信息共享、软件共享、硬件共享</li></ul><h4 id="互联网概述">1.2 互联网概述</h4><p>​ <strong>计算机网络</strong>由若干<strong>节点( node )</strong>和连接这些节点的<strong>链路( link )</strong>组成。</p><ul><li>节点：计算机、集线器、交换机、路由器等</li></ul><p>​ 网络把许多计算机连接在一起，<strong>互连网</strong>把许多网络通过路由器连在一起。与网络相连接的计算机称为<strong>主机</strong>。</p><p>​ 互联网发展的三个阶段：</p><ol type="1"><li>由 ARPANET 向互连网发展。 20 世纪 70 年代， APRA 开始研究多种网络互连的技术，称为互联网的雏形。 1983 年 TCP/IP 成为 ARPANET 上的标准协议，互联网诞生。 1990 年 ARPANET 关闭。</li></ol><ul><li><strong>internet （互连网）</strong>：指多个网络连接而成的网络</li><li><strong>Internet （互联网）</strong>：专有名词</li></ul><ol start="2" type="1"><li>第二阶段特点是建成了<strong>三级结构的互联网</strong>。分为<strong>主干网</strong>、<strong>地区网</strong>和<strong>校园网（企业网）</strong>。</li><li>第三阶段特点是形成了<strong>多层次 ISP 结构的互联网</strong>。 ISP 译为<strong>互联网服务提供商</strong>。</li></ol><p>​</p><p>​ 计算机网络的分类：</p><ul><li><strong>LAN</strong> （<strong>局域网</strong>）</li><li>特点<ul><li>作用范围小</li><li>多用户访问</li><li>高速度</li><li>错误率可控</li></ul></li><li>设备<ul><li><strong>Hub</strong> （集线器）：多端口中继器</li><li><strong>Bridge</strong> （网桥）：</li><li><strong>Switch</strong> （交换机）：</li><li><strong>Router</strong> （路由器）：分组交换，转发收到的分组</li></ul></li><li><strong>WAN</strong> （<strong>广域网</strong>）</li><li>特点<ul><li>作用范围大</li><li>通过链路传输</li><li>速度相对较低</li><li>错误率较难控制</li></ul></li><li>设备<ul><li><strong>Router</strong> （路由器）：</li><li><strong>Modem CSU/DSU TA/NT1</strong></li></ul></li></ul><p><strong>Boring！</strong></p><h4 id="互联网的组成">1.3 互联网的组成</h4><ul><li><p>互联网的组成：</p><ul><li><p>（1）<strong>边缘部分</strong>：由所有连接在互联网上的主机组成，是<strong>用户直接使用</strong>的部分。主机又称为<strong>端系统（end system）</strong></p></li><li><p>（2）<strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。这部分是<strong>为边缘部分提供服务的</strong>。</p></li></ul></li><li><p>端系统间通信方式：客户-服务器模式 and 对等连接方式</p><ul><li><strong>客户(client)</strong>-<strong>服务器(sever)</strong>模式（C/S模式）<ul><li>客户是服务请求方，服务器是服务提供方</li></ul></li><li>对等连接方式（P2P）<ul><li>并不区分服务请求方与服务提供方</li></ul></li></ul></li><li><p><strong>电路交换</strong>主要特点：</p><ul><li><strong>建立连接</strong> → <strong>通话</strong> → <strong>释放资源</strong></li><li>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</li><li>传输效率较低</li></ul></li><li><p><strong>分组交换</strong>主要特点：</p><ul><li>采取<strong>存储转发</strong>技术</li><li>发送的整块数据成为<strong>报文</strong>(message)</li><li>发送之前，先将报文划分成一个个更小的等长数据段，加上必要控制信息组成的<strong>首部</strong>(header)或<strong>包头</strong>，构成一个<strong>分组</strong>(packet)或<strong>包</strong>。</li><li>主机进行信息处理，路由器用来转发分组，即进行分组交换。</li></ul></li></ul><h4 id="计算机网络的类别">1.5 计算机网络的类别</h4><ul><li>按照网络的作用范围分类：<ul><li><strong>广域网 WAN </strong>：</li><li><strong>域域网 MAN </strong>：作用范围一般是一个城市。可以为一个或几个单位所有，也可以是一种公用设施，用来将多个局域网进行互连。</li><li><strong>局域网 LAN </strong>：</li><li><strong>个人区域网 PAN</strong>：把属于个人的设备用无线技术连接起来</li></ul></li><li>按网络使用分类：<ul><li><strong>公用网</strong>(public network)</li><li><strong>专用网</strong>(private network)</li></ul></li><li><strong>用来把用户接入到互联网的网络</strong>：<ul><li><strong>接入网 AN</strong>：又称<strong>本地接入网</strong>或<strong>居民接入网</strong>。</li></ul></li></ul><h4 id="计算机网络的性能">1.6 计算机网络的性能</h4><h5 id="性能指标">1.6.1 性能指标</h5><ul><li><strong>速率</strong>：数据传送速率，也成为<strong>数据率</strong>或<strong>比特率</strong>。提到网络速率，往往指<strong>额定速率</strong>，而非运行速率。单位 bps 。</li><li><strong>带宽</strong>：<ul><li><strong>信号具有的频带宽度</strong>，单位是<strong>赫兹</strong>，表示<strong>某信道允许通过的信号频带范围</strong>。</li><li>网络中某通道传输数据的效率，即<strong>最高数据率</strong>，单位是 bps 。</li></ul></li><li><strong>吞吐量</strong>：表示单位时间内通过某个网络的实际数据量</li><li><strong>时延</strong>：数据从网络一端传送到另一端的时间，组成：<ul><li><strong>发送时延</strong>：主机或路由器发送数据帧所需时间</li><li><strong>处理时延</strong>：</li><li><strong>排队时延</strong>：数据帧进入路由器后需排队等待处理，等待的时间成为排队时延</li><li><strong>传播时延</strong>：信道中传播的时间</li></ul></li></ul><p><span class="math display">\[传播时延=\frac{信道长度(m)}{电磁波在信道上传播速率(m/s)}\]</span></p><ul><li><strong>时延带宽积</strong>： 传播时延与带宽乘积</li><li><strong>往返时间 RTT </strong>：数据在信道中往返一次所需时间</li><li><strong>利用率</strong>：</li></ul><p><span class="math display">\[D=\frac{D_0}{1-U}\]</span></p><h4 id="计算机网络体系结构">1.7 计算机网络体系结构</h4><h5 id="osi-七层协议">1.7.1 OSI 七层协议</h5><ul><li><strong>物理层</strong>：管理通信设备和网络媒体之间的互联互通，<strong>规范</strong>链接的电气和功能<strong>规格</strong>。</li><li><strong>数据链路层</strong>：<strong>通过物理链接提供数据传输链路</strong>。</li><li><strong>网络层</strong>： 在两终端之间进行<strong>路径选择</strong>。</li><li><strong>传输层</strong>：负责网络中<strong>端到端的网络通信</strong>，为虚拟电路的建立、维护、终止，传输故障检测及恢复，以及信息流的控制提供机制。</li><li><strong>会话层</strong>：<strong>创建</strong>、<strong>管理</strong>和<strong>维护</strong>会话。同步表示层实体间的会话并<strong>管理其间的数据交换</strong>。提供高效的<strong>数据传输</strong>、<strong>服务类别</strong>以及会话、演示及应用层的<strong>异常报告功能</strong>。</li><li><strong>演示层</strong>：保证不同系统的信息交换，涉及<strong>数据编码</strong>、<strong>格式转换</strong>、<strong>数据加密</strong>。将多种数据格式转化成通信中采用的标准表示形式。</li><li><strong>应用层</strong>：OSI 协议最高层，离用户最近，<strong>为用户应用程序提供网络服务</strong>，不为其它层提供服务。</li></ul><h5 id="五层协议的体系结构">1.7.2 五层协议的体系结构</h5><ul><li><strong>应用层</strong>：通过进程间的交互来完成特定网络应用，交互数据称为报文。不同网络应用需要有不同的应用层协议。</li><li><strong>运输层</strong>：主要使用两种协议： <strong>TCP、UDP</strong> 。</li><li><strong>网络层</strong>：把运输层产生的报文段或数据封装成<strong>包</strong>或<strong>分组</strong>进行传送。由于网络层使用 IP 协议，因此分组也叫 <strong>IP 数据报</strong>。</li><li><strong>数据链路层</strong>：将网络层交下来的 <strong>IP 数据报</strong>组装成帧，每一帧包括数据和必要的控制信息。</li><li><strong>物理层</strong>：上传数据单位为比特。</li></ul><h5 id="tcpip-四层协议">1.7.3 TCP/IP 四层协议</h5><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202309111635872.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相信未来</title>
      <link href="/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/"/>
      <url>/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<p><em>作者：食指</em></p><p>当蜘蛛网无情地查封了我的炉台，</p><p>当灰烬的余烟叹息着贫困的悲哀，</p><p>我依然固执地铺平失望的灰烬，</p><p>用美丽的雪花写下：相信未来。</p><p>​</p><p>当我的紫葡萄化为深秋的露水，</p><p>当我的鲜花依偎在别人的情怀，</p><p>我依然固执地用凝霜的枯藤，</p><p>在凄凉的大地上写下：相信未来。</p><p>​</p><p>我要用手指那涌向天边的排浪，</p><p>我要用手掌 那托起太阳的大海，</p><p>摇曳着曙光那支温暖漂亮的笔杆，</p><p>用孩子的笔体写下：相信未来。</p><p>​</p><p>我之所以坚定地相信未来，</p><p>是我相信未来人们的眼睛——</p><p>她有拨开历史风尘的睫毛，</p><p>她有看透岁月篇章的瞳孔。</p><p>​</p><p>不管人们对于我们腐烂的皮肉，</p><p>那些迷途的惆怅，失败的苦痛，</p><p>是寄予感动的热泪，深切的同情，</p><p>还是给以轻蔑的微笑，辛辣的嘲讽。</p><p>​</p><p>我坚信人们对于我们的脊骨，</p><p>那无数次地探索、迷途、失败和成功，</p><p>一定会给予热情、客观、公正的评定，</p><p>是的，我焦急地等待着他们的评定。</p><p>​</p><p>朋友，坚定地相信未来吧，</p><p>相信不屈不挠的努力，</p><p>相信战胜死亡的年轻，</p><p><strong>相信未来，热爱生命。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 877 (Div. 2)</title>
      <link href="/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/"/>
      <url>/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1838">Codeforces Round 877 (Div. 2)</a></p><h5 id="a.-blackboard-list">A. Blackboard List</h5><p><strong>题意：</strong></p><p>​ 给定包含两个数字的初始，然后进行 <span class="math inline">\(n-2\)</span> 次操作，每次操作从序列中取出两个数字（不能取同一个），将其差之绝对值加入序列，最终得到一长度为 <span class="math inline">\(n\)</span> 的序列。</p><p>​ 现给定最终序列（乱序）， 求最初始数字之一。</p><p><strong>题解：</strong></p><p>​ 由于新加入数字必为非负数，因此序列中的负数必定是初始数字。</p><p>​ 若全为非负数，由于 <span class="math inline">\(|a-b|\leq|a|\)</span> 且 <span class="math inline">\(|a-b|\leq |b|\)</span> ，因此最大数字必为初始数字。</p><h5 id="b.-minimize-permutation-subarrays">B. Minimize Permutation Subarrays</h5><p><strong>题意：</strong></p><p>​ 给定一 <span class="math inline">\(n\)</span> 的排列。交换两数字的位置，使得交换后序列中，能够成排列的连续子序列数目最少。</p><p><strong>题解：</strong></p><p>​ <span class="math inline">\(1\)</span> 与 <span class="math inline">\(2\)</span> 之间夹 <span class="math inline">\(n\)</span> ，这样能够使得数目恒为 <span class="math inline">\(1\)</span> ，是为最少。讨论即可</p><h5 id="c.-no-prime-differences">C. No Prime Differences</h5><p><strong>题意：</strong></p><p>​ 将 <span class="math inline">\(n*m\)</span> 之内的正整数排成一个 <span class="math inline">\(n*m\)</span> 矩阵，使得矩阵中任意两相邻元素差值的绝对值不为素数。</p><p><strong>题解：</strong></p><p>​ 先考虑 <span class="math inline">\(m\geq 5\)</span> 时，将 <span class="math inline">\(\{0, 1*n, 2*n, 3*n, ... (m-1)*n\}\)</span> 排成一列。以下是一种合适的构造方法。</p><p>​ 设 <span class="math inline">\(p=\lfloor \frac{m-1}{2}\rfloor\)</span> 考虑两个序列 <span class="math display">\[\{0, 1*n, 2*n, ...p*n \} \\\{(p+1)*n, (p+2)*n, ... (m-1)*n\}\]</span> ​ 然后将两序列合成（下面序列的元素依次插入上面序列的空隙）。</p><p>​ 若 <span class="math inline">\(m=4\)</span> ，则可构造为 <span class="math inline">\(\{1*n, 3*n, 0, 2*n\}\)</span></p><p>​ 设该序列为 <span class="math inline">\(A\)</span> ，则最终矩阵可构造为 <span class="math inline">\(p_{i, j}=i+A_j\)</span></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">4</span>) &#123;</span><br><span class="line">        add[<span class="number">0</span>] = n;</span><br><span class="line">        add[<span class="number">1</span>] = <span class="number">3</span> * n;</span><br><span class="line">        add[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        add[<span class="number">3</span>] = <span class="number">2</span> * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) cout &lt;&lt; i + add[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d.-bracket-walk">D. Bracket Walk</h5><p><strong>题意：</strong></p><p>​ 一括号序列，从最左侧出发可以随意向左右移动（不超边界），最终停在最右侧。途经符号构成一括号序列，若该括号序列合法，则称原序列 walkable 。</p><p>​ 现给定一括号序列 <span class="math inline">\(s\)</span> ， <span class="math inline">\(q\)</span> 次单点修改，要求求出每次单点修改后，序列是否 walkable 。</p><p><strong>题解：</strong></p><p>​ walkable 的必要条件首先是长度 <span class="math inline">\(n\)</span> 为偶数。</p><p>​ 其次构造一序列 <span class="math inline">\(A\)</span> ，包含所有的 <span class="math inline">\(i\)</span> ，使得</p><ul><li><p><span class="math inline">\(s_i=&#39;)&#39;\)</span> 且 <span class="math inline">\(i\)</span> 为奇数</p></li><li><p><span class="math inline">\(s_i=&#39;(&#39;\)</span> 且 <span class="math inline">\(i\)</span> 为偶数</p><ol type="1"><li>若 <span class="math inline">\(A\)</span> 为空，则显然圆括号序列为 <span class="math inline">\(()\)</span> 重复若干次，必定 walkable。</li><li>若 <span class="math inline">\(A\)</span> 非空，其中最小数字为奇数，则意味着序列开头为 <span class="math inline">\(()()()...())\)</span> ，必定非法</li><li>若 <span class="math inline">\(A\)</span> 非空，其中最大数字为偶数，则意味着序列末尾为 <span class="math inline">\((()()()\)</span> ，必定非法</li><li>剩余情况， <span class="math inline">\(A\)</span> 中最小数字 <span class="math inline">\(m\)</span> 为偶数， 最大数字 <span class="math inline">\(M\)</span> 为奇数，则 <span class="math inline">\(m, M\)</span> 之间符号数为偶数，其中左右括号奇偶性相同。则在 <span class="math inline">\(m-1,m\)</span> 这两个位置产生足够多的 <span class="math inline">\(((....\)</span> 来消除右侧的 <span class="math inline">\()\)</span>，然后在<span class="math inline">\(M,M+1\)</span> 两个位置产生对应数量的 <span class="math inline">\())\)</span> 补齐即可。合法。</li></ol></li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;str](<span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="built_in">return</span> ((str[p - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) ^ (p &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) s.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2 9</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; pos;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(pos)) s.<span class="built_in">erase</span>(pos);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">insert</span>(pos);</span><br><span class="line">        str[pos - <span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span> + <span class="string">&#x27;)&#x27;</span> - str[pos - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*s.<span class="built_in">begin</span>() &amp; <span class="number">1</span>) || !(*s.<span class="built_in">rbegin</span>() &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="e.-count-supersequences">E. Count Supersequences</h5><p><strong>题意：</strong></p><p>​ 求满足以下条件的 <span class="math inline">\(b\)</span> 序列个数：</p><ul><li><span class="math inline">\(b\)</span> 序列含 <span class="math inline">\(m\)</span> 个正整数，所有数字均在 <span class="math inline">\([1,k]\)</span> 内</li><li><span class="math inline">\(b\)</span> 序列删去若干个数，顺序不变，可以得到 <span class="math inline">\(a\)</span> 序列</li></ul><p><strong>题解：</strong></p><p>​ 考虑 <span class="math inline">\(dp\)</span></p><p>​ <span class="math inline">\(f[i][j]\)</span> 表示含 <span class="math inline">\(i\)</span> 个正整数删去后可得到长度为 <span class="math inline">\(j\)</span> 的 <span class="math inline">\(a\)</span> 序列前缀的序列数，则有如下转移方程： <span class="math display">\[f[i][j]=\begin{cases}f[i-1][j-1]+(k-1)*f[i-1][j],\ j&lt;n \\f[i-1][j-1]+k*f[i-1][j], \ j=n\end{cases}\]</span> ​ 发现该转移方程与 <span class="math inline">\(a\)</span> 无关。</p><p>​ 因此将 <span class="math inline">\(a\)</span> 序列设为 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(1\)</span> ，然后作差法。</p><p>​ 最终答案为： <span class="math display">\[k^m-\sum_{i=0}^{n-1}\binom{m}{i}(k-1)^{m-i}\]</span> <strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">auto</span> quick_pow = [&amp;mod](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">            a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">quick_pow</span>(k, m);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans -= <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>(k - <span class="number">1</span>, m - i) % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        ans += mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * (m - (i+<span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>((i+<span class="number">1</span>), mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/2023/07/04/README/"/>
      <url>/2023/07/04/README/</url>
      
        <content type="html"><![CDATA[<p>​ 本站采用 hexo 架构，部署在 github pages 上，采用 github 作为图床。建议在能够流畅访问 github 的网络环境下浏览。</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307042122433.png" /></p><p>​ 看见这幅美丽的画了吗？看见了说明你能看见这幅画 (bushi)。</p><p>​ 关于左边的这个抽象的双 tags 旋转动画，我也在 diss 它，有时间再把它 ban 掉了。</p><p>维修计划：</p><ul><li>缩进调整</li><li>关闭 tags 动画</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 150 (Div. 2)</title>
      <link href="/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/"/>
      <url>/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1841">Educational Codeforces Round 150 (Rated for Div. 2)</a></p><h5 id="a.-game-with-board">A. Game with Board</h5><p><strong>题意：</strong></p><p>​ 给定初始序列为 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(1\)</span> ，两人轮流行动，每次可以选择序列中若干个相同的数，剔除，并将他们的和加入序列。第一位无法行动的一方获胜。假设二人都绝对聪明，试问先手是否必胜。</p><p><strong>题解：</strong></p><p>​ 分类讨论一下：</p><ul><li>$2n  $，有限轮模拟易得后手必胜。</li><li><span class="math inline">\(n\geq5\)</span> ，则先手取 <span class="math inline">\(n-2\)</span> 个 <span class="math inline">\(1\)</span>， 后手只能取 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> ， 之后序列变为 <span class="math inline">\(\{n-2, 2\}\)</span> ，故先手必胜。</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c.-ranom-numbers">C. Ranom Numbers</h5><p><strong>题意：</strong></p><p>​ A, B, C, D, E 分别代表 <span class="math inline">\(1, 10, 100, 1000, 10000\)</span> 。给定一由大写字母 ABCDE 组成的串，对于某一字符，若字符串后方有严格大于它的字符，则符号为负，否则为正。字符串权值为所有字母乘上符号的权值之和。</p><p>​ 现可以修改至多一字符，求可能的最大权值。</p><p><strong>题解：</strong></p><p>​ 据说 DP 和贪心均可，这里思路是 DP 。</p><p>​ 为了方便起见，先将字符串反转，规则也对应修正。</p><p>​ 然后设计状态： <span class="math inline">\(F[i][j][0/1]\)</span> 代表到第 <span class="math inline">\(i\)</span> 位，目前前缀最大值为 <span class="math inline">\(j\)</span> ，且已经/未修改的最大权值。 <span class="math inline">\(i\)</span> 这一位用滚动数组滚掉，然后枚举状态的转移即可。</p><p>​ 复杂度 <span class="math inline">\(O(nMK)\)</span> ，其中 <span class="math inline">\(M=5, K=2\)</span> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> f[<span class="number">2</span>][<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[<span class="number">0</span>][i][<span class="number">0</span>] = f[<span class="number">0</span>][i][<span class="number">1</span>] = -inf;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">        p ^= <span class="number">1</span>;</span><br><span class="line">        q ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[p][i][<span class="number">0</span>] = f[p][i][<span class="number">1</span>] = -inf;</span><br><span class="line">        <span class="type">int</span> x = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;   <span class="comment">//i-1位前缀最大</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) &#123;   <span class="comment">//</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">5</span>; y++) &#123;</span><br><span class="line">                    <span class="type">int</span> nt = t + (y != x);</span><br><span class="line">                    <span class="type">int</span> nj = <span class="built_in">max</span>(y, j);</span><br><span class="line">                    <span class="keyword">if</span> (nt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        f[p][nj][nt] = <span class="built_in">max</span>(f[p][nj][nt], f[q][j][t] + (y == nj ? digit[y] : -digit[y]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">0</span>]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d.-pairs-of-segments">D. Pairs of Segments</h5><p><strong>题意：</strong></p><p>​ 给定 <span class="math inline">\(n\)</span> 条线段，用区间表示 <span class="math inline">\([l,r]\)</span> 。若 <span class="math inline">\(n\)</span> 为偶数，且可以将 <span class="math inline">\(n\)</span> 条线段分为 <span class="math inline">\(\frac{n}{2}\)</span> 对， 每一对线段相交， 不成一对的线段相交，则称其 <strong>beautiful</strong> 。现问至少删去多少线段，使得剩下的线段可以 <strong>beautiful</strong> 。</p><p><strong>题解：</strong></p><p>​ <span class="math inline">\(n\)</span> 比较小。一开始以为是 <span class="math inline">\(dp\)</span> 但怎么都消除不了后效性。实际解法是——直接暴力。</p><p>​ 首先考虑两对线段，共四条。不成对线段不相交的等价条件可以表示为： 成对线段取并集，所得两条线段不相交。</p><p>​ 因此可以直接求出 <span class="math inline">\(C_n^2\)</span> 对线段中，相交对的并集。然后找出尽量多的并线段，使其互不相交即可。互不相交可以天然保证每条线段至多用了一次。求不相交线段数目，这里用了动态开点线段树。</p><p>​ 复杂度 <span class="math inline">\(O(n^2logn)\)</span> 。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> lc[N &lt;&lt; <span class="number">4</span>], rc[N &lt;&lt; <span class="number">4</span>], dat[N &lt;&lt; <span class="number">4</span>], cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">    dat[p] = <span class="built_in">max</span>(dat[p], val);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid) <span class="built_in">update</span>(lc[p], l, mid, k, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || u &gt; v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(lc[p], l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(rc[p], mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">Line</span>(n);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; Uline;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; Line[i].first &gt;&gt; Line[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a.first, b.first) &lt;= <span class="built_in">min</span>(a.second, b.second);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> uni = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="built_in">min</span>(a.first, b.first), <span class="built_in">max</span>(a.second, b.second));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(Line[i], Line[j])) <span class="keyword">continue</span>;</span><br><span class="line">            Uline.<span class="built_in">pb</span>(<span class="built_in">uni</span>(Line[i], Line[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(Uline.<span class="built_in">begin</span>(), Uline.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Uline) &#123;</span><br><span class="line">        <span class="type">int</span> rem = <span class="built_in">query</span>(rt, <span class="number">-1</span>, inf, <span class="number">-1</span>, line.first - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">update</span>(rt, <span class="number">-1</span>, inf, line.second, rem + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rem + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - (ans &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h5 id="e.-fill-the-matrix">E. Fill the Matrix</h5><p><strong>题意：</strong></p><p>​ 给定一 <span class="math inline">\(n*n\)</span> 的矩阵，其中第 <span class="math inline">\(i\)</span> 列的第 <span class="math inline">\(1-a_i\)</span> 行为黑格， <span class="math inline">\(a_i-n\)</span> 行为白格，仅白格可以填数。当一个格填数 <span class="math inline">\(x\)</span> 且其正右侧格填数 <span class="math inline">\(x+1\)</span> 时，贡献一 beauty 。填入 <span class="math inline">\(1-m\)</span> 共 <span class="math inline">\(m\)</span> 个数，求最大 beauty 值。</p><p><strong>题解：</strong></p><p>​ 看起来似乎比其他几道好想很多。上层所有线段都是下层线段的子集，因此从最底层线段开始枚举，填数，分裂即可。</p><p>​ 这里还是用的线段树。注意细节。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dat[N &lt;&lt; <span class="number">2</span>], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>) (dat[p] = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    dat[p] = <span class="built_in">min</span>(dat[p &lt;&lt; <span class="number">1</span>], dat[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = N;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>, l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">pos</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] = n - a[i];</span><br><span class="line">        pos[a[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos[i] 值为i的位置集合(补上界n+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pos[i].<span class="built_in">pb</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(pos[i].<span class="built_in">begin</span>(), pos[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r, pre_min;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre_min) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">pre_min</span>(pre_min) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node X) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l &lt; X.r - X.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ask(l, r) ask(1, 1, n, l, r)</span></span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">1</span>, n, <span class="number">0</span>));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p.l == p.r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> min_num = <span class="built_in">Ask</span>(p.l, p.r);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>) &gt; m) &#123;</span><br><span class="line">            ans += (m / (p.r - p.l + <span class="number">1</span>) * (p.r - p.l)) + <span class="built_in">max</span>(<span class="number">0ll</span>, m % (p.r - p.l + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m -= <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>);</span><br><span class="line">            ans += <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l);</span><br><span class="line">            <span class="type">int</span> L = std::<span class="built_in">lower_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.l) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> R = std::<span class="built_in">upper_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.r) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> pre_l = p.l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt; R; pre_l = pos[min_num][i] + <span class="number">1</span>, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre_l &lt; pos[min_num][i]) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, pos[min_num][i] - <span class="number">1</span>, min_num));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre_l &lt;= p.r) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, p.r, min_num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 879 (Div. 2)</title>
      <link href="/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/"/>
      <url>/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1834">Codeforces Round 879 (Div. 2)</a></p><p>难度适中，但菜鸡依旧。</p><h6 id="b.-maximum-strength">B. Maximum Strength</h6><p><strong>题意：</strong></p><p>​ <span class="math inline">\([l,r]\)</span> 之间选两个数，使得十进制表示下各个位数的差值绝对值之和最大，位数不同则较小数补前导 <span class="math inline">\(0\)</span> 对齐。</p><p><strong>题解：</strong></p><p>​ 设 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 位数分别为 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> ，取的数字为 <span class="math inline">\(x&lt;y\)</span> ，分情况讨论。</p><ul><li>若 <span class="math inline">\(n&lt;m\)</span> ，则最优情况为 <span class="math inline">\(x\)</span> 取 <span class="math inline">\(m-1\)</span> 个 <span class="math inline">\(9\)</span> , <span class="math inline">\(y\)</span> 保留 <span class="math inline">\(r\)</span> 的最高位，剩余位为 <span class="math inline">\(0\)</span></li><li>若 <span class="math inline">\(n=m\)</span> ，则除去相同前缀，然后 <span class="math inline">\(y\)</span> 保留最高位，剩余位为 <span class="math inline">\(0\)</span> ， <span class="math inline">\(x\)</span> 保留最高位，剩余位为 <span class="math inline">\(9\)</span> 即可。</li></ul><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    n = s1.length();</span><br><span class="line">    m = s2.length();</span><br><span class="line">    if (n &lt; m) &#123;</span><br><span class="line">        cout &lt;&lt; (s2[0] - &#x27;0&#x27;) + (m - 1) * 9 &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (s1[i] == s2[i]) continue;</span><br><span class="line">            cout &lt;&lt; s2[i] - s1[i] + (n - i - 1) * 9 &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="c.-game-with-reversing">C. Game with Reversing</h6><p><strong>题意：</strong></p><p>​ 给定两等长串 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> ， Alice 和 Bob 轮流操作。Alice 每次可以替换一个字符，Bob 每次可以翻转一个串， 当两串相同时，停止操作。Alice 希望操作次数尽量少， Bob 希望操作次数尽量多， 求两个人都采取最优策略的情况下，实际游戏操作次数。</p><p><strong>题解：</strong></p><p>​ 解释起来比较啰嗦，这里简述。</p><p>​ 实际上 Bob 每轮操作都是相同的，因此可以假设 Bob 只翻转一个字符串 <span class="math inline">\(T\)</span> 。</p><p>​ 对 Alice 来说，则可以有两种选择，将 <span class="math inline">\(S\)</span> 变为 <span class="math inline">\(T\)</span> 或 <span class="math inline">\(rev(T)\)</span> 。二者最小步数都容易 <span class="math inline">\(O(n)\)</span> 求出。 最后根据实际的奇偶性补齐 Bob 的操作数即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    int ans1 = 0, ans2 = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (s1[i] != s2[i]) ++ans1;</span><br><span class="line">        if (s1[i] != s2[n - i - 1]) ++ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ans1 &amp; 1) ans1 = ans1 * 2 - 1;</span><br><span class="line">    else ans1 = ans1 * 2;</span><br><span class="line">    if (ans2 &amp; 1) ans2 = ans2 * 2;</span><br><span class="line">    else if (ans2 == 0) ans2 = 2;</span><br><span class="line">    else ans2 = ans2 * 2 - 1;</span><br><span class="line">    cout &lt;&lt; min(ans1, ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="d.-survey-in-class">D. Survey in Class</h6><p><strong>题意：</strong></p><p>​ <span class="math inline">\(n\)</span> 位学生，<span class="math inline">\(m\)</span> 个知识点。第 <span class="math inline">\(i\)</span> 个学生学习了 <span class="math inline">\([l_i, r_i]\)</span> 个知识点。</p><p>​ 上课老师提问，每个问题至多提问一次。初始同学分数均为 <span class="math inline">\(0\)</span> ，答对加一分，答错减一分，分数可为负。求最大分差。</p><p><strong>题解：</strong></p><p>​ 对于线段 $ [l_1, r_1] $ 和线段 $ [l_2,r_2] $ ，设 $ r_1&lt;r_2 $ ，则分三种情况讨论：</p><ul><li>$ r_1&lt;l_2 $ ，则最大差值可以分别来源于两线段整段，即 $ max(r_1-l_1+1, r_2-l_2+1) $ ；</li><li><span class="math inline">\(l_1\leq l_2\leq r_1 \leq r_2\)</span>，则最大差值来源于二者分别对交集取补，即 $ max(r_2-r_1, l_2-l_1) $ ；</li><li>$ l_2l_1 r_1 r_2 $ ，包含关系，最大差值来源于长线段对短线段取补，即 $ (r_2-l_2+1)-(r_1-l_1+1) $ 。</li></ul><p>​ 将每条线段按右端点排序，枚举线段 <span class="math inline">\([l_2,r_2]\)</span> ， 目标是找出对应的 <span class="math inline">\([l_1, r_1]\)</span> ， 三种情况分别需要求：</p><ul><li>右端点小于 <span class="math inline">\(l_2\)</span> 的直线中，<span class="math inline">\(r-l+1\)</span> 的最大值</li><li>相交直线中， <span class="math inline">\(r\)</span> 的最小值以及 <span class="math inline">\(l\)</span> 的最小值</li><li>左端点大于等于 <span class="math inline">\(l_2\)</span> 的直线中， <span class="math inline">\(r-l+1\)</span> 的最小值</li></ul><p>​ 四个值四棵动态开点线段树维护即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x7fffffff</span><br><span class="line">int cnt = 0;</span><br><span class="line">const int N = 4e5 + 5;</span><br><span class="line">int dat[N &lt;&lt; 5], lc[N &lt;&lt; 5], rc[N &lt;&lt; 5];</span><br><span class="line"></span><br><span class="line">void update(int &amp;p, int l, int r, int k, int val) &#123;</span><br><span class="line">    if (!p) p = ++cnt, dat[p] = inf;</span><br><span class="line">    if (l == r) return (void) (dat[p] = min(dat[p], val));</span><br><span class="line">    int mid = l + r &gt;&gt; 1;</span><br><span class="line">    if (k &lt;= mid) update(lc[p], l, mid, k, val);</span><br><span class="line">    else update(rc[p], mid + 1, r, k, val);</span><br><span class="line">    dat[p] = inf;</span><br><span class="line">    if (lc[p]) dat[p] = min(dat[p], dat[lc[p]]);</span><br><span class="line">    if (rc[p]) dat[p] = min(dat[p], dat[rc[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int query(int p, int l, int r, int u, int v) &#123;</span><br><span class="line">    if (!p) return inf;</span><br><span class="line">    if (u &lt;= l &amp;&amp; r &lt;= v) return dat[p];</span><br><span class="line">    int mid = l + r &gt;&gt; 1, res = inf;</span><br><span class="line">    if (u &lt;= mid) res = min(res, query(lc[p], l, mid, u, v));</span><br><span class="line">    if (v &gt; mid) res = min(res, query(rc[p], mid + 1, r, u, v));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123;</span><br><span class="line">    return A.second == B.second ? A.first &lt; B.first : A.second &lt; B.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">#define mp(x, y) make_pair(x, y)</span><br><span class="line">    int t1 = 0, t2 = 0, t3 = 0, t4 = 0;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;pair&lt;int, int&gt; &gt; Stu(n);</span><br><span class="line">    for (int i = 0, l, r; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        Stu[i] = mp(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Stu.begin(), Stu.end(), cmp);</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (auto stu: Stu) &#123;</span><br><span class="line">        int l = stu.first, r = stu.second;</span><br><span class="line">        int rem;</span><br><span class="line">        rem = -query(t1, 0, m, 0, l - 1);</span><br><span class="line">        if (rem != -inf) ans = max(ans, max(rem &lt;&lt; 1, (r - l + 1) &lt;&lt; 1));</span><br><span class="line">        update(t1, 0, m, r, l - r - 1);</span><br><span class="line"></span><br><span class="line">        rem = query(t2, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (r - rem) &lt;&lt; 1);</span><br><span class="line">        update(t2, 0, m, r, r);</span><br><span class="line"></span><br><span class="line">        rem = query(t3, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (l - rem) &lt;&lt; 1);</span><br><span class="line">        update(t3, 0, m, r, l);</span><br><span class="line"></span><br><span class="line">        rem = query(t4, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, ((r - l + 1) - rem) &lt;&lt; 1);</span><br><span class="line">        update(t4, 0, m, l, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="e.-mex-of-lcm">E. MEX of LCM</h5><p><strong>题意：</strong></p><p>​ 题如其名。给定 <span class="math inline">\(n\)</span> 个数，则对应的有 <span class="math inline">\(C_n^2\)</span> 个连续子序列。求所有子序列数值 <span class="math inline">\(lcm\)</span> 的 <span class="math inline">\(Mex\)</span> 。</p><p><strong>题解：</strong></p><p>​ 同样是利用好值域。 对于区间 <span class="math inline">\([l,r]\)</span> ，固定住右端点 <span class="math inline">\(r\)</span> ，则至多还剩下 <span class="math inline">\(r\)</span> 个左端点，对应 <span class="math inline">\(r\)</span> 个区间。这 <span class="math inline">\(r\)</span> 个区间有多少 <span class="math inline">\(lcm\)</span> 值？从 <span class="math inline">\(l=r\)</span> 开始，每次向左添加一个数， <span class="math inline">\(lcm\)</span> 要么不变， 要么至少翻一倍，因此 <span class="math inline">\(lcm\)</span> 值的数目是 <span class="math inline">\(log\)</span> 级别的。因此整个序列所有 <span class="math inline">\(lcm\)</span> 值的数目不超过 <span class="math inline">\(nlogn\)</span> ，迭代求出然后求 <span class="math inline">\(Mex\)</span> 即可。复杂度 <span class="math inline">\(O(nlogn)\)</span></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / __gcd(x, y) * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1ll</span> * n * n + <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; num[i];</span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; s;<span class="comment">//以r-1为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; rem; <span class="comment">//以r为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; ans;<span class="comment">//所有lcm序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: num) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">lcm</span>(y, x);</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= inf) rem.<span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        rem.<span class="built_in">insert</span>(x);</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: rem) s.<span class="built_in">insert</span>(y);</span><br><span class="line">        rem.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) ans.<span class="built_in">insert</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = <span class="number">1</span>;</span><br><span class="line">    ans.<span class="built_in">insert</span>(inf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != now) &#123;</span><br><span class="line">            cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数理思维</title>
      <link href="/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/"/>
      <url>/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h6 id="一决不能把任何我没有明确地认识其为真的东西当作真的加以接受也就是说小心避免仓促的判断和偏见只把那些十分清楚明白地呈现在我的心智之前使我根本无法怀疑的东西放进我的判断之中">一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。</h6><p>​ 在数理逻辑论证推理中，务必做到毫无破绽。防范”千里之堤，溃于蚁穴“的局面。更直观地来说，论证必须有从底层起始的依据。</p><p>​ 在日常生活中，这一条也同样适用。我们处在一个信息爆炸的时代，很多时候困扰我们的并不是信息资源的匮乏，而是信息茧房的拘束以及信息泛滥的迷茫。保持理性，对信息加以筛选，过滤掉无依据的信息。</p><h6 id="二把我所考察的每一个难题都尽可能地分成细小的部分直到可以而且适于加以圆满解决的程度为止">二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。</h6><p>​ 比较典型的分而治之思想。当整体带有规律性时，局部往往也具有与整体相同或相似的规律性，通过不断地划分，最终将问题转化为一个个显然或已解决的子问题。从个别、特殊到一般的方法。</p><h6 id="三按照次序引导我的思想以便以最简单最容易认识的对象开始一点一点上升到对复杂的对象的认识即便是那些彼此间没有自然的先后次序的对象我也要给它们设定一个次序">三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。</h6><p>​ 从易到难，从简单到复杂地进行分析、解决，而不至于迷乱。</p><h6 id="四把一切情形尽量完全地列举出来尽量普遍地加以审视使我确信毫无遗漏">四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”</h6><p>​ 如其所言，思维缜密，考虑周全，确保推理覆盖到所有情况。</p><p>摘自： 笛卡尔 《方法论》</p><p>​</p><p>​</p><p><code>人生没有目的，只有过程，所谓的终极目的是虚无的。——人的情况和树相同。它愈想开向高处和明亮处，它的根愈要向下，向泥土，向黑暗处，向深处，向恶——千万不要忘记。我们飞翔得越高，我们在那些不能飞翔的人眼中的形象越是渺小。</code></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT 指北</title>
      <link href="/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/"/>
      <url>/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fc094c49dec8c68d31e2249786969ee8a0aab851b7f7cd02c836b2855c6f650a">578d5c17fdb0be81f91dae08d76a8b9d310fe713a3967a08677820d492351d4d024aaf5584a3de2eee6cfd36b7caa22d9740053c8a96ed22d2d6dfd2f9a00dec5e9fd27efec9fb0cbc17fcc35e01819114fd1aee1a0491f5c66478faa8a06e2e2a38275f37cf04671781ce95522f0f8bb4350b77e28aeb703a214e03248d7a4f2da825156a4478c4e8e9a73d62a084ae268f2c4638a9aee4aad943d0e2dbe941bec775478b9d482e0483065df9c2945af30768e649b2e65e85f4405f63ba8a6945c66d5c0f4698fd95c52438b972821e3101245d86aee6010c2bad096ab9eee7dc820ab4dd29d09b79858e5b0a2f22a9e00cfcee7d907eca6d5211fb02764c742c47d52ed84e556b86cb77027e513a2220abd8926c2247ce863275df31a0c992a04ec7691e36662f98a91279a32b9cd9bc4412b39f1f98c51707679af494bb111bc4ff22634689f5dffda99f3db844e280230a22f60e80a0cd473cb7f59da80d80911506ccf77b7a2c510a5bf0bf2eed907da326fe31320e5501f9c9a56e27f74c5289da9c9b11760861a6d93af31a3e532191ccec575948b390dd654017a9554b14a96abd48538f8b3e2ff2bcb8b28d2b150a697b4cc1e083f0df0938597fc5c015b2d68094c19af791f14e5465e58c5fb2e53f0165719f6723d5ec9a42192799a2a6943865469b8ac3b3f50436c0a69ab7d455cbc56a19af4556921e35686f7c57f82451b5c8f302664998bf5dd28a3de9994441d2c17a390b10e744adb60e437755bf781f8d4ed7aa6627f2987002780e2c8d617d7227c0334202347fe99d4048e9cb0f039780de44f095c8bec8d44e5e30295c73d82bd8f8f5a934d7387e91b4dc64cdee3694a8db569904ccfe9bbfacbe40879368e75df1592bfba34dc07b3af799f56434e98ce47429c0a15aab24c7d8ffa5792f62255de8b1cb328c3da65c830f40a752bc2d19d93ec8e0f6f99e972cb0bbedde8646d1bad2b73d288bab0d5f917690b5700f7b3b630fdf2aca6abd96c5b1d3471e2ac0eb6ad13a1ac32c7fce968bce0a8775d5334439010b29e0b12b2903403282923f6a64f0a057230f45f71623142cf269c3b95dab1b16854b35c272bc3efd9e8e4986884d77961c09e31d42e98f9a1e6c653fa66d8f0f710651f747b6f0032297247375a27f4c0ea0a0e0a2be36053b38158e920a34b753acf3554f37579d9bdbaab5249662a4f8e08b39c79c18e111d8c5b176d53b7018e4759085d0696d45085a7f5c6bd2f337b056141ad1c1ea204ab51f160728cae5abe87d9a3955e44170d2b2ad6c83788d5a65dc6c5a1f3360a2e4b3e0da73a453e4db65508bcad84b9c83836c035b37da4cd022640b7a0547c98ff213c64bb3a146bb98d22639066ae54ec4a5e2c2284212413f500267f51058850a5dc9e3262ca803220617118e8dbb81252d866fa4bcc7b6fa8fff879e94c9da6e5c6d61d32041c9c9bf488a1ef0a630b476804488b99206a87a5b5c404ad7ed928140ff727ba5e117b1a0e48445642c1466b2148597d3fb71ed4757a8691899e3c774f5d15c996dd78df8dc2109bb2568a7138391d7cbe4b2e9e1f1be2824a927e751161ddef1e07d1d252334478c9b824da946884fb546318fa0dc1b1581b5bef7e2e06c923442a94e1cc19ff8e3b5c4242c5466e47720ac0980c459864247c34ecbe7430621f1b1b0ffa1ad4c36507564c3c7efc2d6eed1b6cdacf21800564ca6809b416ee1944415ebc146ecc285d2ed9b7f525284770551de2e906ed3d8a0f7057da16e57d3ec8fcb03d32fdc2afa3ab1bdc7e8d9a3df30bfe66e700845f2937db1e5025e6b775d6615a0e4f60eed163c034c173ecc900be3afa39140a49edc9d4494ab9550db77da4903135d1e5c1ab53f8b4cb10992160ad817308f94f89c13da52279e84667901f385ffa30283045ccfe45d027000530fc96cc6fdb21e408af8a3c1b1068ea841fd2122408ec4e9191ff0996f755d52ce50915ac449b1ec960889f3f5dbad4a7c7e185bb81dc2d328b050af5c4baceba1d424de93bf8d5a7cd5f61ede600e583ca13114c294e3927736ca9a834a92a52995f2c9c16dfd7988e647886a2700445ea6101ba75d5383c9c6be5bb30896feffe10fb97fe804d4d32a33d1d31ad02a0b40dbaf0b47aeef4950f7c035b06725b188e135aebe6a340a04b44099fb94080b726602b33dfb6e75a2efb9d41a4b252d700d64b59da8ab6775ea8152c6145bc86ecf77914e9b90aedf965c2126c01e849dd49f62fefaefe48adaff4b2bf9649dc43209cedbc93e2168e0d9ee451855b36ac822a67040a2dbff90ea68ee963ff0d3cef90f51b4eb768a0624dd21c2166f8bf8bb3adc84da95dde0eb1c4445526076eb87f314f098d19c2cc660a2e9d107563ef6d17ae91752822a9b32888c0b4e195f7630aa4994b0bca15e11c552d2d818f8004c481e0679669675c93499f9732d17e3ffcb6004645f15ac499f836e4930bd5d3b2a0622212b475c658af1dfa2f1e8acf32382ef5204ae9c5f8e942af46dd222e21cbf5305a1e1f9b708f40021bfafbda7e75798a244504b0f26a6c8ac1779820bc1119fb3a6ad55aa71ec8f0f31caf29687be17ce49fc8fc206652a73b2bc294bdbabaf217c3e7aa8cbd17a4e628ccaba2105eec2fef1767dd0621c829dbbdaf52f4fe0872b17d12c6bfa3150f49c83f9ea67918ff2890c7bebd6377e26ab56cfdb37f8772fb65e400ae57cb6aea12227654af179f7fc4f202145dd8b82843b711de9385752fc48a9055276e3f5594e571f0c464d08f82079ebdac4cef4c22c79303e865429f504236daa6f65b3b94c5b2d260a658af429fbbcfd4381e2deb25937c50a08eb9da5fe3eebf7ac2a23c24e9e959560b1b6e4daa91f563aa8b115e312680cc556d1eda071168f0f2b64191cc8aeeacbdfdfc49455d80d0e7cf0a3748a612d57a4db3857ddf79a8b95449aff310fdfb09fac4afcc95dec12f4c5b79b6ecdcb2cdd579aab5e0757cff0c95258fb7736c98b4bfdff693512ef0433b22f5bc755396bb13a450ec9a6126ba330afc4f05da9a61a4a725c22b9c6b3400c107615385366933e16b643edca6c5da048e64b3c5db5186265bfaec2cd637c6a1361cd91fa2b2f9f69d6bdcc7fe81880dc5cb7523dc7334c56376c70f2c13d8128c43cc99285f738af5a43a13b4bfdee49e261a71e86c4fd5ddcd7367249c33732210808c5f9d6e341b75a6c3b5f6207dc4c05179715b3f4e2cc0e7c1d10df349c36d427c0254e8655c29cd145600c6423389ec5a1191d2743403c5c8440d24cc5a3278d2126387f1c875184c1b1ceea8fef322766c95508b0212c6a91ef1e624da2499ee80950db1d66644a020fd1b770db0c96c4ca802679e7c3b3ef5d0cd3acbe818b93f820c8cf55094ed1d9d5c3dba4d9469c505aae09a07bca30f6c3ab7ede6764ea27478d4bd1791ec9ffaa298e33ba6f8b272e9d37b04b3ed4c79a34d58313e9b08141d9047fee83f9f532dd031faedd18d08b2b3d7416b73ef626ee56783540cfd8e10b64814af71dc4ff4a66b413f57eab8286343ea7035baa44b5f8f05d5e0edf6b14977b3b31861e94e89b792deca1d021334573e47848815d5e0e16cbee1490239a28c7f95a367ffa0f96ee4236d20f7c942956c0123fb64379278cde94000bb688e8a955ef7412e3fc2e72ca7daa9eba027e0e0717bd46ba97575fd8e30862d8d03dcde7c3016921a651de0d288a2fdc0f88214962bd5153ad05a63a9c9b4300815b3689af8777443b1b6c41e9df50da977445a9d30ee8452259e7fe0f42672afd60e839afac7293a79b6c7e20101bdd4f90120be472ed9728354c7d6e10a69aa30c44d2bd930fd238eb653afb5e796519c068c1805ca64ed70eb2c2e70349b935da6e90442c04002e5edf2a328bc06982953c4ddc3a68a74470b6e5746e545c28baa0ddf9f0ea3bc2fb1934ac5ab89d18bd8bb74557e041e11064ea79dd40405d3c69bb7cbf189cbcd2a2b8369c957c4813c5ec9103e26178595dc3c78dccc9c213885b44b826e6f08a5ac3bf4626d701f65d168cf0d46d7953389ee132266e6666a6b9bd51cca3e80acc9b88bd809f3532963e5dac38a421558b9622b95b965d07f27d45054d162bae7a2c3b7b449b91cec680359e8b6b1e79d5e816efdb07fc32b473889a5f64731ccf6128469085d58089970df57defbd27758de8244f69dc9f64508c833a2664299bbaad25bdb26a5ad2d55e5bddc51a26bb2590a6331ff153371732749965b6e9f354704bdf166da0cde8ad0ec64a6518aaf3914fdfe7e6e7b0d5acf878498760711aac2030a701ddf3a927b5aa9ccf2a4073f7dfd56478da36f854e21748ff70f89d09a20f513c8fe88f48af3eff29ea8442b504aecda9e709ce76f0b1baea0d79325f4fc493645cfa92d116d366c85810483ac4ff169731648f185a8553dbb57e11f6f41175fe06566ae7dc9500482391d5ad8202c5469d12057034a0357dfff4df0aaa57ff46bc076a6c7f49d21d974dec4c1012c39f4127d454b56885b328bef4b400b8dde0fdeca83e7dd6f419b6fa3a8336047a86c29de26e9bbdf59f5da707799fced74df4e1530fbf9343302630bc3dc5ada5480e3cf75a8fb7fcc678149892c5b73d2e49c264d28ba02b9889e41954286d5fb8b576322caa0f927acb27049e700740abf68ecafcc3fecd215c44854596fe874691ae8c307c48bd1d60bf21206fe9aae9b1fce6c81fe6bd100e4f87f2d102279421541f0d53754f352e654b6afc74841080e380b3af6bab216565ae041acbbc402dff286f21c2d32e20b23e8e28df324fffbd57dce49ffb5da4d0810c5c3e217de0aa53b9eba81c9a5872ea02b7579d385b63b94dac513c9b628aad0dedd3714a419c4cc174b4ccee336f23cfb18584a2e83618ccd5a083524d6d34cfde25a95fdf60e1e6f2321bba83eca2e35c8404764e70e1507aa22b21282b878fea32c8fd5dded1e0515224217574e464a356e57475e24100a7144505d5ee8343440b0d8aa2f4c6f224e28eb5c9d12fd5358846cecca8d9ae2df59cdfbb290034fa27e6072aa69d4614b5348fe03abb353741a1a43d98a144d9cedd4b76d3f50bda5672872b5d0d1fd743d8dc3249655268fb4d197f2893b9901b19adb91ac22dd515d73f1b1a3687df5ac5dbcb6721512dd895f6e06b867e8963ae0938421b62488636f9b9cf2efa6b8977d0d25aa09dab0dd17eb005d72e80332c587eb9e703639dccb496528a5c2bab2e9e527778c410b81505f5ff5201da13e3436c6634f8e9a203f911db49fceab4081073c90eca0c5abf977cf00f4ee89b302cdc5a2d4b0c9b30f95a5e1e5e31ac9ad1f54673dc57151789545beb2a1edffda43011de3758ced51f9c518db896879f3fea171cb59cce8bb731e9a16560d2a56848cc4fa4002432dcc03c7d5856c82f9c2512fbc5e01ad494da45bfec279ed7730acd5e071ff8b3d3ada70bffc6440e22325708b06e7c5d9054b0f3fdea85cb82166de146b229c7af3a0e2f423ee17f83cfe936caab9a69b48ffdfbbf5beeb901229be9a9638dc56dfe40ac38b627588c300679cf072b5aeb4e4d57ce99c0df97f6b5d99839744ea35d65232405364687c6ad19c4ab703afcf5e80c87217a642b72f3457d0050a333270485ac895c14e81eadcb771aafea33e86fa699273cc929341ecae72d7e849c618968e89c54368c6cd5b42f929045af6571022c0c5d6dd2c4f8c9f505b1fc8a11280b574ecea10583b291e5b8c18487d738043577892dfc6374c47a98eb5dcd3d1a542888caaccd930f4fe3ef3aefe60c4f69a90585fcbcfc3d32af12dbca4aed0f56a92f44c45b8aa1cb6049620c8ab6022f68775924fd28b93d5ca658f9d78ae2ea6ccb75e9afb25bd104381ea6f623bfeccac5a2117da1e88390c8bfb30ba7a4fa9b6b31c7965a3fea4acfc02443e516ee377c4605c5723ffa64d7f18f1f9d44e97a412c2cdbd0274d671294c441e53aa5c59d17d00004c1422aeb1956a44e093b741966e1292ab4542d1f83c1cafb1ba7e0104e80f5dd00167dffa1d385e00058b18035851553b9fc42be5f18aa13cda5ee2efb709e817fb0e20983d405021b01c1e01984b63c7757f2235b15d80bc6f5012d7a64e8775614ca6bd942eb24a16bb5580b30070cba7bfc66f5bf6b25edbc3f45fb5290f8d5af1357654fdbe21d4f5c7d50bb25d8e20bbc7d2c717a08bc69bcfa6efd7d35af95b29154b5aace477f703a589da4f63f9fae7a6a06faaadd9708c7a962e6366d807b9c576bec4917682c115bc6a5289a382e3eb4922589cac19e302da27381cc2e09e1da82b904a5e733616e0c6cdba928a69ec1079ee077d2a20753b82120acf8a7faf2af4c673082f4302b0e43273bf047d614c112f416c3c16ebba05dfaf1b6b2a89842b7d670495ac8931bbce70be2853148e1b8ad22ef04494266b71571ed9203e1c17d9ff12d1db7481c474faf94394edca9c6fc95054aa45bbec832741096b017fcbd5b5de81f8685b5eecfb89fde35cbf21c57c37dbb6e8c64def233cc3e05fdb92a1b7afc4da5a9252103cb6ab2afbbebb188c58e111ac2d2b3a26d10d5ee9141e2e37ad3fc1b4edea8e37631285bac5ff5d0b29748f622e9056ab94b18b3cf2785ef7cdb7b8f2ea3849d0a5209e815cac41db583ab9af1770c91da6f32a59ed85ae7556cae6fec727c1dd589222113dc66a593498454f432d430e8f7c16f59317bc176efe323e2463a45f03abc7243bdb7ff69b15ee86f57a3b34a9ef5a9f0686697371dd72f476b584fe35c2966fbaf177e55c553f61c98cb4e283587c592d890f1ee14a91fa3c4bdb7f917b0bbc54d5e26afefa4335f128d63fef6c0b3f6031fdc27f66a9429d8a5464256f4aea89de7274e36dfba6808b481b17c0e8d94fcd73e9a46a2d21d1a5b496cab06777597eebebcd96f745bb29cd1e0576e5381c9e0b33642580c0639863f1b194f4ef6e73f83ba81d28842984acd7b78f32e7fb1d7a6fd6d5708cebc61cdfb245c616e84188e0d40baae02e6f7a0cfd1f75449feea972d41212984e0a89b567de1b03807fa3dc6fd4d057943bb2089274d91300208688ee54b5600573d623160743880bdcfebca7854e13a6f9cc7408c320aa6e70b152270f4a1bd96dd49e9a492d27cbd12331fe72ea0098fe091a7f85be307e9cfd22f30d5656d031cb6522aefe7aa689a849519ac95769d9d5f68b1f523f7cb1747ae122b7ea1c7edcc577f190af32e292b6e648e07a4e8131e67d34f62374f11e5c80c90a90cb5baebaf1945e1a3707a24057d500e98b02ad418b5ac0971841ae3005f74c1d879c9da02fd5f571d6761716cc20dfdd9441609f1c1005b04aa61b652292d453d1682f091f08e794de97ebedc32e12cf52640583ac6aba51db7f10cfabf8593aca0c25073420534f302c9fc9000740c7911014e03a71861cda4f2d70170261786ce5a53dfd2d55e7ef4111dd643674472a9229b101e06b2efcf4dc091b97d9c8766dd7c1618c9104f6baabac8b8c66b814819e50818437c87a6ffdac25b479f13eabd03b61e5854d3ac442705a02b83278de35140872ba17c141c13398e02caf374746c5a0314a42d4b1f45e4495f3a693e55921674285842dbb1107730c8b18669f0af485260fbdde363fadd2dd277ddb5cdb9782e9f026bfcc75cf6eaced9caba8c205ca580a5b23abfff65dbcdd8fbc73823a9112e5d22c25b8f9bd11674b0577039a3aaeb31246c4acc63ef08ceb0152583d20122131b2aad3e9f94716a7d2c6d6df9e4260d8ccdfcabfaec192bfb0b3fbc5731cf362e90ae2fc21b0e77f57c08776f9e5b8b7895d085cb45c685b5760580dac4dcf4c05fc982b979cb28569c76aec7a5b5991bb7120fac5806eb21ffebc75f806e61296b6594dd332f6236fbf70ce8ecf3830e7f4cd14a14e745616b12367c3b9e574738aaf02e0e655a17c0ae0bdf1c1d672cf2fc8c99194bd1b52ff5199a5519b84305a89fadc58f4b310d3ff48caf39c17f5435d3c9a94cd12b18b62e92868859d089ec3c8a79be6a37f1539cec34d15999635718b77e2b1954d7549fb3ef05e4ec67ee192371ec0a0447a16b3fb1859c6ce5b2b696ee2a1aef1b3048a46d12966266d8189fcf3942f289e97202d7f2958c157a70ef71c6db1335ce3ef90638ce84a2334b1a50f36f351253bc0d6d4e53e3f11ad7e52d737752364d7243d6a067145a5aae0fdb89af96fc02d049a0567f72c97de0719726b335a9a57fad1232afd3f0ee8779738ee8493f41ec42a90b49eb6f275ca7e7cc6401efcff63a7929e76eac73495cf2a65e9f887b1adda8c113fcf4eb669bc4228de2d59816d807275080658ce6e077f7b3d36d876327b9a92e7fc0675cdbf8b71bcfd8266f01e36bd56827a24ef717ec29f22089d8e2674ea3464f7c74493638920cbc5538a569b91c3cd8045f548d1e7329bbff10a51f873131fdc08f4a698380ffd7482c810718ea7bd04db3156661fca9bff5206e2e16469481bb1033a5bbb3d2e0c3778ae36bc45154415fe0d7da65619aad12f598723df492723f4b68cef8e251e28ae356a00fe30a9aed8a5f3e97c1f726623eea0effe3d708a16abc34f4e22172f35d02682d1e9ff21ed244fd13a324a1fea0964036c058e47f50f4b662c166971392904cb7b307ce9b09777ceaac5017abaacc2a07230a6d509d64898441405bc77c76cc6ded78fdfa346816cef888dac0ad4f7f9697cffeb453376c1c7034e0e7b58f5e1f1f50c22aae6b6429aeebf8444561bdbc5675feb5698e61560d82ef8881107c601f1289229e18ffc1777cb8633cf2c90d702c91cbbc6bed42b81974c7f721afa6cf81520c1d80302aa8dadba6f450bf63b50dcb3a03a07c6020d1dd42168a35a58cc345f1429df94e94a9e8b6bf8829685f6d5302f5d9baaaeed82536837a26095e17e04e643542f0e80c289e1a6df2704d7a7e1a97b218522c1a5f336ef0effb5a2362c3abf85e66ab898b8d43e12c01816d348b3eb76c3053e138787ec894bb9f26b0322fbd0373d55cf7ffa52c2848da191e09e037547bde4db8fd853ae1d2d96c696cbdb0d9292b51450f8e7fb369750f52c0395c51106775be21926b308aa7ed17065ff82deaf1c56ed97dbd41605155b3eb150842f6425b803700fec8fefef74cd0c23aff21db6cf5be4ddfee2a48e3018beb8e7ad06b08525ccd4fc992f593babc0b4d1a72c7df392fdc23ce22094489f09e0f0bfccea4d844e829092f44e61ff83f963d00c7cb36e7aea72211ec9d9ba29492451a42d44b3a2103b3588045eb42e4d5512393541804e4ef05b5ef44a69b33b55b94c67abf9a1a61da4fb267ae0d784bfe6d16a775ade81f0edc277cc68282e6213a6a0427f2df35538754843870ae134b0d0cd858da7fe3befc2fd613</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 880(Div. 2)</title>
      <link href="/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/"/>
      <url>/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>挂个传送门：<a href="https://codeforces.com/contest/1836">Dashboard - Codeforces Round 880 (Div. 2) - Codeforces</a></p><p>评价是，切完ABC蹲大牢</p><h5 id="b.-astrophysicists">B. Astrophysicists</h5><p><strong>题意</strong>：</p><p><span class="math inline">\(k*g\)</span> 银币分配给 <span class="math inline">\(n\)</span> 人，设一个人分到 <span class="math inline">\(x\)</span> 银币，<span class="math inline">\(r=x \mod g\)</span> 对每人有补正如下：</p><ul><li>若 <span class="math inline">\(r\geq \lceil \frac{g}{2} \rceil\)</span>，则向上修正至 <span class="math inline">\(x+(g-r)\)</span>；</li><li>否则，向下修正至 <span class="math inline">\(x-r\)</span> .</li></ul><p>求分配完后，剩下的银币数目之和最小值。</p><p><strong>题解</strong>：</p><p>​ 什么黑心资本家出的题。</p><p>​ 考虑一个人分配到的银币，从 <span class="math inline">\(0\)</span> 增加至 <span class="math inline">\(g\)</span> 。增加至 <span class="math inline">\(\lceil \frac{g}{2}\rceil\)</span> 前，经补正他所获得银币为 <span class="math inline">\(0\)</span> ，原先分配银币即剩下；增加至 <span class="math inline">\(\lceil \frac{g}{2}\rceil\)</span> 后，我们需要额外的银币为其补正。 故对一个人来说，我们的收益和他分配的银币呈一个由两直线构成的分段函数，从 <span class="math inline">\(0\)</span> 开始并且回到 <span class="math inline">\(0\)</span> 。我们的最大收益点在 <span class="math inline">\(p=\lceil \frac{g}{2}\rceil-1\)</span> 。</p><p>​ 此时可以分成两种情况讨论：</p><ul><li><p>若 $n<em>p k</em>g $ ，那所有人贪心分配（至多 <span class="math inline">\(p\)</span> ），最后每个人分配到 <span class="math inline">\(0\)</span> ，方案显然最优，结果为 $ k*g $ 。</p></li><li><p>若<span class="math inline">\(n*p&lt; k*g\)</span>， 最优分配结果为<span class="math inline">\(g\lfloor \frac{p*n}{g} \rfloor\)</span> 。</p></li></ul><p>​ 讨论下第二种情况，为什么是这个式子。</p><p>​ 易知，最优方案不存在向上修正。设第 <span class="math inline">\(i\)</span> 个人分配到 <span class="math inline">\(x_i\)</span> 银币，则有<span class="math inline">\(\sum x_i = k*g\)</span>，因此我们的收益 <span class="math inline">\(income\)</span> 满足 $income=(x_i% g)(x_i)% g $ 。这是一个比较重要的性质，答案必定是 <span class="math inline">\(g\)</span> 的倍数。</p><p>​ 设 <span class="math inline">\(income=kg\)</span> ，则必有 $kg p*n $ （答案上限就是 <span class="math inline">\(p*n\)</span> ），故 $income = kg = g  { g } $</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, k, g;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; g;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> p = ((g + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p * n &gt;= k * g) &#123;</span><br><span class="line">        cout &lt;&lt; k * g &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; p * n / g * g &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c.-k-th-equality">C. K-th equality</h5><p><strong>题意</strong>：</p><p>​ 构造第 <span class="math inline">\(k\)</span> 大字典序字符串，其中字符串形如 <span class="math inline">\(A\)</span> 位数 <span class="math inline">\(+B\)</span> 位数 <span class="math inline">\(=C\)</span> 位数。</p><p><strong>题解</strong>：</p><p>​ 体感很简单的一道题。</p><p>​ 设 <span class="math inline">\(x\)</span> 位数的范围为 <span class="math inline">\([L_x, R_x)\)</span></p><p>​ 由于 <span class="math inline">\(A\leq 6\)</span>，因此枚举 <span class="math inline">\(x+y=z\)</span> 中的 <span class="math inline">\(x\)</span> 。</p><p>​ 接下来寻找对 <span class="math inline">\(y\)</span> 的限制条件。</p><ul><li><span class="math inline">\(L_B\leq y&lt;R_B\)</span></li><li><span class="math inline">\(L_C\leq z&lt; R_C\)</span> ，即 <span class="math inline">\(L_C\leq x+y &lt;R_C\)</span></li></ul><p>​ 由此可得限制条件 <span class="math inline">\(max\{L_B,L_C-x\}\leq y&lt;min\{R_B,R_C+x\}\)</span></p><p>​ 然后边统计边算即可。复杂度 <span class="math inline">\(O (10^A)\)</span></p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mn[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> A, B, C;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mx = mn[A + <span class="number">1</span>], i = mn[A]; i &lt; mx; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(mn[C] - i, mn[B]);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">min</span>(mn[C + <span class="number">1</span>] - i, mn[B + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= r - l) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; l + k - <span class="number">1</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; i + l + k - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> k -= r - l;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="e.-twin-clusters">E. Twin Clusters</h5><p><strong>题意：</strong></p><p>​ 给定长为 <span class="math inline">\(2^{k+1}\)</span> 的一序列，值域为 <span class="math inline">\([0,4^k)\)</span> 。求原序列两不相交子区间，使得两子区间中数字的异或和相同。</p><p><strong>题解：</strong></p><p>​ 瞄了眼 Tutorial ，不太好想。一开始想过类似于分块的思路，实际解法也差不多，不过只取一个块。</p><p>​ 先关注二进制下低 <span class="math inline">\(k\)</span> 位。算上空串，共有 <span class="math inline">\(2^{k+1}+1\)</span> 个值，但实际上低 <span class="math inline">\(k\)</span> 位值域 <span class="math inline">\([0,2^k-1]\)</span> 共 <span class="math inline">\(2^k\)</span> 个值，因此根据鸽巢原理，我们可以匹配出 <span class="math inline">\(2^k+1\)</span> 个区间 <span class="math inline">\((l_i, r_i]\)</span>，使得这每个区间 <span class="math inline">\(S_{r_i} \ xor\ S_{l_i}\)</span> 的低<span class="math inline">\(k\)</span> 位均为 <span class="math inline">\(0\)</span> 。</p><p>​ 接下来关注这些线段的高 <span class="math inline">\(k\)</span> 位。采取同样的方法，根据鸽巢原理，必定存在两个子区间高 <span class="math inline">\(k\)</span> 位的异或和相同，取这两子区间的交即为结果。</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    n = (<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; Line;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    g[<span class="number">0</span>] = s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lbit = (<span class="number">1ll</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hbit = (((<span class="number">1ll</span> &lt;&lt; (k &lt;&lt; <span class="number">1</span>)) - <span class="number">1</span>) ^ lbit);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; g[i];</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ g[i];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = (s[i] &amp; lbit);</span><br><span class="line">        <span class="keyword">if</span> (mp[p] || p == <span class="number">0</span>) Line.<span class="built_in">push_back</span>(<span class="built_in">mp</span>(mp[p], i));</span><br><span class="line">        mp[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Line) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = ((s[line.second] ^ s[line.first]) &amp; hbit);</span><br><span class="line">        <span class="keyword">if</span> (pos[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l1 = Line[pos[p] - <span class="number">1</span>], l2 = line;</span><br><span class="line">            <span class="keyword">if</span> (l1.second &lt;= l2.first) &#123;</span><br><span class="line">                cout &lt;&lt; l1.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">min</span>(l1.first, l2.first) + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">max</span>(l1.first, l2.first) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                     &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> pos[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d.-lottery">D. Lottery</h5><p><strong>题意：</strong></p><p>​ 给定 <span class="math inline">\(n\)</span> 个人，每人买一张彩票，票号在 <span class="math inline">\([0,m]\)</span> 范围内。设开奖号为 <span class="math inline">\(x\)</span> ，则票号距离 <span class="math inline">\(x\)</span> 最近的 <span class="math inline">\(k\)</span> 人中奖，平局情况则编号小的获胜。作为第 <span class="math inline">\(n+1\)</span> 人，你编号最大，求最小位置，使得能够使你中奖的编号尽可能多。</p><p><strong>题解：</strong></p><p>​ 非常繁琐的一道题。先来看这幅图（截自 tutorials ）：</p><figure><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307021737523.png" alt="image-20230702173756179" /><figcaption aria-hidden="true">image-20230702173756179</figcaption></figure><p>​ 假设当前选择编号为 <span class="math inline">\(c\)</span> ，<span class="math inline">\(c\)</span> 的前 <span class="math inline">\(k\)</span> 名为 <span class="math inline">\(a\)</span> ，后 <span class="math inline">\(k\)</span> 名为 <span class="math inline">\(b\)</span> 。则中奖区间为 <span class="math inline">\((\lfloor \frac{a+c}{2} \rfloor, \lceil \frac{b+c}{2} \rceil)\)</span> 。由此计算结果。</p><p>​ 接下来讨论需要枚举哪些 <span class="math inline">\(c\)</span> 。由上面图可知，处在 <span class="math inline">\((d,e)\)</span> 区间内时，中奖区间虽然改变，但实际中奖区间长度不变（<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 没有变化）。故我们只需讨论 <span class="math inline">\(n\)</span> 个人所选号码的前后两三个数即可。 当然，特别考虑边界情况。</p><p>​ 输入量较大，需要注意 <span class="math inline">\(IO\)</span> 效率。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; v;</span><br><span class="line"><span class="type">int</span> nowl, nowr;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calc</span><span class="params">(<span class="type">long</span> <span class="type">long</span> now_pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nowl &lt; n &amp;&amp; v[nowl] &lt; now_pos) ++nowl;</span><br><span class="line">    <span class="keyword">while</span> (nowr &lt; n &amp;&amp; v[nowr] &lt;= now_pos) ++nowr;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posl = nowr - k &lt; <span class="number">0</span> ? <span class="number">0</span> : (now_pos + v[nowr - k]) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posr = nowl + k - <span class="number">1</span> &gt;= n ? m : (now_pos + v[nowl + k - <span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, posr - posl + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        v.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    nowl = nowr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res_pos = <span class="number">0</span>, ans = <span class="built_in">calc</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> bl = i == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="number">0ll</span>, v[i] - <span class="number">2</span>) : <span class="built_in">max</span>(v[i] - <span class="number">2</span>, v[i - <span class="number">1</span>] + <span class="number">3</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> br = <span class="built_in">min</span>(v[i] + <span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> now_pos = bl; now_pos &lt;= br; now_pos++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">calc</span>(now_pos);</span><br><span class="line">            <span class="keyword">if</span> (p &gt; ans) &#123;</span><br><span class="line">                ans = p;</span><br><span class="line">                res_pos = now_pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res_pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="f.-doctors-brown-hypothesis">F. Doctor's Brown Hypothesis</h5><p><strong>题意：</strong></p><p>​ 给定一有向图，求无序点对 <span class="math inline">\((u, v)\)</span> 的数目，使得 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 相互之间存在着长度为 <span class="math inline">\(k\)</span> 的路径，其中 <span class="math inline">\(u=v\)</span> 也被允许。</p><p><strong>题解：</strong></p><p>​ 不会。稍微翻译下 tutorial 。</p><p>​ 突破口在 <span class="math inline">\(k\geq n^3\)</span> 。显然对于所有满足答案的点对，两点都在同一个强连通分量内。于是讨论范围缩减到同一个 <span class="math inline">\(SCC\)</span> 。对强连通分量内的所有环的大小，存在一个最大公约数 <span class="math inline">\(g\)</span> 。将所有的边 <span class="math inline">\(&lt;s,t&gt;\)</span> 按照 <span class="math inline">\(t=(s+1)mod\ g\)</span> 进行染色。由于 <span class="math inline">\(k\)</span> 比较大，所以可以认为颜色相同的点都是等价的。</p><p>​ 对于一个连通分量内，满足条件的点对有以下两种：</p><ul><li><span class="math inline">\(g|k\)</span> ，则所有颜色相同点对满足条件。</li><li><span class="math inline">\(2|g\)</span> 且 <span class="math inline">\(k\equiv g/2\ mod \ g\)</span> ，则所有颜色差值为 <span class="math inline">\(g/2\)</span> 的点对满足条件</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[N];</span><br><span class="line"><span class="type">int</span> col[N], cnt_col;</span><br><span class="line"><span class="type">int</span> _stack[N], <span class="type">_t</span>, dfn[N], low[N], cnt, siz[N];</span><br><span class="line"><span class="type">bool</span> book[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//强连通分量</span></span><br><span class="line">    dfn[x] = low[x] = ++cnt;</span><br><span class="line">    _stack[++<span class="type">_t</span>] = x;</span><br><span class="line">    book[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[ver]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ver);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[ver]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book[ver]) low[x] = <span class="built_in">min</span>(low[x], dfn[ver]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        ++cnt_col;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = _stack[<span class="type">_t</span>];</span><br><span class="line">            col[p] = cnt_col;</span><br><span class="line">            ++siz[cnt_col];</span><br><span class="line">            book[p] = <span class="literal">false</span>;</span><br><span class="line">            --<span class="type">_t</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag[N], dis[N];</span><br><span class="line"><span class="type">bool</span> solved[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    dis[x] = d;</span><br><span class="line">    flag[x] = des;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[ver] != des) <span class="built_in">dfs</span>(ver, d + <span class="number">1</span>, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试染色</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    <span class="type">bool</span> Flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) Flag &amp;= <span class="built_in">draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">        <span class="keyword">else</span> Flag &amp;= (num[ver] == ((num[x] + <span class="number">1</span>) % base_num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt_num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//染色，统计数目</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    ++cnt_num[now];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) <span class="built_in">Draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: v[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[i] == col[y]) vec[i].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> search_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solved[col[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        solved[col[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[col[i]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x = i, y = vec[x][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, <span class="number">0</span>, y);</span><br><span class="line">        d += dis[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= d; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d % j != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> p = j, rem_num = <span class="number">1</span>;</span><br><span class="line">            <span class="type">bool</span> now_flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (d % p == <span class="number">0</span>) &#123;</span><br><span class="line">                ++search_num;</span><br><span class="line">                <span class="keyword">if</span> (now_flag &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, p, search_num)) rem_num = p;</span><br><span class="line">                <span class="keyword">else</span> now_flag = <span class="literal">false</span>;</span><br><span class="line">                p *= j;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= (p / j);</span><br><span class="line">            g *= rem_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span> &amp;&amp; (++search_num) &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, d, search_num)) g *= d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) cnt_num[j] = <span class="number">0</span>;</span><br><span class="line">        ++search_num;</span><br><span class="line">        <span class="built_in">Draw_col</span>(x, <span class="number">0</span>, g, search_num);</span><br><span class="line">        <span class="keyword">if</span> (k % g == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) ans += <span class="number">1ll</span> * cnt_num[j] * (cnt_num[j]+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; k % g == g / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g / <span class="number">2</span>; j++) ans += <span class="number">1ll</span> * cnt_num[j] * cnt_num[j + g / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当我开始真正爱自己</title>
      <link href="/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/"/>
      <url>/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<p><em>作者：卓别林</em></p><p>当我真正开始爱自己，</p><p>我才认识到，所有的痛苦和情感的折磨，</p><p>都只是提醒我：活着，不要违背自己的本心。</p><p>今天我明白了，这叫做“真实”。</p><p>​</p><p>当我真正开始爱自己，</p><p>我才懂得，把自己的愿望强加于人，</p><p>是多么的无礼，就算我知道，时机并不成熟，</p><p>那人也还没有做好准备，</p><p>就算那个人就是我自己。</p><p>今天我明白了，这叫做“尊重”。</p><p>​</p><p>当我开始爱自己，</p><p>我不再渴求不同的人生，</p><p>我知道任何发生在我身边的事情，</p><p>都是对我成长的邀请。</p><p>如今，我称之为“成熟”。</p><p>​</p><p>当我开始真正爱自己，</p><p>我才明白，我其实一直都在正确的时间，</p><p>正确的地方，发生的一切都恰如其分。</p><p>由此我得以平静。</p><p>今天我明白了，这叫做“自信”。</p><p>​</p><p>当我真正开始爱自己，</p><p>我不再牺牲自己的自由时间，</p><p>不再去勾画什么宏伟的明天。</p><p>今天我只做有趣和快乐的事，</p><p>做自己热爱，让心欢喜的事，</p><p>用我的方式、我的韵律。</p><p>今天我明白了，这叫做“单纯”。</p><p>​</p><p>当我开始真正爱自己，</p><p>我开始远离一切不健康的东西。</p><p>不论是饮食和人物，还是事情和环境，</p><p>我远离一切让我远离本真的东西。</p><p>从前我把这叫做“追求健康的自私自利”，</p><p>但今天我明白了，这是“自爱”。</p><p>​</p><p>当我开始真正爱自己，</p><p>我不再总想着要永远正确，不犯错误。</p><p>我今天明白了，这叫做“谦逊“。</p><p>​</p><p>当我开始真正爱自己，</p><p>我不再继续沉溺于过去，</p><p>也不再为明天而忧虑，</p><p>现在我只活在一切正在发生的当下，</p><p>今天，我活在此时此地，</p><p>如此日复一日。这就叫“完美”。</p><p>​</p><p>当我开始真正爱自己，</p><p>我明白，我的思虑让我变得贫乏和病态，</p><p>但当我唤起了心灵的力量，</p><p>理智就变成了一个重要的伙伴，</p><p>这种组合我称之为，“心的智慧”。</p><p>我们无须再害怕自己和他人的分歧，</p><p>矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界，今天我明白，这就是“生命”。</p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

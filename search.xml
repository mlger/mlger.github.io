<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络01</title>
      <link href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/"/>
      <url>/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="dbeb179db9797820974fe7f43c8eda218414c509e065cd1cdae6a028c949e5e8">8df0c2fb6c575594294cbfe72329b39391de17c75992aa7b56f3b557dca9fdcd01c8bfb1e095f4c2875fadc647e91d760f0a905b5cc1c6f96ca4e496c05dc3040986e725727fd6486a906fae057a62790bcebb6edb419ae1255ed825cf2c55f86e88527c1ac85846504ff37e55ae39d26aabc5f6197473e7f184361260a14fda655f49b59210fca9b835d7c75a3f36c6af37844b5c04dd1285c547462bceadcb4af2e03b381ef32ea9ae561b56fe8397a4eb01836e3c07bf27844f63805ee9179d96505b55586658fc025191ad103c82417006d0483a26a6fff4d382e387dbcdc31d8d6b7ceb3831565ec6228b6b193a9589af58acf05d693ec378081baa5b29008f0eb6961fbe12f511e8a9737912bd5db89a906b63ecf34a85e0f11d9ddd1994443ee84af18e0674a614f7968a0a903fe81aa33b5ab51dd16539c2e9ba7e36d08b8790b77abd83114e95d2445d8889a33dfa530ec6109feea19f47764b40f5d725c54aa4150df5834a971646856823bcb1332c780505c72c73df425c38ceb8248c2fb3c2ea5688792a30cc4d7bee9a17a763caba1931ebf8e4aaa2709154961954d76e54f2529c3d01a47b27ca19e429fd1605a26f34444b059af968f20829e9fba9080b4c5bfe876412d4a161cab3e496d1c1c71388f6a620188090d2a8756dd3470cef3ff359088acf2dc58c220633478cd6e0342a075f22c9797fd7d4b2c288c65c4f46f936a49abe91fc2a0778ee7b5ed178c8a3c5f212401d1f583d0d355f629b8bc48c756eba906fd060330e4c861a2f334cb741d22423f1b7a16134f3ed611fafab97f4a93f1ee704b5f2003900f800e9cffe6795dba86cf23ae51477159eaa131e338b3a6f711f903d3a0672b0c3aeadba076c4f55060ea0c4ae9b31208920cc3292e6ddb3c771566853861448b28bd4ea5648717ea174e4a33cbb9e70a6863247dfc625d4fc4aac18ea50c73ccb152f7915b62c032de67577cb9c5a4d61bd659951491b51088f1461d73d67f4fd7525b89658bea4f2ea9f21284939db45c507bf35dfe43321e5832143639541dfaa35263ead6d3895566ff95777c5d9d254c9fb32d07017eb62bcbe9b76922ccc6a57e140b761241294ea20e97a4fb49f9cef999c5b05e827bb31b254dcea55e72f5f50c84c441f764cdf06376762744a016720335e5165ad36e5a1857c447ba4d84d1e5e4bde35a87790318ce85c56dac7020b4e96b0e6d16f43e7ff9c869bdb488c6fb8ebc6cd4f1f9143cfc2281b14bc5a659d7254cf5f37c2da163516c118b6c7f464e69ce6f7f9a48576d6f0b29a86e6bc02c5a77d050ecb2fc6b16e09c3e0f9ff0520e197567a7c2d976d07745a356bcf882aa067dfd3cd4bd742245c6347c7a08651063e73441af6606cffb4ffa2ee6f61369ffa95904fff5e939d85fc15b510a1a0d1ac4ed222383a731005ba1197b76e18e8b8ee871e2ca94dd5bddfd5c911e300af69158f303e2f613ae0f595d160c7e4de87e5aea63020aad35d6f4ccdfa4d455dfec58f73f11e2ffbf983aa4de3c5da44f5c09d181799ab26c1fcea4e99460cc570a0bbdbe2fdfd68a2bc01a23d40c845cb7bfe86a5bae87d6c04ec24f897489b68b5aa976839f50972fd5c7f1fa3704fce76ad3a11bf65a575e41a3bd60b8a1ad4004cd2b030f0b657a535ea75b4673c64b702beb8bb39b0c91e149f0caeba516f38143258393b1439e6c43361563ac4856d5abac96ac3cde88777a3bbf9086b2298c810fb0ff516345f6246541d28cae2c49c32b95608ad3ba1fe49972406b9d4c5357a435d9723e4521274ce0b4c821a1621454e1209ddad2a870506bf8954583517be681848e95d1214fc77cf81efbbb8b2417cd04cc71b2ee2ea20f08adb6bce7df893b288245f7ec04dbf97d57d84343e10708e55473a8ff8742e18c5f1cf72f4c62c8e57daf5f3c47242e41b0c32ab5ef2f287ac436ef6c04f8b6812bdf640d957a36fa70046ef167a4a12177e3daa39068ccfeeda165b05faa2e535f6905e2292c019745559ff62172b7fa5c3800a9cae17ab24b2c333fc99d44be7fcc259f5469714f32f57854413957bad3634d37449ab43f713f16bcefd96fc01e3fd90529485c6ae30167f16277524fee45a53334db4f6aaeff284f61c979ca62c121cec8ff4dd7309469436bb803687c330a8b9eb0ac2d9803dedea49128f260334c154a42813d9e4f79e9ebdfbbb1a1c3b660ef10de4d2fea8898be149a77371fee50935017ea9f4d6c40e799e8c0a1f2e0b39fcbec8f76eae63101598bfafddb8a05283670b93f143f1f8c3a00a6b359b4793f74bd2eaed3df3fc86bf17f4084703283bc3593247b6f51d9d766719e31cd0988abbfb3b2d113e229a270f41a457696355945445ad71d212041e4266296bfdb58abd23ca0817e87ada0cc46a10b44dffea8af7bfb03524c7cd1b69bac937a8aa1519a4c3d41e5dc27b5caaab9a56a34a800b3766a9599a15000c456e2a7c6fdc4530276fff3f35e6b52160aec1dd8212aaf4cd24cd4c407da2bc82d4d8396457e7ddc3bda820d106fbe31f33eee74c348520ecf78801952965f759e4ee5879974e3c3c7fcef2e5f5d3191e8c313aeb76bf92297a0c991f8086cb9ae71203cf738c1b41ad3b709f43e0f1bd3cd7c2ad1ecb25c73a922c1b32bcc72b67248c36303d5cae33f2a0c17587d0b5b63d7ad9510d8593100e9f95e34f42e9230a1736954ff08a919f6ae4dc7c4e9e9d14455931b2233fbb8cce0d04df0b9aad446dcce07c6bd4cae2d612e0b240063cadff2be10b2b6907aa6bc91214ac28755b0fc7e7dffa91d5cf7068333f283b3b152f23b702e95dd1d85e567397ae7f7c2112f9ca650e2c6988b2d3170111c24ef194610076633065e167523bea0127c5d61010865facdcefdb4537dc63720c6a9d21b2167bc2e82e01d0c32961405c9ae3bbe404b2fb11740d14701a1a98b025c502fa07147a279b2aa650088d750e6ab6ede13adea4387a04b05bc4718ed569b3d871204d15cde211dfe4b326f60539d52722a21face0fcfaf1022976d58e600baddf12292eeb0a67a5e9d1c9c93e5bdf5433fca5d4a673e4bf43a558e24f17b0a3001ae4dba435474c59fe08e445de8dec7639ba7c2dac04eb3a075be0680a5ecca0c9c82654205c8edabf1da263cbdd3206a9943ef0decff85e91d6737191cd67641a5ab0aaaa00f8279d675caa51017e5e3d9973fe77c774615b7d075c9073dbd74959cd20a536ea442a330b7c433ca0c6bbb0945c3272e8962e28a0b0024579367fc6c0b8c842051ef08dc1bdedf4bffd3ca6fbd7ebf3ea45d485b09301829aa4dc2338f0e23dc8617eea7b12a7f03e6dd2b18f7d185bccd54624d2e3a63415531bc9d329a805326f79f229bff2e650045d8f83c05ca832136f13357090e12e4ae54a88b06159915679c0dab6aad4a4c3c1bcc78604fecea644c5c7e100c5ffdc1c618f15b4b4d478951b48348f526430eeefd17745f3dd7366b92f6eef717ab516a6014899185652e516bd57db3e65bd779f165d144bda57c7e0a5abf1f15242e4a99848d831136da22f4eaf10aaef4fc50d3a0c042a18f68a4f67445c2a924529f01ea77c3fc9935688aede5a7bf1051735e5d5e0395e577e1b3959072813bb72ad0e4f777cc78725295f583b51b4e617a51696ec124bdba6900352461470a30467593970ec0885d1613160a6646590ed9a706f095a4baae2228c4d3eed4db5fe5c511d4febb41f0e2edeb8a8a0f4febfda2243d94b13b322a9c62d920208ebf235a014a9738e75f01029e99b4591c6508987072f71210143649cf38526f9ae703d7f929e29b674fe87911e148392326edbadbaa3405b2af4123b7cf865a45446c8ac8856388eb5d806238142dad1896c9e4c589c9839561ceaee007664c3ef46cccb61617b54e81aa80a4f98b34edaee73a149c824ee499bcbce2ae5ad5683d5e7c43e5b9103592868390d0fe8c5f61de471dc37e5ed8ee703352971897fb48bbc7b6582c23ea9c9e936c66dbacf11b782bd530bdd1517c24a2a20dd69f173582adf4679a240b96b10ca8e7124903b7971caf87c7136cd79821f04ab8d92aa278f0871d7bc2f3da515380322f62469a588595c89245d76b296ef5baae93cafa252bf57f580595209f47d60889fb5d7ade465730fffbdcfa601062d7902807435bcf4a8eb36d9168bc79336b110394b0556417e67c646fbc92a6a74758fddbb55125991144b3756c8aafffad39fc946f08278d5e28785ab0fa3e77c0634aa7588be26676dc33dad057fc74d1fd17b189508388923af96713a15332844ab06a06fde7b506d892735ec310d1e211a0fc32221a4f14b31d0283cc087084d03ec7093a773d6de4c890b90d1fe9ac8184de59e05456d7e72cf42ceaa0b679e1f141857a992e4bc6922216ede3dd4d1723e9294afe35bec1620ba26b4ceaa9bb43d14170586f477f92ba03b19b19048a5178bd9a115bd74e8bb74ac9d2c9de45bae9c4f8d9eed68eba507e60be81c27f20e9df1f2cbb35e2f6401eae23d87ec1dd0d273746e39fe3151295a9f50be54a9ea605652650e43edf29cc79c69bf234c652e65483ac125b5e02109002818ea8762fea6ee012f9e5664889bce875edf1fc4028c5e076a0cf074b939cde2bd3301f49bc4daedb67d52bd8fd43eed3e39185aadf405c5d0144758fdca6f27dd5026491551e332c9c25823e3d3b387731bb18b7090c13908b15fb3882ac45844a1b57dcdfa4d71a7e67eb20200baedda7ce23e29566cb942e397579f2930445b7ad82aa96133259c4f217f2401a0e0736fd639bb9cca422432a41a1e184644f47a50e6e531a9cbae02a80eacf1f6630069cb25ab7dcf91979db2d09c05c1441269a507b35d1fea1ae5f9bd0c659396f28a6488a1f5b00dc9374cb3fc2f086a76073df83eb4334632191b9389a065f9a33dc321b2560ff273d2596df9c00b27304199cb9870dfaca83c681558c53656bfaa76dfa044cd280a644dd1fed4af7c8b3f7238a77407b7a74fe26c27bb0ce446d30e3a538e34e70a6ee9f19256d14dc7cd5801aa3fa96e6f1c171c689aff2bd63d7341f2134babe20ad6c31b3c976934cf7e3acc495701ac333bb6fde6c15f7e7440ed0fe055cbc3560273be027d31949dd0ed366b7cf7180b6515a6278f71e1348ca4662b32bc1d61318b30e526362f6291ad9e12c39739620a834ff0fd3d134f2759b6d730c6fcbc16fc3101b95cd55a31ba883492a4c6595f1a71dde39573c8c33534ade7b38a2d888a01f44c0a0156d9de488e397df194d84c87dc4b63befb892acc14dbc067cf252999bd53837b6e6fac8465b002a30fb85f4f049e0add745f6d2e6d9f9fd44e841b0bda0f91f1cc30281ccb208979df42e8e7e0d95c90f5d513777f448b68859075952b892b4451d9b411aa9b1029e7612ed7f19d4762704a65af1bca8335280d6576551d4ea248e4cca7fdabf55a6831d7b86ff1464eebb6607c7714a673f22c2d8a78cb0700a8d01452fdc8eeffee993b16305f10c1014e28e8b696d698f55b47db4ddf53b8494c30526fb7eeabda0f3a4e53e87c4dadacb60e1d73556dec60784bcab71c3729aa70ade0d1fbe89c713643439ad25de724ae16ffcf00d67381c71ca40b3333b2a6066aa8cea5d91008a0fe0c0e9a84bdf24c0a9ea79d4da640b871ed13906d350fa8e136075057348a176282cb1c298bac6430d7c3b1090851794cce57226aa0a0808e8fbe41d709396e3776ec035c94b3d273403244257829c7ca1ae2f014d8a44652ea3c4bcc652b25683ff6da3003503ab4256db87db5560807571198e497a05581d80f0f5524ca7891f8de5a8d9028955c367babf625a6f4276da5a01648f07caf00ce961154c36d0d5351d85db71efeaf831f5a142cc3c578e9ada674e8244757c5220420ef4359d141f7c0650a5d5b3bafeb9ae249ecced198f96dcd1ed508f9ef28282f9bacdc3f4574d6e08ed03487dfc554b4831b9f8664dece0fe27ceac26836a95a1fb08a9170fc77ecd4880d446c5f40e5a16540376955042f03489f2ec393fce14ea05c4433d4eae85cd467948ce554da7b3e06c81aea1fe8eb52282ad6fb3a37c28d3dd55704074518a3efaa887fd248e2a6ab33f2453196de1e8cf2ebea18d2505115265c28f90b8cdb6d315642f91b76c65613161e4ad9634df88544ae8a917824e87fbef40b5981ccf1745177dcee44e0b583c5cbd3298d76fbfb7a029929973ec0d3cb323cf01f399914788231cbf4b609ec68c9b3ca5ce05d2341685f45a407713e322ad123a5023f2ccc6018094826b1ad6ca39ab4516af1b578af945aeedb35d5fedf6b32022e06bb01d748adbc01d34929b8223a618a987bb8e26147aad54ff04fc1cf7708b24d15467db6980e4d335729e18e11fb451fb8cce3a8eea072129452341c43225da53f61a1ba6ed5beee3dd4e8eab8357173ff7c2c7f03ed6e77960ec36367b222583dd5e9acf5aa023060ca8378efa5e2b156c87fa21f061c648fa240df4ede42bb1a6ce34ab3917ccd3393e8f3689f56700e6f0c4e98399052b2b341e5045467f03a5230bb81c429e57c99ea80c05c3c87b79836feb790e78c04a963d31ea46dbb9619ac84fee98cabfa68ce0288c0ab8d2ce1c35df2600b08d8e5219e09b0d43cabc5a6878b477ad3fb68b9baab16975bd1df6107b09be640c48684fc4965fcc3116d759be2efd033b8c1912016da8f411d80c6a55cd45af6354b0253d751afc7329a9c943dd6bfce06946075f8e96c3bc894ac971d5bc5e7d110dfe5e4c1334d91a948d8f1a53500a3b446157f0fae8da44148d86d5a92e93293ec13353f266f1483f9b82930e838a2070d2c3945877c8163523d0da2b1689ad1beac254eff6346ce73059c4b830f4653333dad9e21f90af376cd8133c8dfde0bc83248055f6b56787a26944c74384e7fcfb3c734b218eb81967ae6c8dca9242cbd5608e230b97cccd32d19e20f06adf859c5e0b33f778ebbba6f7cb562343e1b168bef6ab0163a1efb29c854263aba78a5244e9d27f6cb157e2f3d1edf4dfae04214a75b4acc7f6fab726eb5220406e5234e5853160a27400b8649262169634668636cfb01ee637b71581cbb929128b42973fb4bbf3c7ea6ec54bdd7e8ddeed445ae4ab3995e6db4e56ecfdf34dc4a702888eeec8ad9fb2ba593e727798f14aff0e4adc478be44bfa181e809c658d8ed0599a405896a6d840c80ec162b7777675f8318d75f94d552fea0337b4f32c44ef6a2c472752daf81c243a568adfd06b67e439b413d666d38546a504a02026bb389aa95187c9ed87d05419af2ad3d255ba0b7472ceff8a1481aae00ffa9cdca947afdec8f876f3416231368791fcf836cf549e11a603e15de547b182b427437378a1b592f54ea0fa39038c73f76a37a379735172c14ff4297e7dd357894bc1adbbe4e66cc860dc95537bb6362c233f45ea37a5b8d48655f7c69254ed4bc15a95bf3c060a7507f82ad06bd02e894ed3568a0a5297ae040d2be01ca08c5a14287ba2c93b04d1ad3a982c78dfdf49f11fc9fa499934ddd6b4809cf2b35e33dbae595b48e6784eed98d655dd968da1dd10f9292479214f4aee7c65142d0c39a3451afd436a9f3a4ad091c34c96db413aad86bff371da44e0c8a4f82318db9082fec367e6ae5a6813d9dd68ae080238ed97f1c986d2af6a0e24160b24db85789af3f55b05582a8a484aacbd6b0922535c287b636a2bb1cc2b0de89f9091c096edb9aa8a81ec3668ae7a7c0528aaff8a4c6ef253a2be2b966412b00bfea7d0073512737fac8705a3956dd084a64c5a122dedf2db66c1bb8205502fabb153052c2d7c981887bcdb0f015ba1b2fb79d4607f8296c91f9e126141723ed57a772c1833cb6c58fcc9bc92369ed7e16be49ef291f2e811276d706fbb094768bf3a860d38efbac1098eee6504465827865e913338c90da875ea3b53da292d402580d61a63285cf6010a57ffbe80f2df22482e5f97006b1706d368311836f27c8fdbf272dd2dc5180407f7a554eb6ff0df34ce981543d718469d2e4b9a8467d7127257565cb1ecf21f847449eefd4867a2299587b2132febc940e16b53d662ae56d9b3be162273e5b9349a96cd3474aa7d2f345344284be8c924c8969dec70a6e18f4328a70a4dd466a06fa4e9fc09f732884d6584d6a5e6c938bacb406fa9a09c771acd117b0419b7496bfb26b1100eacfb4b26d2bc042204f3a358746c3f84d17fc8cc2be2796a73fdb3152df3954c06dce2d8a23d76792703a1d6cc217918afbc64fd6847943bbd291e82dddd79a45828bd88ed871bd923ad63d7d576e144e1839172042459fb8ea380d4fa4cf8cf97986d2abefa9626556507faa042b0bcbd93a4e0052fac544de5d9f50f81df855494cbfd2648f0bdfd4c79f2e4bb19a5381838bfe40d6667e96c8798fc4005d8e0b5f89f0fee01eb2e29201ffd789933ca8be21a071b1fef1a4df93093918d6653ed61562a5a63d4b38fb81b463e994196ee4c878df9aa971545de1c8ef8d507faac5329ee5858beb46cd7b5ca1ea6c34f116dbd03dafd862e4d1e483e635436ad2f97ce2535b1c0a3d9aa68a068c24250c247b7cfadb3e677900e0096a0160cbcf85abcd2f67d25733cf92fd4acf47b90a58970273159ccee7756a9886bbcccbb82488c88ab898e3bde804161559e450d20bef2f3e8d3d92ababec35306101f54801d3675a5c0f7a92cc781c0adb531b8f01441ad028204b74e6c7732848ed002dea3ed558179bdf3b7b1901bd1c5fc27a0f3346b43ff10573cf9de26a4eee013d4fa49d6365f774ff080fe646a2afd7550bbd6fb0933d38524488bba2523012eca1dd66b1c176958ba9ba8a434897788966c8f0d1a05c93e9c544976ee46b2c283d45a50af91a0f3e9aa9d17a790edf6d9882e207548a75644c60f5b7ff5c4d4e77d07e268fed3a0cb02642db1d28759117f466818d56f04a609546a702c4708b052956411b18ecb4174ec4618316abb1e4d3320593af84d6de444883595f3af013c90ec6347c93bbc3ec33fac7be8099c957e062b5933d0efff7dfa4777bdaf749d237fba9ca8740f14c500c71a72bf3a404f1e04010dd676451b0f09bdadf4bd2b7247d6992894e2af6941a250bc21499150c417b4e546602a239e9c5ce45ed4d3fe6301dd6fffc8c76f66d6ca3bd731566e074263a940b815c67473da53ebe27aad208d1e2c0cc790cd8b50fb2203c458cf3b6c1411598478d9cb7d9c471da36e96520b0bf6dcb925217b629a58463a1a5fe1d1811fcf6214a1afae15d82ec9ea50f4a75ce6f2328467841b9279b9346e3eb630fa26c6e18b9da45c74d294983289dbf3617fb7a15cb5ee17883a73f082b843e55aa3a4156b9e26d7fbfe460c6e2cf0be6b7ad293b9845c0201b79dd14d5489d6e8fe2875884a4f60eea00c0f4631720fe1c2c5f978b6976f07b265a7610755e11e5ef8e983a95dac35810857dbc76fc793e42555c8e2ac258598d7e99204fb1fcb16709b4263b61766cc73344c90c03e58ef36c458690b098447cc4ef7ef79d6a3f615a06db6aab224909932bf5b395008f69e2bc90bb85d10acc1e40bc843379704a6ce8e56d8566e9f30aaa2420eeb9aa715476b66f273aaa6c9f86c0d0a18e9360d1a6e7545d532c006be238886475af67b722eeb71123cddc7f37ba664de76be3eb311b932be7b2e28a19079fa3331f12c74ab4ea215865443f23f490b89d2d10b04069d98cce4bab82875fc412711da176d67b661dfead648f40d422c38cab7314154970c78cbcd003d3c4c552bbcf8d124b06c5386a7582bb6c70384426a6e049f1b3939f751e1a684de1dc2e1b7fa53a48133238e1345df23c7f57ae26526133e686dd2d69778c93883c0f3ccdcccd4592429dd0eb380ce3bf22d316030786d7a6a2a7f702c5a64438763814469b574ba4d411bb2a4c414b487be9858e1449579969180eb07f6bcad097e53ec494f16d55f8beb5aa82b0204e03b12d56a44c7f90e3aedeffb3d2df2d09a9035c54597322da5fe5dc86654451950ea4f454e562ad2767c88f024a41a00e3c24ae91b814188e4097df377ce4614971b6ac120fdf90d6f75d9110db40fc3e68de3671da9a1a4c4762f3432b338f19d71c6471813b3ee12b82d26f6bd647375d7caae9d0ebb7c073268d2b1f7955349de6233b0a46783bae1f1f129d834d4cfa5b6dcf1e55ce7f8db2105cc8b9fff238e5c5139c48678559b9c9d9e173bf44e5db1e20509c2aabfa4f0b3696fbfe2f67feb9775bf66dbda2c6fb4190532ac166887c7c5a15da4a3cf64961d5899496c527304acb1a575f38152c7fc815b02d49ce9c40db2e90d3ecda91f7833f5ba1e471c7549e7ec3731aca7b4b9f57a1e9c0228f217fd49553389d2ef8d6328e6b0a76d56890a563bfeff868be4834d7ee21a6b1e489db4903d7e25e7d3e92bc52a4b726e6fded36b33986cb59b952be4481a128421f405e5c29d76419f205e5247e1b1f21c42956eed1026af967c27e93c995ee778b56a93425ac54118fa6eeff1a2587fcbcc77858b5536edd38b744de0a3121561413e3c48ffb87a0f138cd61ba218dc3d6b5fb1cb4eb4e72992aa6c01c0745a14fd59999f287b482e14e7181f6c29cdf49f280aa595f5f5c059b0daa9bfe92c85c8c26668a00f51b4c92d1dcb12d07c65fccb1d44d90a92994a3ebf3d78518861ce8b6d82ca000a78c97fa8cffc8256c3bb4639043f18e1ebe3ee1b281e3156b722b1ca9d371f524338cd2782791633d4e5557c4ad177e2829e405f9527f5447a82873333ad06a5f6e8530995658bd6afbe346084231adef4fb46cd9c6a8e33f4c6aa5811418949170bc000274855717ea2100d512e2eeaba6b0b1d337ce68c53ec0dd8565a05830f3ce6c4e7207b027bc9d988b83d4366974f4dd89c6fa496887c5fd60b4497f583b5b7f6b2e3dc536b0f003f93209b960446457883d5d9680d62b55702827088609861036d5d4df1915fcd3a6b20d4583268f5145146b6db2278d54274780b5b739b968af09ea2a5ae282b43092fbeb404df2208a0e546f941f963a79f77af0fbf2aaadac48b0a5891c6a6421f14d1b232088274f96f9f9b1189db375329dea45b6ee592f44349132f8f3a5957f865312ec50cb2c98c4cc61e37002ef3c50cbb9cc1f8ee5394bf2553f5ddf9d496e9c22352c02b9b6f4cb46ea2857b58c28b69fe67b5e5dbcc3ec87a33f30cb879a07a1cb10aad28c2f16014602bab83f21c13aa963f5f989583493834d5cbfc5af0907ebc5d9ddf25e5efe9521c58aff409a72af46bf85d5013857cc789c7a647584a917e35156c1adb99444883c40dee83d626efc0e179432678afcea4e4b2cae71d0598dd184e20350d6a41d7b6bf66b4211608c0e33e09badf7eabbb267ae20295b848ed686911faf3aada9ba8528a92d0bfcb86c820939848e79b0324c99753babce7d5fe4b4363eba81de9215585890f27dcf3e98471a46cd28bf98fed0698cf77e2ffd3c086c6dfe396c3df191c467b393529705904936fbb211669c4b950b18bcd794fc9eddcde9783757909b229f02afb15e85e324d984c329bd38faef4563ec7260b3279aace01d2898146586beb97fe0917905c1a57b888fe469870c7ce80f21eccb925738beb717b65652337c7053d97b6498d683c52ceab687c9e89e48167b2760104b6717f708d63d4883dd1e0f428ba278bcca958e91f8ac4f0cb205de36d7f2acd15ed2db5818814eed0cbae3f99b69a8aaec207721ab417a309d88ba02509181f91d7543bf3211b0358a3d75394ff34b5da3f1c00ca054c3e2c435fb1be3030b1761e30f4ec0cbaa1c72295902f87136e54820385a3268133b1a036813d8eb918dc79fc6129e4e6b38129435e184f25cc57f679a8d760bca37f8ecfbb241d188790183df81bce65790315943207d87d8b7d14f316b117df8bb1d070d1208d48fcefe53da4c7fc0f637c56d56c48d10e4ef81a6868f2d7529ccd1d84706c8f6849f1d8d54f9fa656caa04aad3afcafd68de11a22a7f63b6394b152d6b2b4f8c8ab527f7dfdf8f069fd18bb80b815b1737f72e96ace2d64d7c55d40c8eb35cbf4edba1888ebc7e1de18b91e8d8f36e5564a68a690b177aed435f10c822b522092594ca67f832f7082308886383a12ec5658072d9f02af1c5e75bf17876aa9ac82c16d45c57bddbefe3b369891c313ca337a8cd092b556c72c27bab8b842cd3e7658a5ed8eec7fca8f95db58ef653b84bc9907370645a8ff62f2e102ffeaa1a6ca84eff05a347a76ac544e9efe287119220fadf6e866f58b7fa5482a1872d65f1c5d10ad97f6506f70800664b3cbb056148d3f7c669d02bcfacb3e0796c16cb5634d6a4ded258fe3618c5152ef6977d1adc2daf86b872af35e18d734f00c45d0945c2719c3447db1824d55127766abbf4223e20d08c0e382ba7e6ba5a97e0cfd2616efbb8faea18267bac930292f7023d235df00f788c47878a682b23b08a1c243dc3163994554f327e82d1901b2b81e73c9439a6bf69c9dd26941008f6aa6d831f14682ffe870e384a8e512e05e597a8f98c4881aa75607a01310a54a89dac77f35a2d4fbebb40e8341c59fd2d365ee87ccd4fb5cc2397db2acc7741c6c7d26dff6bb54542fb647c8aa5a1ee181a97bfecc464aacf13a9dc34cc96dbe58a91a0833c4b2e80078d61240841d4dd2f95ddb05bad35b233dc7af1c4c5a78b5fa1e494dd3feb8d7c1f24ead3d387f3633ad6f73071a02a9e997abcc1ac6447691c87eda98ff08a7e3974d31d556901e71d2d22fd04defe1477ba7fbf3f3b51c6084870966f15c373b1ce9325793b6fb2ad1f001f5bf4d5d10f48aae6ffcb8da5326b0f3f0cc7f1efbdf62cd85cd6d33af35303caa9b7dd0f20388437884fc23a1af3e387eddfad0ade05c0e47a23d35e6c98b6837ad6a30bcc2f8cab4b8e42f41acb4ca31d0c487283c020e42305853b40ee42c7c38dc902ff7b04f220655d04d77b644c77c648134127b390b90204f6c4e9e2c12b9bae3aa66fcad6697004e82901c2da7781d31f5fa35c30855092be38fd51ea4b5412b742896628baa618e3db4faf388fee7928bc64dab00c0e00072acaee24dc61ff4410a433f2a0c34531d4878f2083f9977684190a41e6581972ef9d4453a89dcbeeb8a7a64d952bcf26771be4d7dd8176c70428a4416a2cbbfed5248e986d1bc86e4b81abf92fdbcafc65bad2fd8752be386c8fce2ec1a71962f3a96fe59a38377f641af9689b4ea7bc484effe1ec6f0f2e2419c42705cc617411af2727efed5b19cd7fb7dc9656c0bc2e9862e7b18590eb7f2f52839afcd8309546ac860d36f490d60564338433fb060ac283cbc693e21048c4e11f132f90972fd4ca26031559833bdd99cb38b685288e7de606b0ba7c242d1ed6ab9140dc571fdb0dd6a07fc415c3d73718b6093e969c188d80fceb4cf4dc186c3755e467ea8d5d9a18c031c8949e1d5794c4195831ac90f2f140180f8039b731b272936fdac6dfb4c912613ad95c6e47bdf7bc43ae7f5177304efa95ca6df1cd31e1d72077871e0d0b977e80fc849c8bc70d89efa3402a14dd11b25ea9556136d55d9bba88e4b54fe52a783db4fa402553c426c06ed94693919df10e4dd5c99ea71cf44e2e6647e4ba89fd6576e0305216341a1d62cfdf4acd06aae93c8935a9c23049a31fa71df371e79931f2bfd77e81c3060e1782bf1faa3cd7e791cabb97ea186e03c154ca73fbdd00d31c60270a2f35353f364769be12083d3beef3e4dd79edf1e2833d80b144778f57a0cc02506b7d51af1e0a44fcd49e2dc1812344e09f2fe731d8f94975deb7722af14cfa6ac713c86877a802f1eba7d01aa756cfbdd87b451563c8fc547d9cc2aee8986c78ea72140cd3d92a0c082d34a1c3f80c076a59c3a406094760d5f16f439ea6ea7009d1a340f7df8339989b0616b8ff596cd7bfc6bff39a62afe781a41ac47210a906e47d9bf1c4e1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相信未来</title>
      <link href="/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/"/>
      <url>/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<p><em>作者：食指</em></p><p>当蜘蛛网无情地查封了我的炉台，</p><p>当灰烬的余烟叹息着贫困的悲哀，</p><p>我依然固执地铺平失望的灰烬，</p><p>用美丽的雪花写下：相信未来。</p><p>​    </p><p>当我的紫葡萄化为深秋的露水，</p><p>当我的鲜花依偎在别人的情怀，</p><p>我依然固执地用凝霜的枯藤，</p><p>在凄凉的大地上写下：相信未来。</p><p>​    </p><p>我要用手指那涌向天边的排浪，</p><p>我要用手掌 那托起太阳的大海，</p><p>摇曳着曙光那支温暖漂亮的笔杆，</p><p>用孩子的笔体写下：相信未来。</p><p>​    </p><p>我之所以坚定地相信未来，</p><p>是我相信未来人们的眼睛——</p><p>她有拨开历史风尘的睫毛，</p><p>她有看透岁月篇章的瞳孔。</p><p>​    </p><p>不管人们对于我们腐烂的皮肉，</p><p>那些迷途的惆怅，失败的苦痛，</p><p>是寄予感动的热泪，深切的同情，</p><p>还是给以轻蔑的微笑，辛辣的嘲讽。</p><p>​    </p><p>我坚信人们对于我们的脊骨，</p><p>那无数次地探索、迷途、失败和成功，</p><p>一定会给予热情、客观、公正的评定，</p><p>是的，我焦急地等待着他们的评定。</p><p>​    </p><p>朋友，坚定地相信未来吧，</p><p>相信不屈不挠的努力，</p><p>相信战胜死亡的年轻，</p><p><strong>相信未来，热爱生命。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 877 (Div. 2)</title>
      <link href="/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/"/>
      <url>/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1838">Codeforces Round 877 (Div. 2)</a></p><h5 id="A-Blackboard-List"><a href="#A-Blackboard-List" class="headerlink" title="A. Blackboard List"></a>A. Blackboard List</h5><p><strong>题意：</strong></p><p>​    给定包含两个数字的初始，然后进行 <script type="math/tex">n-2</script> 次操作，每次操作从序列中取出两个数字（不能取同一个），将其差之绝对值加入序列，最终得到一长度为 <script type="math/tex">n</script> 的序列。</p><p>​    现给定最终序列（乱序）， 求最初始数字之一。</p><p><strong>题解：</strong></p><p>​    由于新加入数字必为非负数，因此序列中的负数必定是初始数字。</p><p>​    若全为非负数，由于 <script type="math/tex">|a-b|\leq|a|</script> 且 <script type="math/tex">|a-b|\leq |b|</script> ，因此最大数字必为初始数字。</p><h5 id="B-Minimize-Permutation-Subarrays"><a href="#B-Minimize-Permutation-Subarrays" class="headerlink" title="B. Minimize Permutation Subarrays"></a>B. Minimize Permutation Subarrays</h5><p><strong>题意：</strong></p><p>​    给定一 <script type="math/tex">n</script> 的排列。交换两数字的位置，使得交换后序列中，能够成排列的连续子序列数目最少。</p><p><strong>题解：</strong></p><p>​    <script type="math/tex">1</script> 与 <script type="math/tex">2</script> 之间夹 <script type="math/tex">n</script> ，这样能够使得数目恒为 <script type="math/tex">1</script> ，是为最少。讨论即可</p><h5 id="C-No-Prime-Differences"><a href="#C-No-Prime-Differences" class="headerlink" title="C. No Prime Differences"></a>C. No Prime Differences</h5><p><strong>题意：</strong></p><p>​    将 <script type="math/tex">n*m</script> 之内的正整数排成一个 <script type="math/tex">n*m</script> 矩阵，使得矩阵中任意两相邻元素差值的绝对值不为素数。</p><p><strong>题解：</strong></p><p>​    先考虑 <script type="math/tex">m\geq 5</script> 时，将 <script type="math/tex">\{0, 1*n, 2*n, 3*n, ... (m-1)*n\}</script> 排成一列。以下是一种合适的构造方法。</p><p>​    设 <script type="math/tex">p=\lfloor \frac{m-1}{2}\rfloor</script> 考虑两个序列 </p><script type="math/tex; mode=display">\{0, 1*n, 2*n, ...p*n \} \\\{(p+1)*n, (p+2)*n, ... (m-1)*n\}</script><p>​    然后将两序列合成（下面序列的元素依次插入上面序列的空隙）。</p><p>​    若 <script type="math/tex">m=4</script> ，则可构造为 <script type="math/tex">\{1*n, 3*n, 0, 2*n\}</script></p><p>​    设该序列为 <script type="math/tex">A</script> ，则最终矩阵可构造为 <script type="math/tex">p_{i, j}=i+A_j</script></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">4</span>) &#123;</span><br><span class="line">        add[<span class="number">0</span>] = n;</span><br><span class="line">        add[<span class="number">1</span>] = <span class="number">3</span> * n;</span><br><span class="line">        add[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        add[<span class="number">3</span>] = <span class="number">2</span> * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) cout &lt;&lt; i + add[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Bracket-Walk"><a href="#D-Bracket-Walk" class="headerlink" title="D. Bracket Walk"></a>D. Bracket Walk</h5><p><strong>题意：</strong></p><p>​    一括号序列，从最左侧出发可以随意向左右移动（不超边界），最终停在最右侧。途经符号构成一括号序列，若该括号序列合法，则称原序列 walkable 。</p><p>​    现给定一括号序列 <script type="math/tex">s</script> ， <script type="math/tex">q</script> 次单点修改，要求求出每次单点修改后，序列是否 walkable 。</p><p><strong>题解：</strong></p><p>​    walkable 的必要条件首先是长度 <script type="math/tex">n</script> 为偶数。</p><p>​    其次构造一序列 <script type="math/tex">A</script> ，包含所有的 <script type="math/tex">i</script> ，使得</p><ul><li>$s_i=’)’$ 且 $i$ 为奇数</li><li><p>$s_i=’(‘$ 且 $i$ 为偶数</p><ol><li>若 <script type="math/tex">A</script> 为空，则显然圆括号序列为 $()$ 重复若干次，必定 walkable。</li><li>若 <script type="math/tex">A</script> 非空，其中最小数字为奇数，则意味着序列开头为 $()()()…())$ ，必定非法</li><li>若 <script type="math/tex">A</script> 非空，其中最大数字为偶数，则意味着序列末尾为 <script type="math/tex">(()()()</script> ，必定非法</li><li>剩余情况， <script type="math/tex">A</script> 中最小数字 $m$ 为偶数， 最大数字 $M$ 为奇数，则 $m, M$ 之间符号数为偶数，其中左右括号奇偶性相同。则在 $m-1,m$ 这两个位置产生足够多的 $((….$ 来消除右侧的 $)$，然后在$M,M+1$ 两个位置产生对应数量的 $))$ 补齐即可。合法。</li></ol></li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;str](<span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="built_in">return</span> ((str[p - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) ^ (p &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) s.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2 9</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; pos;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(pos)) s.<span class="built_in">erase</span>(pos);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">insert</span>(pos);</span><br><span class="line">        str[pos - <span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span> + <span class="string">&#x27;)&#x27;</span> - str[pos - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*s.<span class="built_in">begin</span>() &amp; <span class="number">1</span>) || !(*s.<span class="built_in">rbegin</span>() &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-Count-Supersequences"><a href="#E-Count-Supersequences" class="headerlink" title="E. Count Supersequences"></a>E. Count Supersequences</h5><p><strong>题意：</strong></p><p>​    求满足以下条件的 <script type="math/tex">b</script> 序列个数：</p><ul><li>$b$ 序列含 $m$ 个正整数，所有数字均在 $[1,k]$ 内</li><li>$b$ 序列删去若干个数，顺序不变，可以得到 $a$ 序列</li></ul><p><strong>题解：</strong></p><p>​    考虑 <script type="math/tex">dp</script></p><p>​    <script type="math/tex">f[i][j]</script> 表示含 <script type="math/tex">i</script> 个正整数删去后可得到长度为 <script type="math/tex">j</script> 的 <script type="math/tex">a</script> 序列前缀的序列数，则有如下转移方程：</p><script type="math/tex; mode=display">f[i][j]=\begin{cases}f[i-1][j-1]+(k-1)*f[i-1][j],\ j<n \\f[i-1][j-1]+k*f[i-1][j], \ j=n\end{cases}</script><p>​    发现该转移方程与 <script type="math/tex">a</script> 无关。</p><p>​    因此将 <script type="math/tex">a</script> 序列设为 <script type="math/tex">n</script> 个 <script type="math/tex">1</script> ，然后作差法。</p><p>​    最终答案为：</p><script type="math/tex; mode=display">k^m-\sum_{i=0}^{n-1}\binom{m}{i}(k-1)^{m-i}</script><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">auto</span> quick_pow = [&amp;mod](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">            a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">quick_pow</span>(k, m);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans -= <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>(k - <span class="number">1</span>, m - i) % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        ans += mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * (m - (i+<span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>((i+<span class="number">1</span>), mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/2023/07/04/README/"/>
      <url>/2023/07/04/README/</url>
      
        <content type="html"><![CDATA[<p>本站采用 hexo 架构，部署在 github pages 上，采用 github 作为图床。建议在能够流畅访问 github 的网络环境下浏览。</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307042122433.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 150 (Div. 2)</title>
      <link href="/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/"/>
      <url>/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1841">Educational Codeforces Round 150 (Rated for Div. 2) </a></p><h5 id="A-Game-with-Board"><a href="#A-Game-with-Board" class="headerlink" title="A. Game with Board"></a>A. Game with Board</h5><p><strong>题意：</strong></p><p>​    给定初始序列为 <script type="math/tex">n</script> 个 <script type="math/tex">1</script> ，两人轮流行动，每次可以选择序列中若干个相同的数，剔除，并将他们的和加入序列。第一位无法行动的一方获胜。假设二人都绝对聪明，试问先手是否必胜。</p><p><strong>题解：</strong></p><p>​    分类讨论一下：</p><ul><li>$2\leq n \leq 4 $，有限轮模拟易得后手必胜。</li><li>$n\geq5$ ，则先手取 $n-2$ 个 $1$， 后手只能取 $2$ 个 $1$ ， 之后序列变为 $\{n-2, 2\}$ ，故先手必胜。</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-Ranom-Numbers"><a href="#C-Ranom-Numbers" class="headerlink" title="C. Ranom Numbers"></a>C. Ranom Numbers</h5><p><strong>题意：</strong></p><p>​    A, B, C, D, E 分别代表 <script type="math/tex">1, 10, 100, 1000, 10000</script> 。给定一由大写字母 ABCDE 组成的串，对于某一字符，若字符串后方有严格大于它的字符，则符号为负，否则为正。字符串权值为所有字母乘上符号的权值之和。</p><p>​    现可以修改至多一字符，求可能的最大权值。</p><p><strong>题解：</strong></p><p>​    据说 DP 和贪心均可，这里思路是 DP 。</p><p>​    为了方便起见，先将字符串反转，规则也对应修正。</p><p>​    然后设计状态： <script type="math/tex">F[i][j][0/1]</script> 代表到第 <script type="math/tex">i</script> 位，目前前缀最大值为 <script type="math/tex">j</script> ，且已经/未修改的最大权值。 <script type="math/tex">i</script> 这一位用滚动数组滚掉，然后枚举状态的转移即可。</p><p>​    复杂度 <script type="math/tex">O(nMK)</script> ，其中 <script type="math/tex">M=5, K=2</script> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> f[<span class="number">2</span>][<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[<span class="number">0</span>][i][<span class="number">0</span>] = f[<span class="number">0</span>][i][<span class="number">1</span>] = -inf;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">        p ^= <span class="number">1</span>;</span><br><span class="line">        q ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[p][i][<span class="number">0</span>] = f[p][i][<span class="number">1</span>] = -inf;</span><br><span class="line">        <span class="type">int</span> x = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;   <span class="comment">//i-1位前缀最大</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) &#123;   <span class="comment">//</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">5</span>; y++) &#123;</span><br><span class="line">                    <span class="type">int</span> nt = t + (y != x);</span><br><span class="line">                    <span class="type">int</span> nj = <span class="built_in">max</span>(y, j);</span><br><span class="line">                    <span class="keyword">if</span> (nt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        f[p][nj][nt] = <span class="built_in">max</span>(f[p][nj][nt], f[q][j][t] + (y == nj ? digit[y] : -digit[y]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">0</span>]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Pairs-of-Segments"><a href="#D-Pairs-of-Segments" class="headerlink" title="D. Pairs of Segments"></a>D. Pairs of Segments</h5><p><strong>题意：</strong></p><p>​    给定 <script type="math/tex">n</script> 条线段，用区间表示 <script type="math/tex">[l,r]</script> 。若 <script type="math/tex">n</script> 为偶数，且可以将 <script type="math/tex">n</script> 条线段分为 <script type="math/tex">\frac{n}{2}</script> 对， 每一对线段相交， 不成一对的线段相交，则称其 <strong>beautiful</strong> 。现问至少删去多少线段，使得剩下的线段可以 <strong>beautiful</strong> 。</p><p><strong>题解：</strong></p><p>​    <script type="math/tex">n</script> 比较小。一开始以为是 <script type="math/tex">dp</script> 但怎么都消除不了后效性。实际解法是——直接暴力。</p><p>​    首先考虑两对线段，共四条。不成对线段不相交的等价条件可以表示为： 成对线段取并集，所得两条线段不相交。</p><p>​    因此可以直接求出 <script type="math/tex">C_n^2</script> 对线段中，相交对的并集。然后找出尽量多的并线段，使其互不相交即可。互不相交可以天然保证每条线段至多用了一次。求不相交线段数目，这里用了动态开点线段树。</p><p>​    复杂度 <script type="math/tex">O(n^2logn)</script> 。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> lc[N &lt;&lt; <span class="number">4</span>], rc[N &lt;&lt; <span class="number">4</span>], dat[N &lt;&lt; <span class="number">4</span>], cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">    dat[p] = <span class="built_in">max</span>(dat[p], val);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid) <span class="built_in">update</span>(lc[p], l, mid, k, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || u &gt; v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(lc[p], l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(rc[p], mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">Line</span>(n);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; Uline;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; Line[i].first &gt;&gt; Line[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a.first, b.first) &lt;= <span class="built_in">min</span>(a.second, b.second);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> uni = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="built_in">min</span>(a.first, b.first), <span class="built_in">max</span>(a.second, b.second));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(Line[i], Line[j])) <span class="keyword">continue</span>;</span><br><span class="line">            Uline.<span class="built_in">pb</span>(<span class="built_in">uni</span>(Line[i], Line[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(Uline.<span class="built_in">begin</span>(), Uline.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Uline) &#123;</span><br><span class="line">        <span class="type">int</span> rem = <span class="built_in">query</span>(rt, <span class="number">-1</span>, inf, <span class="number">-1</span>, line.first - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">update</span>(rt, <span class="number">-1</span>, inf, line.second, rem + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rem + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - (ans &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h5 id="E-Fill-the-Matrix"><a href="#E-Fill-the-Matrix" class="headerlink" title="E. Fill the Matrix"></a>E. Fill the Matrix</h5><p><strong>题意：</strong></p><p>​    给定一 <script type="math/tex">n*n</script> 的矩阵，其中第 <script type="math/tex">i</script> 列的第 <script type="math/tex">1-a_i</script> 行为黑格， <script type="math/tex">a_i-n</script> 行为白格，仅白格可以填数。当一个格填数 <script type="math/tex">x</script> 且其正右侧格填数 <script type="math/tex">x+1</script> 时，贡献一 beauty 。填入 <script type="math/tex">1-m</script> 共 <script type="math/tex">m</script> 个数，求最大 beauty 值。</p><p><strong>题解：</strong> </p><p>​    看起来似乎比其他几道好想很多。上层所有线段都是下层线段的子集，因此从最底层线段开始枚举，填数，分裂即可。</p><p>​    这里还是用的线段树。注意细节。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dat[N &lt;&lt; <span class="number">2</span>], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>) (dat[p] = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    dat[p] = <span class="built_in">min</span>(dat[p &lt;&lt; <span class="number">1</span>], dat[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = N;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>, l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">pos</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] = n - a[i];</span><br><span class="line">        pos[a[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos[i] 值为i的位置集合(补上界n+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pos[i].<span class="built_in">pb</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(pos[i].<span class="built_in">begin</span>(), pos[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r, pre_min;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre_min) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">pre_min</span>(pre_min) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node X) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l &lt; X.r - X.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ask(l, r) ask(1, 1, n, l, r)</span></span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">1</span>, n, <span class="number">0</span>));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p.l == p.r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> min_num = <span class="built_in">Ask</span>(p.l, p.r);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>) &gt; m) &#123;</span><br><span class="line">            ans += (m / (p.r - p.l + <span class="number">1</span>) * (p.r - p.l)) + <span class="built_in">max</span>(<span class="number">0ll</span>, m % (p.r - p.l + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m -= <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>);</span><br><span class="line">            ans += <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l);</span><br><span class="line">            <span class="type">int</span> L = std::<span class="built_in">lower_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.l) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> R = std::<span class="built_in">upper_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.r) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> pre_l = p.l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt; R; pre_l = pos[min_num][i] + <span class="number">1</span>, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre_l &lt; pos[min_num][i]) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, pos[min_num][i] - <span class="number">1</span>, min_num));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre_l &lt;= p.r) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, p.r, min_num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 879 (Div. 2)</title>
      <link href="/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/"/>
      <url>/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1834">Codeforces Round 879 (Div. 2)</a></p><p>难度适中，但菜鸡依旧。</p><h6 id="B-Maximum-Strength"><a href="#B-Maximum-Strength" class="headerlink" title="B. Maximum Strength"></a>B. Maximum Strength</h6><p><strong>题意：</strong></p><p>​    <script type="math/tex">[l,r]</script> 之间选两个数，使得十进制表示下各个位数的差值绝对值之和最大，位数不同则较小数补前导 <script type="math/tex">0</script> 对齐。</p><p><strong>题解：</strong></p><p>​    设 <script type="math/tex">l</script> 和 <script type="math/tex">r</script> 位数分别为 <script type="math/tex">n</script> 和 <script type="math/tex">m</script> ，取的数字为 <script type="math/tex">x<y</script> ，分情况讨论。</p><ul><li>若 <script type="math/tex">n<m</script> ，则最优情况为 <script type="math/tex">x</script> 取 $m-1$ 个 <script type="math/tex">9</script> , <script type="math/tex">y</script> 保留 <script type="math/tex">r</script> 的最高位，剩余位为 <script type="math/tex">0</script></li><li>若 <script type="math/tex">n=m</script> ，则除去相同前缀，然后 <script type="math/tex">y</script> 保留最高位，剩余位为 <script type="math/tex">0</script> ， <script type="math/tex">x</script> 保留最高位，剩余位为 <script type="math/tex">9</script> 即可。</li></ul><p><strong>code：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    n = s1.length();</span><br><span class="line">    m = s2.length();</span><br><span class="line">    if (n &lt; m) &#123;</span><br><span class="line">        cout &lt;&lt; (s2[0] - &#x27;0&#x27;) + (m - 1) * 9 &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (s1[i] == s2[i]) continue;</span><br><span class="line">            cout &lt;&lt; s2[i] - s1[i] + (n - i - 1) * 9 &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="C-Game-with-Reversing"><a href="#C-Game-with-Reversing" class="headerlink" title="C. Game with Reversing"></a>C. Game with Reversing</h6><p><strong>题意：</strong></p><p>​    给定两等长串 <script type="math/tex">S</script> 和 <script type="math/tex">T</script> ， Alice 和 Bob 轮流操作。Alice 每次可以替换一个字符，Bob 每次可以翻转一个串， 当两串相同时，停止操作。Alice 希望操作次数尽量少， Bob 希望操作次数尽量多， 求两个人都采取最优策略的情况下，实际游戏操作次数。</p><p><strong>题解：</strong></p><p>​    解释起来比较啰嗦，这里简述。    </p><p>​    实际上 Bob 每轮操作都是相同的，因此可以假设 Bob 只翻转一个字符串 <script type="math/tex">T</script> 。</p><p>​    对 Alice 来说，则可以有两种选择，将 <script type="math/tex">S</script> 变为 <script type="math/tex">T</script> 或 <script type="math/tex">rev(T)</script> 。二者最小步数都容易 <script type="math/tex">O(n)</script> 求出。 最后根据实际的奇偶性补齐 Bob 的操作数即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    int ans1 = 0, ans2 = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (s1[i] != s2[i]) ++ans1;</span><br><span class="line">        if (s1[i] != s2[n - i - 1]) ++ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ans1 &amp; 1) ans1 = ans1 * 2 - 1;</span><br><span class="line">    else ans1 = ans1 * 2;</span><br><span class="line">    if (ans2 &amp; 1) ans2 = ans2 * 2;</span><br><span class="line">    else if (ans2 == 0) ans2 = 2;</span><br><span class="line">    else ans2 = ans2 * 2 - 1;</span><br><span class="line">    cout &lt;&lt; min(ans1, ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="D-Survey-in-Class"><a href="#D-Survey-in-Class" class="headerlink" title="D. Survey in Class"></a>D. Survey in Class</h6><p><strong>题意：</strong></p><p>​    给定若干条线段，求最大分数差值。</p><p><strong>题解：</strong></p><p>​    对于线段 <script type="math/tex">[l_1, r_1]</script> 和线段 <script type="math/tex">[l_2,r_2]</script> ，设 <script type="math/tex">r_1<r_2</script> ，则分三种情况讨论：</p><ul><li><script type="math/tex">r_1<l_2</script> ，则最大差值可以分别来源于两线段整段，即 <script type="math/tex">max(r_1-l_1+1, r_2-l_2+1)</script> ；</li><li><script type="math/tex">l_1\leq l_2\leq r_1 \leq r_2</script>，则最大差值来源于二者分别对交集取补，即 <script type="math/tex">max(r_2-r_1, l_2-l_1)</script> ；</li><li><script type="math/tex">l_2\leq l_1 \leq r_1 \leq r_2</script> ，包含关系，最大差值来源于长线段对短线段取补，即 <script type="math/tex">(r_2-l_2+1)-(r_1-l_1+1)</script> 。</li></ul><p>​    将每条线段按右端点排序，枚举线段 <script type="math/tex">[l_2,r_2]</script> ， 目标是找出对应的 <script type="math/tex">[l_1, r_1]</script> ， 三种情况分别需要求：</p><ul><li>右端点小于 <script type="math/tex">l_2</script> 的直线中，<script type="math/tex">r-l+1</script> 的最大值</li><li>相交直线中， <script type="math/tex">r</script> 的最小值以及 <script type="math/tex">l</script> 的最小值</li><li>左端点大于等于 <script type="math/tex">l_2</script> 的直线中， <script type="math/tex">r-l+1</script> 的最小值</li></ul><p>​    四个值四棵动态开点线段树维护即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x7fffffff</span><br><span class="line">int cnt = 0;</span><br><span class="line">const int N = 4e5 + 5;</span><br><span class="line">int dat[N &lt;&lt; 5], lc[N &lt;&lt; 5], rc[N &lt;&lt; 5];</span><br><span class="line"></span><br><span class="line">void update(int &amp;p, int l, int r, int k, int val) &#123;</span><br><span class="line">    if (!p) p = ++cnt, dat[p] = inf;</span><br><span class="line">    if (l == r) return (void) (dat[p] = min(dat[p], val));</span><br><span class="line">    int mid = l + r &gt;&gt; 1;</span><br><span class="line">    if (k &lt;= mid) update(lc[p], l, mid, k, val);</span><br><span class="line">    else update(rc[p], mid + 1, r, k, val);</span><br><span class="line">    dat[p] = inf;</span><br><span class="line">    if (lc[p]) dat[p] = min(dat[p], dat[lc[p]]);</span><br><span class="line">    if (rc[p]) dat[p] = min(dat[p], dat[rc[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int query(int p, int l, int r, int u, int v) &#123;</span><br><span class="line">    if (!p) return inf;</span><br><span class="line">    if (u &lt;= l &amp;&amp; r &lt;= v) return dat[p];</span><br><span class="line">    int mid = l + r &gt;&gt; 1, res = inf;</span><br><span class="line">    if (u &lt;= mid) res = min(res, query(lc[p], l, mid, u, v));</span><br><span class="line">    if (v &gt; mid) res = min(res, query(rc[p], mid + 1, r, u, v));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123;</span><br><span class="line">    return A.second == B.second ? A.first &lt; B.first : A.second &lt; B.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">#define mp(x, y) make_pair(x, y)</span><br><span class="line">    int t1 = 0, t2 = 0, t3 = 0, t4 = 0;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;pair&lt;int, int&gt; &gt; Stu(n);</span><br><span class="line">    for (int i = 0, l, r; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        Stu[i] = mp(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Stu.begin(), Stu.end(), cmp);</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (auto stu: Stu) &#123;</span><br><span class="line">        int l = stu.first, r = stu.second;</span><br><span class="line">        int rem;</span><br><span class="line">        rem = -query(t1, 0, m, 0, l - 1);</span><br><span class="line">        if (rem != -inf) ans = max(ans, max(rem &lt;&lt; 1, (r - l + 1) &lt;&lt; 1));</span><br><span class="line">        update(t1, 0, m, r, l - r - 1);</span><br><span class="line"></span><br><span class="line">        rem = query(t2, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (r - rem) &lt;&lt; 1);</span><br><span class="line">        update(t2, 0, m, r, r);</span><br><span class="line"></span><br><span class="line">        rem = query(t3, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (l - rem) &lt;&lt; 1);</span><br><span class="line">        update(t3, 0, m, r, l);</span><br><span class="line"></span><br><span class="line">        rem = query(t4, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, ((r - l + 1) - rem) &lt;&lt; 1);</span><br><span class="line">        update(t4, 0, m, l, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-MEX-of-LCM"><a href="#E-MEX-of-LCM" class="headerlink" title="E. MEX of LCM"></a>E. MEX of LCM</h5><p><strong>题意：</strong></p><p>​    题如其名。给定 <script type="math/tex">n</script> 个数，则对应的有 <script type="math/tex">C_n^2</script> 个连续子序列。求所有子序列数值 <script type="math/tex">lcm</script> 的 <script type="math/tex">Mex</script> 。</p><p><strong>题解：</strong></p><p>​    同样是利用好值域。 对于区间 <script type="math/tex">[l,r]</script> ，固定住右端点 <script type="math/tex">r</script> ，则至多还剩下 <script type="math/tex">r</script> 个左端点，对应 <script type="math/tex">r</script> 个区间。这 <script type="math/tex">r</script> 个区间有多少 <script type="math/tex">lcm</script> 值？从 <script type="math/tex">l=r</script> 开始，每次向左添加一个数， <script type="math/tex">lcm</script> 要么不变， 要么至少翻一倍，因此 <script type="math/tex">lcm</script> 值的数目是 <script type="math/tex">log</script> 级别的。因此整个序列所有 <script type="math/tex">lcm</script> 值的数目不超过 <script type="math/tex">nlogn</script> ，迭代求出然后求 <script type="math/tex">Mex</script> 即可。复杂度 <script type="math/tex">O(nlogn)</script></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / __gcd(x, y) * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1ll</span> * n * n + <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; num[i];</span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; s;<span class="comment">//以r-1为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; rem; <span class="comment">//以r为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; ans;<span class="comment">//所有lcm序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: num) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">lcm</span>(y, x);</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= inf) rem.<span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        rem.<span class="built_in">insert</span>(x);</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: rem) s.<span class="built_in">insert</span>(y);</span><br><span class="line">        rem.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) ans.<span class="built_in">insert</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = <span class="number">1</span>;</span><br><span class="line">    ans.<span class="built_in">insert</span>(inf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != now) &#123;</span><br><span class="line">            cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数理思维</title>
      <link href="/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/"/>
      <url>/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h6 id="一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。"><a href="#一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。" class="headerlink" title="一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。"></a>一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。</h6><p>​    在数理逻辑论证推理中，务必做到毫无破绽。防范”千里之堤，溃于蚁穴“的局面。更直观地来说，论证必须有从底层起始的依据。</p><p>​    在日常生活中，这一条也同样适用。我们处在一个信息爆炸的时代，很多时候困扰我们的并不是信息资源的匮乏，而是信息茧房的拘束以及信息泛滥的迷茫。保持理性，对信息加以筛选，过滤掉无依据的信息。</p><h6 id="二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。"><a href="#二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。" class="headerlink" title="二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。"></a>二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。</h6><p>​    比较典型的分而治之思想。当整体带有规律性时，局部往往也具有与整体相同或相似的规律性，通过不断地划分，最终将问题转化为一个个显然或已解决的子问题。从个别、特殊到一般的方法。</p><h6 id="三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。"><a href="#三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。" class="headerlink" title="三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。"></a>三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。</h6><p>​    从易到难，从简单到复杂地进行分析、解决，而不至于迷乱。</p><h6 id="四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”"><a href="#四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”" class="headerlink" title="四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”"></a>四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”</h6><p>​    如其所言，思维缜密，考虑周全，确保推理覆盖到所有情况。</p><p>摘自： 笛卡尔 《方法论》</p><p>​    </p><p>​    </p><p><code>人生没有目的，只有过程，所谓的终极目的是虚无的。——人的情况和树相同。它愈想开向高处和明亮处，它的根愈要向下，向泥土，向黑暗处，向深处，向恶——千万不要忘记。我们飞翔得越高，我们在那些不能飞翔的人眼中的形象越是渺小。</code></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT 指北</title>
      <link href="/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/"/>
      <url>/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0b9628033c767bbf3aa9fee6487070856f5e148fa15f92e5f20f8eb5d8b0b88b">578d5c17fdb0be81f91dae08d76a8b9d310fe713a3967a08677820d492351d4d8db2ce40c3d8dab35779bf2fde14fa61c200e4156e98e199d65a4f6ec1aee5b9815b7e5e19294072fc6ca00bfdcfe1fdc03e417f1adb72afa06d680da541c738197ab655a1e49104eb77ef86810c9e98c936e71ca104e1468987a8c1e4b1296836fc3d4145db7d9fa4c464b5166fff91038e2df137e5865cd29aa5865e803bebe454cc244e72f408e32aeaeecae74074129952ce099bad2b1987eb5a86827dca7852c842cdc14eb9cb8266b8774b394f73c82ffd15441a66c402a27690d2352201cf129e86dadc27dbce48b9701822060af5d9f46cfad7e9a8bacdd9a487b6ba370c023ae61299c46c8b7f9cc4100e59a0c098d1bca096af391e03cbffd11680904121495a7e928ae1b3a572bd196bf307fd8e815440b15142cd0832f0b8e8ecad8f412613938a1a65d7f435cea3376f4717de8683ef1b9f573173c119169384e2071082ad17830d107bfdde9c46f44e4105a5a231bcac34b7f4c9d13a3041ea222256429263941c7aa50e1c238a49960c3c8d56e5ff8b29ba2f8c5129f7616b3ad065cd14acd62ed7699f53937ecd023a0d56bd295b45f263c1ee4f8b9426acd1ca77ae4ec2e922b18fee7c29cccd302426ec247fcd95e8650ec9ba580132dfe01dafc3882097b69a72e9472006bf33438a2b347e6fede1c44aa5d8255cef135c08e327f34a621531aa0b83f0c31b5669e24e0250798e3290b7e08de1de4c4f8554d08424e681a69f844a268ff59b9600a4122880760bb56642ccfc16bbd7b6fe5ac62e500220531706b6a9434298adaaa7c2c75b7f93ebfecb6534894df6f477bdde4f5bb44b1316fbd1cbafce529a9cfe14a130b2ef47140dfa3090ab6fa312274a67f661ce4d4b178cf9a5141d43adc3efb3bb0ad68bf1f682f19398b75d56ffb3de87e1c3dfc138195f9c436ef370e92fd57e54d8b22972c3bc7e3f068cc7ae5841ef8d6f250c9c7d998b895528166573464185355ca11909ec3377912299fc2162fed0db073e1a201d52767c97db1d3691ccb5ea3e30286c6b9f7ac6dc75cda6a57b08ec6e4e19f29642591fd0822b4cc4a45bbe7317888fec0223836e2dc79789659561124fd9e17bfb8c96339a8714177c12f979324aaaafb93974e0eccf4df7aeffc5c405708064516b72cb1cd6c795c6453e532d7916015105dc29705393b7c3d729c8c4afb47fc8128e6532d4919de15ec86c9f023fc04194611851c481a03b828fc3c4230600b5d94bff38a8d323e8885fc584e9ac3978afeecf77d309827cd7fcbfcf3536adad3adbba9762f408660ad60bd6238bb5cbd2e5b8d0997dd13be89a954a208f8eefbc6d878cdf5b2a802ac0ec2cce1000a2d274f5e48c77630ae7e8ab81dd57dbd03d0582dadfba8437a8b4e68c135c696b0d4b37447e9d376d61bd19266ff0634809b387c047ee4c7f2b6b0c2f6f621de194b15a859201705ad40319d2e7d1a1c886b0ec12332d5a57fbb2ad9e2713164610232a6f5a82bde627fafbbdf02d2383a9cd3d9e107657f08a02b2a535a8f0fcbe2d358cc62c67472d7bb5d8649da262144c896eb621cbbc979a63fbf3ea44a928d154d5a6706b0b0ff534cd35db0d9702b0cbdea9d5f6a1290426f05c59c34500bf913d6dc39d319f80b5dff4030af7de7e32b5856afa9683d8e7eb7b46fef84735b9c8ff15152086081797da1c839ccb75cc97fef9c38fcbedc64f4b384a9a8e99c1f2b508de9cd6b8027c4e2743d1d422b9a0a57f46819294aeda4d783ef4668a5f808fb8c53811db3672853b8ae5ed2fa68f5e39d6638177543a7ec36295c24dbc2fe6821e2c04458eaf0e402077bd68e663bcbf90a32a4fd7e692c4ff0263a829b7004ab7d3d7800fb7f8e075c9c3a0aa21a3a79dc3f1c29e13ab66610208af1804abd5a3d451813c573ae3dc14bf9ef69226669f033074a0311681bc2d0d28588b08a9ac56ba7fe20d397567ef517e0121ef8d1ac29abd6f8169967329581b48a8ad121163b857e2ef4e3076d370d99903cf3d91532d284a1a4afb23949c3c1cb9836577a0499d0e4bab26deb85311e854b3f4de26346631a778a2fc33d875f9aaf68579875a69615e740e9eb79db16b3f9b389507063f2ca4ceca5186fd72b2f61ae0679e010a4bd38aa7bec34219ca15ad9e0856972ab65b704fa9bb383a396fb26b274103a8b3c39a1d1951d09168193f5266632332715663118cc0c29f400d0e7f24f77543d1875ce3744db7b50256ff8e96d3d23b3f499ef06cc7e940951be896d16ffd18cfde1c906a96b9d90b50c48d8a7bb5cd66c3d0884564078fb3cc0ac3a1d4c962ef390fdb7850786a61589e1ad6019b15ccec04d277fca0cd1197328498afc896797ba3d4864ac4b6dab9392e35e74702f5b8aab284749c305e4646729c8e971a91fc73f2b0865f76ed95ab5d28b99d97807367c7ea5850dce550640690c09284eb7421866bfda04389edc0fa90aaded37e7a3a0ca1ce6eca3f0018aa38439f2fa6200fdcb33f5644a2bd4b912eb4f13a254ac7cdea8f148018a93837c5b3e3666a14548b1cc8a6387c3cfbeb27ca56bdfac92550c86835cce802a1607d8a528dc42e2ff738b67a3a7b8c7ede62eb5ed3ae1f5107489db5467cf1444c1824545b78ff98de3ac89e68ded45fe73b1711e1015cb244f6046b0ad33cbcef218c4df747a694f84285b0ff7d4be7730386458de5df313c0c014b995495db0eeb7aef36155abfd2bd611931276c3efec28af0a0c7c56aed369ad3471856e710aefb4349af76c0766b28cb535f28771ab80f4fc1864592556ed3696e4328a6df82711fb5cfa31dc8c16ccfef7ee5541a12b9a53edf8cc5052994b27aeb74874835b838f41965388c005f8b2a418fc7fa680352f4e681126d936c56eb39efb30c53620a24f6a10f59dbb609a221eb37fdba065f4d865ad20c8c27c63112cc50a267c07ad06a02a1019a0917a94289bbcf66d7372258edbd758b3c266d18d73e008422a2e1d9a665feea94914f3521ce3fb306cc790e1a8d70a09983fa416b6b3485f17c876c6c7781ba7d50e75ea1ba3ab6dc6e33d9767acc7d171ddb3714cee5a8dfd48e1f4ebeea41d1bdb00864e0d9d1bb4b02345acd9f49f4c29516763288309332f9796e55bf06df916e225be7f837e0d7b2fc9ab8e19465666c9e6052cf130c00a9e591d0838cbb52ae686ea00a02e2f8366776f47c586961b77a0358127db76d6ca8829ea8f71df597a02f3e9092672828496a0347465fadc16b1bf933f6f817a5b2c798f5dbf02dedf18b60e89064a24bcba7afed522845eb60454a62d1ed21d70688d822419a9d71404c5db9df70d7c11f5b8e38e97f95da616b5de5e11005e7ad00bb6f38f856f4a5f5e151916c46c3ebbe6649602cba5c3b89d28a6120f354cd333e4d7e86e21b66ec10b4f4e0658464fbe2a4ccfc028d45ccf73a2be22f9edd950b91a094e709e60ac1368f356e3132eb2a4918b645bd0d249c9d1513761c9d1c3637ea4f9c4577914c6d24d8d6c84bc1e83b04c05a425ae7075c1fd30e9ccc2517af0c3b62e83731346b90d8b7f47d2f1da6556402350609d647312bd12db35f8a127e53632e3265c7492899e47b7b8833f39cbd49c51613eda73ad8819bd7dce8e1426a8e9bfa32bf52a0065312a14dd51985a779505b7404d32a797d98f95fe9a1388a9b3e9d19100a41c577457a64c84126f1b84055cd821ddc6aba117f1e0930e306ecb961e1a39c6b4b9be623dcf0311c975ee4a49a5942889221d5cf7dff6437e6926adb0fa98378c13cb215c8c91ec79b20522439165ec78e383b3a8091ae096d8df7601975fcfa2c550b431b820524561101ca84917b4a6e2d2adb3cd0792d99c80e2de4a78ecb9bd54b55106eb136c8e9a424772e638862b5337e84a14c7227573a3566ec9d281f68203ad3b8e90cbfe9743dd4112fc2cc1073b32b6fe51167419037dcb8fc0ddb0913fef6d17d3679ba7efc65551f48865fa2046c9be394855f9abb4a0710d24a89bbe284f5b209a0543bbe0b71cd5725125cb1398a6df3bfe2b26fbcb8b05554962fb0d17ca95c7b98cd1d5b06cd945c0ebb5f2cece52ca8b5be76ce577b9f9b315f598bdc09f251581e79420d193e87a717822a85ad0fa3d6e9cf820f7269f44fc70dfe48d0bafc577a14185e58e772811895febabc5adef518e0c6c1a432170b4881c971cd8bfbf7737f68c8d990881baa37ab44aaa526d5f8dd17a921fb8539e4e9c2530e99bc8cabf0e77ecb0b0b4dfb05e2519bcb19c7785f42878636ab11c1b47c375621b640d95270df167a1043012b91b5058750a1a9b7ef6bca3a178fcb893ee5a9c17f51be7398293a866a5ca81bb339de8d422db232be59ae3d725665ff686f7342e5da98ddfd79083428a8f61da8d3817877be2603e7bbc241b979dfc1314c7e6bdbc069174340652a6e598a22a32d63291b7984bf527dd8147ef1c9734f3505f92f5ab33934b035007b34480a6543c0d8b5c70694865d41237d52a3c6881fa9edcf9e86810234b6b1105689a0a19f502d6c79f0d9efba90a224cd82db8d85e1f1cf96ea39b0e70809555c6773f5a0593e64457c2ff0801235a179dd01408c419194395fe5a4ccfb3369510e626443aa52961c02f83590386bdea13b081de2b0cb23ec122375ccab6f29e5138ffd6d2215a549c9d7be3fe4b2963c51efff678c7fca3922a8c50896179396b9adeddfcdd69c1f8f67e91670bf87b52727187c390f3fcc27218986cbd62287fc2b16501d4f2a74b5166ac45f4fed6a4f445b93b2fc81702bfd8451b5c7f7a87ca2cd8b5f00c671f6f73a4ee8ca3b2ee18d40bf2e0c34725f9ab31b1f9d2c86ccb27a422938898d6807aea0e0cc52f7dddd69c5344c6d2a3ebc86b235dd7f8ff11b97436d28289f4df2011cc22af341b49b18181bc58fd24637b58d5408649549fe47da5fbff571009d5fd233d0b83dd1db7757435f42ca5de0229b0662cdad24cf151d3029e077e6e01d0f242c7cd3c8f0cce4f421b0e3e9c006c035ea53014ab9e31ec6b6f5d2b97aa085424aa307b09c4c676352cd04e880fa6d23b19a1be02c9bdd6d2d11c2040a538ffab8a4a0e153e05f27ba094b850cdec3e90e139f9943a3286cb1d4818ec05d868ade7e38bf515af1d32b67d0c7758f29793b5c74e8e05c59bf62e0e363899ebf1ec09aca77f32288c22e3a81ea67c501af545f946360519ae1e4c04715d9e43f5a23808607b6ad8f0aaa75cc886790d0e768bf3c5fe071f82f076e0af671788a6afbdae09e80fbcd31381bb66ab62c3e4e68e49413fce2304016fbbb9d62b5cab45eb74a7da55f333eea28462dc5b7ddd3660a0c6b6bcc4b6a66dec95227de79eee1ff5f747f9de98dffd867db8e6fd7e9adab0b178e41c9a3c66983e731bf0cca6aded587ab2930c34ca1ec969ae46ebbe10cb4b9d68c2e5fe45885e5afdd41eed5f71683daa99b3deea37e70497c3456c66b4ae4fa673377106c222a1aa3885d4b42d13f148242c9a5b772ae5b46dfb0966ea1531dfaa50d2b53dfb6af310f94cb052d7c7b1e5190f6f9dc2c8cc88cd26baca3e508eb456d09b51329832509e4ed0f5dcd9e125305f2cb217b6f77544255eb5edc7b8adda3a7a46053eb98b12507c78dedb4da56953d4be909bdaf8b9b8ebd95cbbc977b9cca80ecbcdc52c623029cea5330bf05a6e4fd45c55dfa8b6ab4c0991be52a87c5c4825d3c33e6b2af733f2461b2350f84b22090b4be6631235bec0657e43521235c60d40b91467539adcd45fdf41613e53c774cce7d99a28133f0ecba414231dce28f22e7e697b369e3178d7c13276444e55b44ca7c4687a4606191a92c8610809e5e147748b0f9429d1c0e38393c177dc05b66e411ebf76c6d10d09ee10d674c9b3556a606ccace20f0f110a3651c017e8b177a3cbe5f842b877cdee76912eac93b927fd8f3e72e7eb51d2fcc18d2183bdc564e9586730068e7e5a28af416dfa119f6292000ede457569dfb0e960e221563489e023a488393065bbe5f31ec1193f127b49e5e56132e13d41a51655ad0522920b1359518f93ef614c62335cb478551f4502225b62951fa24235fc83febd00d2445668800fbf7206683b9ecc4723a6bec539a24b1bb56a71caaa8a0101d0d26dc6c0cd9c02db46b41e803387bbebc6be9d31bcd1d182e177f78ae1410cf15d7b289178f383da68ac73f5b0c168ee5d78fb31b9ae861058a699dc84f89187041d5d9784d9f27b7effc632044f1ad65a494d855c7bef88688fbdf1833dcfd02e8f0623c01e606f41e94ec621d1f33b6e8a90e69a776d53698461c5ffef029c7bd5d65c5d0d5c8254c06d21cacfa6ca9b0a691a440046058e208528373c096e25ed0168cd04225e893b731c6824f4f0128d83fb43252f01f4aeb6e43978aa17bb7bf25f5424d364ff7892fe4837bd79230463624ead5a376995d4fb076d8f2d945b153201483396ddd7a4806629d1238411ad798c2256366918c3708b6b692ac01787f74902169ea08bea09e561a61926dcdd120050272a5a63e73298b8d725b53d9ed71692b8db11d8565ba85275d08d509ced3582dce1a120645285a8b5c35a2e764dd13894ba53772247b0a4a1ce7a65b18961591a78811ad71b4d262e887064e96f5a388c57e2fc234d54285b5b390902c045b07dbce837b1f780068cc992e08705cf633f85a50bce1b9bd211cf814e9ec987a7a08174d99da61c1c9ee232648f65cd2bf9547c704ef20fb4ad57028dc5ca19f4d7dc6a07a207c876493c4f2ff3f8dbe4f29bc1e3f0c9a350b4eb3962fe96754486fda4aa032fc1910278d3b4bcabc91247fcb5168c8f77a2034951180a9f0505f2cb0aafbe56fd5268227a6bd17548f768a668b8639b969761b2d86e349f24efbf1587423d472d6457d3631ab9b91a7ad309ffb4f01c37b50da074dce5e5ad52426ebf0511a8f31f517cdd556af6bc224f745d54d794511cd4dc98a69210d60f0caf9d40fe209b144f203af8485b4b8ed48e85db564b5956c831624f96e6783a141d661ed66bd918055ffba0f8363b6f587d409c369472ca1ff4f24e2166d284dc138a062aff48b6538a10aefe334002bb0c2c19ccaffda14b0f5478a7761d659443adf21ebeb51bf25b2f08091b352bd1a9b206c1ba55ce3eaab64d6815a3f4ad5b8565c59d06d4de64886e564fb32b21ef6ef976026765d2783cb37cab04bc8e73ce8344ba6690a1297a903b1be9e7d11189f8591bb8760119a487e4d1316f34263b0537edfcb3169a094ce64e82a8091941018813d52117214593937a540c26714e40048592a5ec6d6a7bbe293814322eea9773e00cc1a714d9c001d36d2e61019c248ea1977ec4c54dd7b161b4dcec69812bdb229e75531c4431e07ae7f5b49d407d00df2f7e54e68c6d6ecba93a817b6750a93efd3d28f89b146d0827870cb035f4c140c14bf15c77892dc97c51a1bea8bb12a3d72449a9febb584ef764348fcf4a5b2acd512e3ae814b3cbbcfdfe51d1f330b1e594227f730b01ca60cc834593ce2bcdc08b28a769ca7b5cafeab1acd74b970d08f90ae6388ea9fcfe4e8b1d4e7e86aeec5dbe0dddeac564fb372396aeb58fd06ace81b0ee4f2ee13105326df367c2cc74184581af73d542041a464ee44c94c024b80a4870af54ff33641b5daadd592d6e9ebbf29ef505cfcb6968b8a28ec77da263ec38983ae301a5a373be648518ae3eedf3decbc264a0de2e72ecdd75e25331a3a0b22fe0af91f0314c0d2c67b12d7239cab1d0874e7e5b887ba33ff7d46ad9469b84ea6a2d5231868ea75b0c3883f5fb41b009213dc99160bdbb584517dd478a2105f8324118c53e6ea057aaebef438861bbe4ee5a58b5c5072551b6ba224c8f00f1d077d6efde112fc034baad7e0ae05acfd7375712ad8349c9e8c3935eb9f1cb7ac3d8836af2fb0f86ad3e43e0957c4bec35dadb67c53d339e01eba36645d6847c6d68596a17cfdea24dc52493d5e3e7fb9bf735a2f8a110f962bea57cffdaf595fc973fd915cc512c49ef5d31257dbe8847531a05ea602006ac0784fb29b93efa6f763e913d7bfe1f8afdfac85983a13ceeca2f576946404738c3d5763c586dbd5ddea84b4d51181549e416d2c9bfeec85bee6413362479de9a4bde0deae3f2f135c8d2566fe3f79a652acfcc4569d68ec6b9906892f0828c5ffdc111e398b9d96f272cbcbaea7cd231796458d111fbcce579052eb395e92745f0e658b68f4fd5c8db7b5b664f780d9c2c39b6bb90b9eb3d889ef9d54d71f69622d8999b9984056e78b65104a1ded33de34ff2ec23799df91bbb118fd2d35c63b825168215be40d14b97a600f11f2acfa2a595ccad024d23d0f875b473f445821dbd4b54d60de8c72ad331bdeb49e323da4dda1d705cd9eeef0533e2c648c25bac263cae778eac4de13f19ba82396e374a489b310d4d41d2a7ec228943dacb2ef40a7b77a302794f2197d6e74403232f4eaca30e7c45e47bd864f20f5f139b56935a87d6d65b91b5f6310fa8368d92b64711820ec54b4ef0afa6ad52bc1663b600d94922c6446a5517a6c9591ff2d6d34b5a5ee0d83beae4253061aedaad5e9a09b18ca8b055269db0d7203d9b5f2518f5bf7964a60628c6e19d64546102efb9ff87c37a984b89fd2cceba013a8b6639707451a940725e291d22769944eca80f703e321ae951401a77bb278c1f95ed3918d5c6ffa9585601c1c985f832f13c1fc157383aaa9f02a3c8c3adecc2ee8ced7d153b04255893b2a6f76c7674e713c63db9699f7ea3d8724e3002a414ed41f945152f81aebbf8701ad0d352c953e0777f008c6073a2a5ee11a503cbd4e1d0cb76be0da9fa13216c571b9bd4e36fc7f343ea4ec1cd61701386da014aa8adad328b71c28a50a88ad5119a1ef841a44e368e75da6ca528d627e162f731abac031e6fb5c900c181c3f74f5f9abc5e86d6e8fb29c7d46dd94176a59dfc930f32db13f5d27eff529b973eef379381f9ab6537987b0b8d598676f8f27b3b116d0e9bff76b02056182eb555fba061f5f7d19ca0c593d2546fd9d8ddb71524811da1987bc809fb09923b73f2d46aec81386e385b05ae09dc556da1c847f74ff00244ae227f7bbad6cf9af83843e1660899020221232d06ef59e2df1d84166a9e4e693ddc98e2568a72028764b5dcf815b738c5f17baf4057c314b759d5e68fe74723e5800463cb31669ebbb1419d5cec686951747e324456226db023b3078bf0d945474e386a956096c83d1d7fa935634067c12171bd47351c3d7c02de5a65f56b32bef8073f3fffdacf0d185abf7d987743a90d923ae7fc927ec750c144339890ed0abac99a046915eefad409039642fe6ee17ebe792d5dd5f5582e85af60d08be459200701c822440eb6d2ebe44caf1afe657536805dc80050083eb04a670b65a175c2b8683c353cc0fc3ccd9d01c5fb555cc5f6f9b9bbfd39a761b802e84a23484fa3b82240a36aff54621401dc0a7e93120d4595db1ad86714e0b78f4e18a7f4528736fe1a30f82eea30f56098e6817e4a09129ab8595f3daac9fde8d8814fb2ad2e23605346d0de643518a9dbba359f180fd0db77af843b2d7a629bec222def3e2ebbeceefac0ed8e3aa9b00ac47f021514bf7182103f3b2d5e86f9fc17c30ed3077eed0307c94f896c0db8c4061968c67c1317855e9492030433b9bc852dcc0f1fe83bc473b9c35a6a43c0dd76b06e1e725d00eb3aa4814e28f099a4048ea3f347426835227efba1ef0bb764d512663a47448d3b231c8b813f354d12be0bb87a0faf955b4e2a40c8b32dbe951a76fb68a140afb921a4d73abe1f9309803b090e06689c456fefb2218b17521f8e6f1366810fa849baba4d057a61a5ab41e89c6cb08b2f934d4d17945dfcac9feb43ccdf220c2c1252f45332be4b7ea756c902ce15bc584b27ddd999651527375ee2fdda52653ef236358b8d853477b209</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 880(Div. 2)</title>
      <link href="/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/"/>
      <url>/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>挂个传送门：<a href="https://codeforces.com/contest/1836">Dashboard - Codeforces Round 880 (Div. 2) - Codeforces</a></p><p>评价是，切完ABC蹲大牢</p><h5 id="B-Astrophysicists"><a href="#B-Astrophysicists" class="headerlink" title="B. Astrophysicists"></a>B. Astrophysicists</h5><p><strong>题意</strong>：</p><p>$k*g$ 银币分配给 $n$ 人，设一个人分到 $x$ 银币，$r=x \mod g$ 对每人有补正如下：</p><ul><li>若 $r\geq \lceil \frac{g}{2} \rceil$，则向上修正至 $x+(g-r)$；</li><li>否则，向下修正至 $x-r$ .</li></ul><p>求分配完后，剩下的银币数目之和最小值。</p><p><strong>题解</strong>：</p><p>​    什么黑心资本家出的题。</p><p>​    考虑一个人分配到的银币，从 $0$ 增加至 $g$ 。增加至 $\lceil \frac{g}{2}\rceil$ 前，经补正他所获得银币为 $0$ ，原先分配银币即剩下；增加至 $\lceil \frac{g}{2}\rceil$ 后，我们需要额外的银币为其补正。    故对一个人来说，我们的收益和他分配的银币呈一个由两直线构成的分段函数，从 $0$ 开始并且回到 $0$ 。我们的最大收益点在 $p=\lceil \frac{g}{2}\rceil-1$ 。</p><p>​    此时可以分成两种情况讨论：</p><ul><li><p>若 <script type="math/tex">n*p \geq k*g</script> ，那所有人贪心分配（至多 <script type="math/tex">p</script> ），最后每个人分配到 $0$ ，方案显然最优，结果为 <script type="math/tex">k*g</script> 。</p></li><li><p>若<script type="math/tex">n*p< k*g</script>， 最优分配结果为<script type="math/tex">g\lfloor \frac{p*n}{g} \rfloor</script> 。</p></li></ul><p>​    讨论下第二种情况，为什么是这个式子。</p><p>​    易知，最优方案不存在向上修正。设第 $i$ 个人分配到 $x_i$ 银币，则有<script type="math/tex">\sum x_i = k*g</script>，因此我们的收益 <script type="math/tex">income</script> 满足 <script type="math/tex">income=\sum (x_i\% g)\equiv (\sum x_i)\% g\equiv 0</script> 。这是一个比较重要的性质，答案必定是 $g$ 的倍数。</p><p>​    设 <script type="math/tex">income=kg</script> ，则必有 <script type="math/tex">kg \leq p*n</script> （答案上限就是 <script type="math/tex">p*n</script> ），故 <script type="math/tex">income = kg = g \lfloor \frac { p*n } { g } \rfloor</script> </p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, k, g;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; g;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> p = ((g + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p * n &gt;= k * g) &#123;</span><br><span class="line">        cout &lt;&lt; k * g &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; p * n / g * g &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-K-th-equality"><a href="#C-K-th-equality" class="headerlink" title="C. K-th equality"></a>C. K-th equality</h5><p><strong>题意</strong>：</p><p>​    构造第 $k$ 大字典序字符串，其中字符串形如 $A$ 位数 $+B$ 位数 $=C$ 位数。</p><p><strong>题解</strong>：</p><p>​    体感很简单的一道题。</p><p>​    设 $x$ 位数的范围为 $[L_x, R_x)$</p><p>​    由于 $A\leq 6$，因此枚举 $x+y=z$ 中的 $x$ 。</p><p>​    接下来寻找对 $y$ 的限制条件。</p><ul><li>$L_B\leq y&lt;R_B$</li><li>$L_C\leq z&lt; R_C$ ，即 $L_C\leq x+y &lt;R_C$</li></ul><p>​    由此可得限制条件 $max\{L_B,L_C-x\}\leq y&lt;min\{R_B,R_C+x\}$</p><p>​    然后边统计边算即可。复杂度 $O (10^A)$</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mn[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> A, B, C;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mx = mn[A + <span class="number">1</span>], i = mn[A]; i &lt; mx; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(mn[C] - i, mn[B]);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">min</span>(mn[C + <span class="number">1</span>] - i, mn[B + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= r - l) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; l + k - <span class="number">1</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; i + l + k - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> k -= r - l;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-Twin-Clusters"><a href="#E-Twin-Clusters" class="headerlink" title="E. Twin Clusters"></a>E. Twin Clusters</h5><p><strong>题意：</strong></p><p>​    给定长为 <script type="math/tex">2^{k+1}</script> 的一序列，值域为 <script type="math/tex">[0,4^k)</script> 。求原序列两不相交子区间，使得两子区间中数字的异或和相同。</p><p><strong>题解：</strong></p><p>​    瞄了眼 Tutorial ，不太好想。一开始想过类似于分块的思路，实际解法也差不多，不过只取一个块。</p><p>​    先关注二进制下低 <script type="math/tex">k</script> 位。算上空串，共有 <script type="math/tex">2^{k+1}+1</script> 个值，但实际上低 <script type="math/tex">k</script> 位值域 <script type="math/tex">[0,2^k-1]</script> 共 <script type="math/tex">2^k</script> 个值，因此根据鸽巢原理，我们可以匹配出 <script type="math/tex">2^k+1</script> 个区间 <script type="math/tex">(l_i, r_i]</script>，使得这每个区间 <script type="math/tex">S_{r_i} \ xor\ S_{l_i}</script> 的低<script type="math/tex">k</script> 位均为 $0$ 。</p><p>​    接下来关注这些线段的高 <script type="math/tex">k</script> 位。采取同样的方法，根据鸽巢原理，必定存在两个子区间高 <script type="math/tex">k</script> 位的异或和相同，取这两子区间的交即为结果。</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    n = (<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; Line;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    g[<span class="number">0</span>] = s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lbit = (<span class="number">1ll</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hbit = (((<span class="number">1ll</span> &lt;&lt; (k &lt;&lt; <span class="number">1</span>)) - <span class="number">1</span>) ^ lbit);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; g[i];</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ g[i];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = (s[i] &amp; lbit);</span><br><span class="line">        <span class="keyword">if</span> (mp[p] || p == <span class="number">0</span>) Line.<span class="built_in">push_back</span>(<span class="built_in">mp</span>(mp[p], i));</span><br><span class="line">        mp[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Line) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = ((s[line.second] ^ s[line.first]) &amp; hbit);</span><br><span class="line">        <span class="keyword">if</span> (pos[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l1 = Line[pos[p] - <span class="number">1</span>], l2 = line;</span><br><span class="line">            <span class="keyword">if</span> (l1.second &lt;= l2.first) &#123;</span><br><span class="line">                cout &lt;&lt; l1.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">min</span>(l1.first, l2.first) + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">max</span>(l1.first, l2.first) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                     &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> pos[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Lottery"><a href="#D-Lottery" class="headerlink" title="D. Lottery"></a>D. Lottery</h5><p><strong>题意：</strong></p><p>​    给定 <script type="math/tex">n</script> 个人，每人买一张彩票，票号在 <script type="math/tex">[0,m]</script> 范围内。设开奖号为 <script type="math/tex">x</script> ，则票号距离 <script type="math/tex">x</script> 最近的 <script type="math/tex">k</script> 人中奖，平局情况则编号小的获胜。作为第 <script type="math/tex">n+1</script> 人，你编号最大，求最小位置，使得能够使你中奖的编号尽可能多。</p><p><strong>题解：</strong></p><p>​    非常繁琐的一道题。先来看这幅图（截自 tutorials ）：</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307021737523.png" alt="image-20230702173756179"></p><p>​    假设当前选择编号为 <script type="math/tex">c</script> ，<script type="math/tex">c</script> 的前 <script type="math/tex">k</script> 名为 <script type="math/tex">a</script> ，后 <script type="math/tex">k</script> 名为 <script type="math/tex">b</script> 。则中奖区间为 <script type="math/tex">(\lfloor \frac{a+c}{2} \rfloor, \lceil \frac{b+c}{2} \rceil)</script> 。由此计算结果。</p><p>​    接下来讨论需要枚举哪些 <script type="math/tex">c</script> 。由上面图可知，处在 <script type="math/tex">(d,e)</script> 区间内时，中奖区间虽然改变，但实际中奖区间长度不变（<script type="math/tex">a</script> 和 <script type="math/tex">b</script> 没有变化）。故我们只需讨论 <script type="math/tex">n</script> 个人所选号码的前后两三个数即可。 当然，特别考虑边界情况。</p><p>​    输入量较大，需要注意 <script type="math/tex">IO</script> 效率。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; v;</span><br><span class="line"><span class="type">int</span> nowl, nowr;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calc</span><span class="params">(<span class="type">long</span> <span class="type">long</span> now_pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nowl &lt; n &amp;&amp; v[nowl] &lt; now_pos) ++nowl;</span><br><span class="line">    <span class="keyword">while</span> (nowr &lt; n &amp;&amp; v[nowr] &lt;= now_pos) ++nowr;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posl = nowr - k &lt; <span class="number">0</span> ? <span class="number">0</span> : (now_pos + v[nowr - k]) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posr = nowl + k - <span class="number">1</span> &gt;= n ? m : (now_pos + v[nowl + k - <span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, posr - posl + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        v.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    nowl = nowr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res_pos = <span class="number">0</span>, ans = <span class="built_in">calc</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> bl = i == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="number">0ll</span>, v[i] - <span class="number">2</span>) : <span class="built_in">max</span>(v[i] - <span class="number">2</span>, v[i - <span class="number">1</span>] + <span class="number">3</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> br = <span class="built_in">min</span>(v[i] + <span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> now_pos = bl; now_pos &lt;= br; now_pos++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">calc</span>(now_pos);</span><br><span class="line">            <span class="keyword">if</span> (p &gt; ans) &#123;</span><br><span class="line">                ans = p;</span><br><span class="line">                res_pos = now_pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res_pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="F-Doctor’s-Brown-Hypothesis"><a href="#F-Doctor’s-Brown-Hypothesis" class="headerlink" title="F. Doctor’s Brown Hypothesis"></a>F. Doctor’s Brown Hypothesis</h5><p><strong>题意：</strong></p><p>​    给定一有向图，求无序点对 <script type="math/tex">(u, v)</script> 的数目，使得 <script type="math/tex">u</script> 和 <script type="math/tex">v</script> 相互之间存在着长度为 <script type="math/tex">k</script> 的路径，其中 <script type="math/tex">u=v</script> 也被允许。</p><p><strong>题解：</strong></p><p>​    不会。稍微翻译下 tutorial 。</p><p>​    突破口在 <script type="math/tex">k\geq n^3</script> 。显然对于所有满足答案的点对，两点都在同一个强连通分量内。于是讨论范围缩减到同一个 <script type="math/tex">SCC</script> 。对强连通分量内的所有环的大小，存在一个最大公约数 <script type="math/tex">g</script> 。将所有的边 <script type="math/tex"><s,t></script> 按照 <script type="math/tex">t=(s+1)mod\ g</script> 进行染色。由于 <script type="math/tex">k</script> 比较大，所以可以认为颜色相同的点都是等价的。</p><p>​    对于一个连通分量内，满足条件的点对有以下两种：</p><ul><li>$g|k$ ，则所有颜色相同点对满足条件。</li><li>$2|g$ 且 $k\equiv g/2\ mod \ g$ ，则所有颜色差值为 $g/2$ 的点对满足条件</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[N];</span><br><span class="line"><span class="type">int</span> col[N], cnt_col;</span><br><span class="line"><span class="type">int</span> _stack[N], <span class="type">_t</span>, dfn[N], low[N], cnt, siz[N];</span><br><span class="line"><span class="type">bool</span> book[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//强连通分量</span></span><br><span class="line">    dfn[x] = low[x] = ++cnt;</span><br><span class="line">    _stack[++<span class="type">_t</span>] = x;</span><br><span class="line">    book[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[ver]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ver);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[ver]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book[ver]) low[x] = <span class="built_in">min</span>(low[x], dfn[ver]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        ++cnt_col;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = _stack[<span class="type">_t</span>];</span><br><span class="line">            col[p] = cnt_col;</span><br><span class="line">            ++siz[cnt_col];</span><br><span class="line">            book[p] = <span class="literal">false</span>;</span><br><span class="line">            --<span class="type">_t</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag[N], dis[N];</span><br><span class="line"><span class="type">bool</span> solved[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    dis[x] = d;</span><br><span class="line">    flag[x] = des;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[ver] != des) <span class="built_in">dfs</span>(ver, d + <span class="number">1</span>, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试染色</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    <span class="type">bool</span> Flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) Flag &amp;= <span class="built_in">draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">        <span class="keyword">else</span> Flag &amp;= (num[ver] == ((num[x] + <span class="number">1</span>) % base_num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt_num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//染色，统计数目</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    ++cnt_num[now];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) <span class="built_in">Draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: v[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[i] == col[y]) vec[i].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> search_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solved[col[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        solved[col[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[col[i]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x = i, y = vec[x][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, <span class="number">0</span>, y);</span><br><span class="line">        d += dis[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= d; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d % j != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> p = j, rem_num = <span class="number">1</span>;</span><br><span class="line">            <span class="type">bool</span> now_flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (d % p == <span class="number">0</span>) &#123;</span><br><span class="line">                ++search_num;</span><br><span class="line">                <span class="keyword">if</span> (now_flag &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, p, search_num)) rem_num = p;</span><br><span class="line">                <span class="keyword">else</span> now_flag = <span class="literal">false</span>;</span><br><span class="line">                p *= j;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= (p / j);</span><br><span class="line">            g *= rem_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span> &amp;&amp; (++search_num) &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, d, search_num)) g *= d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) cnt_num[j] = <span class="number">0</span>;</span><br><span class="line">        ++search_num;</span><br><span class="line">        <span class="built_in">Draw_col</span>(x, <span class="number">0</span>, g, search_num);</span><br><span class="line">        <span class="keyword">if</span> (k % g == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) ans += <span class="number">1ll</span> * cnt_num[j] * (cnt_num[j]+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; k % g == g / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g / <span class="number">2</span>; j++) ans += <span class="number">1ll</span> * cnt_num[j] * cnt_num[j + g / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当我开始真正爱自己</title>
      <link href="/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/"/>
      <url>/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<p><em>作者：卓别林</em></p><p>当我真正开始爱自己，</p><p>我才认识到，所有的痛苦和情感的折磨，</p><p>都只是提醒我：活着，不要违背自己的本心。</p><p>今天我明白了，这叫做“真实”。</p><p>​    </p><p>当我真正开始爱自己，</p><p>我才懂得，把自己的愿望强加于人，</p><p>是多么的无礼，就算我知道，时机并不成熟，</p><p>那人也还没有做好准备，</p><p>就算那个人就是我自己。</p><p>今天我明白了，这叫做“尊重”。</p><p>​    </p><p>当我开始爱自己，</p><p>我不再渴求不同的人生，</p><p>我知道任何发生在我身边的事情，</p><p>都是对我成长的邀请。</p><p>如今，我称之为“成熟”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我才明白，我其实一直都在正确的时间，</p><p>正确的地方，发生的一切都恰如其分。</p><p>由此我得以平静。</p><p>今天我明白了，这叫做“自信”。</p><p>​    </p><p>当我真正开始爱自己，</p><p>我不再牺牲自己的自由时间，</p><p>不再去勾画什么宏伟的明天。</p><p>今天我只做有趣和快乐的事，</p><p>做自己热爱，让心欢喜的事，</p><p>用我的方式、我的韵律。</p><p>今天我明白了，这叫做“单纯”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我开始远离一切不健康的东西。</p><p>不论是饮食和人物，还是事情和环境，</p><p>我远离一切让我远离本真的东西。</p><p>从前我把这叫做“追求健康的自私自利”，</p><p>但今天我明白了，这是“自爱”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我不再总想着要永远正确，不犯错误。</p><p>我今天明白了，这叫做“谦逊“。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我不再继续沉溺于过去，</p><p>也不再为明天而忧虑，</p><p>现在我只活在一切正在发生的当下，</p><p>今天，我活在此时此地，</p><p>如此日复一日。这就叫“完美”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我明白，我的思虑让我变得贫乏和病态，</p><p>但当我唤起了心灵的力量，</p><p>理智就变成了一个重要的伙伴，</p><p>这种组合我称之为，“心的智慧”。</p><p>我们无须再害怕自己和他人的分歧，</p><p>矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界，今天我明白，这就是“生命”。</p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

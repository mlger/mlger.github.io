<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Codeforces Round 877 (Div. 2)</title>
      <link href="/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/"/>
      <url>/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1838">Codeforces Round 877 (Div. 2)</a></p><h5 id="A-Blackboard-List"><a href="#A-Blackboard-List" class="headerlink" title="A. Blackboard List"></a>A. Blackboard List</h5><p><strong>题意：</strong></p><p>​    给定包含两个数字的初始，然后进行 <script type="math/tex">n-2</script> 次操作，每次操作从序列中取出两个数字（不能取同一个），将其差之绝对值加入序列，最终得到一长度为 <script type="math/tex">n</script> 的序列。</p><p>​    现给定最终序列（乱序）， 求最初始数字之一。</p><p><strong>题解：</strong></p><p>​    由于新加入数字必为非负数，因此序列中的负数必定是初始数字。</p><p>​    若全为非负数，由于 <script type="math/tex">|a-b|\leq|a|</script> 且 <script type="math/tex">|a-b|\leq |b|</script> ，因此最大数字必为初始数字。</p><h5 id="B-Minimize-Permutation-Subarrays"><a href="#B-Minimize-Permutation-Subarrays" class="headerlink" title="B. Minimize Permutation Subarrays"></a>B. Minimize Permutation Subarrays</h5><p><strong>题意：</strong></p><p>​    给定一 <script type="math/tex">n</script> 的排列。交换两数字的位置，使得交换后序列中，能够成排列的连续子序列数目最少。</p><p><strong>题解：</strong></p><p>​    <script type="math/tex">1</script> 与 <script type="math/tex">2</script> 之间夹 <script type="math/tex">n</script> ，这样能够使得数目恒为 <script type="math/tex">1</script> ，是为最少。讨论即可</p><h5 id="C-No-Prime-Differences"><a href="#C-No-Prime-Differences" class="headerlink" title="C. No Prime Differences"></a>C. No Prime Differences</h5><p><strong>题意：</strong></p><p>​    将 <script type="math/tex">n*m</script> 之内的正整数排成一个 <script type="math/tex">n*m</script> 矩阵，使得矩阵中任意两相邻元素差值的绝对值不为素数。</p><p><strong>题解：</strong></p><p>​    先考虑 <script type="math/tex">m\geq 5</script> 时，将 <script type="math/tex">\{0, 1*n, 2*n, 3*n, ... (m-1)*n\}</script> 排成一列。以下是一种合适的构造方法。</p><p>​    设 <script type="math/tex">p=\lfloor \frac{m-1}{2}\rfloor</script> 考虑两个序列 </p><script type="math/tex; mode=display">\{0, 1*n, 2*n, ...p*n \} \\\{(p+1)*n, (p+2)*n, ... (m-1)*n\}</script><p>​    然后将两序列合成（下面序列的元素依次插入上面序列的空隙）。</p><p>​    若 <script type="math/tex">m=4</script> ，则可构造为 <script type="math/tex">\{1*n, 3*n, 0, 2*n\}</script></p><p>​    设该序列为 <script type="math/tex">A</script> ，则最终矩阵可构造为 <script type="math/tex">p_{i, j}=i+A_j</script></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">4</span>) &#123;</span><br><span class="line">        add[<span class="number">0</span>] = n;</span><br><span class="line">        add[<span class="number">1</span>] = <span class="number">3</span> * n;</span><br><span class="line">        add[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        add[<span class="number">3</span>] = <span class="number">2</span> * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) cout &lt;&lt; i + add[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Bracket-Walk"><a href="#D-Bracket-Walk" class="headerlink" title="D. Bracket Walk"></a>D. Bracket Walk</h5><p><strong>题意：</strong></p><p>​    一括号序列，从最左侧出发可以随意向左右移动（不超边界），最终停在最右侧。途经符号构成一括号序列，若该括号序列合法，则称原序列 walkable 。</p><p>​    现给定一括号序列 <script type="math/tex">s</script> ， <script type="math/tex">q</script> 次单点修改，要求求出每次单点修改后，序列是否 walkable 。</p><p><strong>题解：</strong></p><p>​    walkable 的必要条件首先是长度 <script type="math/tex">n</script> 为偶数。</p><p>​    其次构造一序列 <script type="math/tex">A</script> ，包含所有的 <script type="math/tex">i</script> ，使得</p><ul><li>$s_i= ) $ 且 $i$ 为奇数</li><li>$s_i= ($ 且 $i$ 为偶数<ol><li>若 <script type="math/tex">A</script> 为空，则显然圆括号序列为 $()$ 重复若干次，必定 walkable。</li><li>若 <script type="math/tex">A</script> 非空，其中最小数字为奇数，则意味着序列开头为 $()()()…())$ ，必定非法</li><li>若 <script type="math/tex">A</script> 非空，其中最大数字为偶数，则意味着序列末尾为 <script type="math/tex">(()()()</script> ，必定非法</li><li>剩余情况， <script type="math/tex">A</script> 中最小数字 $m$ 为偶数， 最大数字 $M$ 为奇数，则 $m, M$ 之间符号数为偶数，其中左右括号奇偶性相同。则在 $m-1,m$ 这两个位置产生足够多的 $((….$ 来消除右侧的 $)$，然后在$M,M+1$ 两个位置产生对应数量的 $))$ 补齐即可。合法。</li></ol></li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;str](<span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="built_in">return</span> ((str[p - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) ^ (p &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) s.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2 9</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; pos;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(pos)) s.<span class="built_in">erase</span>(pos);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">insert</span>(pos);</span><br><span class="line">        str[pos - <span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span> + <span class="string">&#x27;)&#x27;</span> - str[pos - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*s.<span class="built_in">begin</span>() &amp; <span class="number">1</span>) || !(*s.<span class="built_in">rbegin</span>() &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/2023/07/04/README/"/>
      <url>/2023/07/04/README/</url>
      
        <content type="html"><![CDATA[<p>本站采用 hexo 架构，部署在 github pages 上，采用 github 作为图床。建议在能够流畅访问 github 的网络环境下浏览。</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307042122433.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 150 (Div. 2)</title>
      <link href="/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/"/>
      <url>/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1841">Educational Codeforces Round 150 (Rated for Div. 2) </a></p><h5 id="A-Game-with-Board"><a href="#A-Game-with-Board" class="headerlink" title="A. Game with Board"></a>A. Game with Board</h5><p><strong>题意：</strong></p><p>​    给定初始序列为 <script type="math/tex">n</script> 个 <script type="math/tex">1</script> ，两人轮流行动，每次可以选择序列中若干个相同的数，剔除，并将他们的和加入序列。第一位无法行动的一方获胜。假设二人都绝对聪明，试问先手是否必胜。</p><p><strong>题解：</strong></p><p>​    分类讨论一下：</p><ul><li>$2\leq n \leq 4 $，有限轮模拟易得后手必胜。</li><li>$n\geq5$ ，则先手取 $n-2$ 个 $1$， 后手只能取 $2$ 个 $1$ ， 之后序列变为 $\{n-2, 2\}$ ，故先手必胜。</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-Ranom-Numbers"><a href="#C-Ranom-Numbers" class="headerlink" title="C. Ranom Numbers"></a>C. Ranom Numbers</h5><p><strong>题意：</strong></p><p>​    A, B, C, D, E 分别代表 <script type="math/tex">1, 10, 100, 1000, 10000</script> 。给定一由大写字母 ABCDE 组成的串，对于某一字符，若字符串后方有严格大于它的字符，则符号为负，否则为正。字符串权值为所有字母乘上符号的权值之和。</p><p>​    现可以修改至多一字符，求可能的最大权值。</p><p><strong>题解：</strong></p><p>​    据说 DP 和贪心均可，这里思路是 DP 。</p><p>​    为了方便起见，先将字符串反转，规则也对应修正。</p><p>​    然后设计状态： <script type="math/tex">F[i][j][0/1]</script> 代表到第 <script type="math/tex">i</script> 位，目前前缀最大值为 <script type="math/tex">j</script> ，且已经/未修改的最大权值。 <script type="math/tex">i</script> 这一位用滚动数组滚掉，然后枚举状态的转移即可。</p><p>​    复杂度 <script type="math/tex">O(nMK)</script> ，其中 <script type="math/tex">M=5, K=2</script> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> f[<span class="number">2</span>][<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[<span class="number">0</span>][i][<span class="number">0</span>] = f[<span class="number">0</span>][i][<span class="number">1</span>] = -inf;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">        p ^= <span class="number">1</span>;</span><br><span class="line">        q ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[p][i][<span class="number">0</span>] = f[p][i][<span class="number">1</span>] = -inf;</span><br><span class="line">        <span class="type">int</span> x = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;   <span class="comment">//i-1位前缀最大</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) &#123;   <span class="comment">//</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">5</span>; y++) &#123;</span><br><span class="line">                    <span class="type">int</span> nt = t + (y != x);</span><br><span class="line">                    <span class="type">int</span> nj = <span class="built_in">max</span>(y, j);</span><br><span class="line">                    <span class="keyword">if</span> (nt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        f[p][nj][nt] = <span class="built_in">max</span>(f[p][nj][nt], f[q][j][t] + (y == nj ? digit[y] : -digit[y]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">0</span>]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Pairs-of-Segments"><a href="#D-Pairs-of-Segments" class="headerlink" title="D. Pairs of Segments"></a>D. Pairs of Segments</h5><p><strong>题意：</strong></p><p>​    给定 <script type="math/tex">n</script> 条线段，用区间表示 <script type="math/tex">[l,r]</script> 。若 <script type="math/tex">n</script> 为偶数，且可以将 <script type="math/tex">n</script> 条线段分为 <script type="math/tex">\frac{n}{2}</script> 对， 每一对线段相交， 不成一对的线段布希昂叫，则称其 <strong>beautiful</strong> 。现问至少删去多少线段，使得剩下的线段可以 <strong>beautiful</strong> 。</p><p><strong>题解：</strong></p><p>​    <script type="math/tex">n</script> 比较小。一开始以为是 <script type="math/tex">dp</script> 但怎么都消除不了后效性。实际解法是——直接暴力。</p><p>​    首先考虑两对线段，共四条。不成对线段不相交的等价条件可以表示为： 成对线段取并集，所得两条线段不相交。</p><p>​    因此可以直接求出 <script type="math/tex">C_n^2</script> 对线段中，相交对的并集。然后找出尽量多的并线段，使其互不相交即可。互不相交可以天然保证每条线段至多用了一次。求不相交线段数目，这里用了动态开点线段树。</p><p>​    复杂度 <script type="math/tex">O(n^2logn)</script> 。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> lc[N &lt;&lt; <span class="number">4</span>], rc[N &lt;&lt; <span class="number">4</span>], dat[N &lt;&lt; <span class="number">4</span>], cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">    dat[p] = <span class="built_in">max</span>(dat[p], val);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid) <span class="built_in">update</span>(lc[p], l, mid, k, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || u &gt; v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(lc[p], l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(rc[p], mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">Line</span>(n);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; Uline;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; Line[i].first &gt;&gt; Line[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a.first, b.first) &lt;= <span class="built_in">min</span>(a.second, b.second);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> uni = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="built_in">min</span>(a.first, b.first), <span class="built_in">max</span>(a.second, b.second));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(Line[i], Line[j])) <span class="keyword">continue</span>;</span><br><span class="line">            Uline.<span class="built_in">pb</span>(<span class="built_in">uni</span>(Line[i], Line[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(Uline.<span class="built_in">begin</span>(), Uline.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Uline) &#123;</span><br><span class="line">        <span class="type">int</span> rem = <span class="built_in">query</span>(rt, <span class="number">-1</span>, inf, <span class="number">-1</span>, line.first - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">update</span>(rt, <span class="number">-1</span>, inf, line.second, rem + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rem + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - (ans &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h5 id="E-Fill-the-Matrix"><a href="#E-Fill-the-Matrix" class="headerlink" title="E. Fill the Matrix"></a>E. Fill the Matrix</h5><p><strong>题意：</strong></p><p>​    给定一 <script type="math/tex">n*n</script> 的矩阵，其中第 <script type="math/tex">i</script> 列的第 <script type="math/tex">1-a_i</script> 行为黑格， <script type="math/tex">a_i-n</script> 行为白格，仅白格可以填数。当一个格填数 <script type="math/tex">x</script> 且其正右侧格填数 <script type="math/tex">x+1</script> 时，贡献一 beauty 。填入 <script type="math/tex">1-m</script> 共 <script type="math/tex">m</script> 个数，求最大 beauty 值。</p><p><strong>题解：</strong> </p><p>​    看起来似乎比其他几道好想很多。上层所有线段都是下层线段的子集，因此从最底层线段开始枚举，填数，分裂即可。</p><p>​    这里还是用的线段树。注意细节。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dat[N &lt;&lt; <span class="number">2</span>], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>) (dat[p] = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    dat[p] = <span class="built_in">min</span>(dat[p &lt;&lt; <span class="number">1</span>], dat[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = N;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>, l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">pos</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] = n - a[i];</span><br><span class="line">        pos[a[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos[i] 值为i的位置集合(补上界n+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pos[i].<span class="built_in">pb</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(pos[i].<span class="built_in">begin</span>(), pos[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r, pre_min;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre_min) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">pre_min</span>(pre_min) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node X) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l &lt; X.r - X.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ask(l, r) ask(1, 1, n, l, r)</span></span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">1</span>, n, <span class="number">0</span>));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p.l == p.r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> min_num = <span class="built_in">Ask</span>(p.l, p.r);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>) &gt; m) &#123;</span><br><span class="line">            ans += (m / (p.r - p.l + <span class="number">1</span>) * (p.r - p.l)) + <span class="built_in">max</span>(<span class="number">0ll</span>, m % (p.r - p.l + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m -= <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>);</span><br><span class="line">            ans += <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l);</span><br><span class="line">            <span class="type">int</span> L = std::<span class="built_in">lower_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.l) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> R = std::<span class="built_in">upper_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.r) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> pre_l = p.l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt; R; pre_l = pos[min_num][i] + <span class="number">1</span>, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre_l &lt; pos[min_num][i]) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, pos[min_num][i] - <span class="number">1</span>, min_num));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre_l &lt;= p.r) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, p.r, min_num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 879 (Div. 2)</title>
      <link href="/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/"/>
      <url>/2023/07/01/Codeforces%20Round%20879%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1834">Codeforces Round 879 (Div. 2)</a></p><p>难度适中，但菜鸡依旧。</p><h6 id="B-Maximum-Strength"><a href="#B-Maximum-Strength" class="headerlink" title="B. Maximum Strength"></a>B. Maximum Strength</h6><p><strong>题意：</strong></p><p>​    <script type="math/tex">[l,r]</script> 之间选两个数，使得十进制表示下各个位数的差值绝对值之和最大，位数不同则较小数补前导 <script type="math/tex">0</script> 对齐。</p><p><strong>题解：</strong></p><p>​    设 <script type="math/tex">l</script> 和 <script type="math/tex">r</script> 位数分别为 <script type="math/tex">n</script> 和 <script type="math/tex">m</script> ，取的数字为 <script type="math/tex">x<y</script> ，分情况讨论。</p><ul><li>若 <script type="math/tex">n<m</script> ，则最优情况为 <script type="math/tex">x</script> 取 $m-1$ 个 <script type="math/tex">9</script> , <script type="math/tex">y</script> 保留 <script type="math/tex">r</script> 的最高位，剩余位为 <script type="math/tex">0</script></li><li>若 <script type="math/tex">n=m</script> ，则除去相同前缀，然后 <script type="math/tex">y</script> 保留最高位，剩余位为 <script type="math/tex">0</script> ， <script type="math/tex">x</script> 保留最高位，剩余位为 <script type="math/tex">9</script> 即可。</li></ul><p><strong>code：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    n = s1.length();</span><br><span class="line">    m = s2.length();</span><br><span class="line">    if (n &lt; m) &#123;</span><br><span class="line">        cout &lt;&lt; (s2[0] - &#x27;0&#x27;) + (m - 1) * 9 &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (s1[i] == s2[i]) continue;</span><br><span class="line">            cout &lt;&lt; s2[i] - s1[i] + (n - i - 1) * 9 &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="C-Game-with-Reversing"><a href="#C-Game-with-Reversing" class="headerlink" title="C. Game with Reversing"></a>C. Game with Reversing</h6><p><strong>题意：</strong></p><p>​    给定两等长串 <script type="math/tex">S</script> 和 <script type="math/tex">T</script> ， Alice 和 Bob 轮流操作。Alice 每次可以替换一个字符，Bob 每次可以翻转一个串， 当两串相同时，停止操作。Alice 希望操作次数尽量少， Bob 希望操作次数尽量多， 求两个人都采取最优策略的情况下，实际游戏操作次数。</p><p><strong>题解：</strong></p><p>​    解释起来比较啰嗦，这里简述。    </p><p>​    实际上 Bob 每轮操作都是相同的，因此可以假设 Bob 只翻转一个字符串 <script type="math/tex">T</script> 。</p><p>​    对 Alice 来说，则可以有两种选择，将 <script type="math/tex">S</script> 变为 <script type="math/tex">T</script> 或 <script type="math/tex">rev(T)</script> 。二者最小步数都容易 <script type="math/tex">O(n)</script> 求出。 最后根据实际的奇偶性补齐 Bob 的操作数即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    int ans1 = 0, ans2 = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (s1[i] != s2[i]) ++ans1;</span><br><span class="line">        if (s1[i] != s2[n - i - 1]) ++ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ans1 &amp; 1) ans1 = ans1 * 2 - 1;</span><br><span class="line">    else ans1 = ans1 * 2;</span><br><span class="line">    if (ans2 &amp; 1) ans2 = ans2 * 2;</span><br><span class="line">    else if (ans2 == 0) ans2 = 2;</span><br><span class="line">    else ans2 = ans2 * 2 - 1;</span><br><span class="line">    cout &lt;&lt; min(ans1, ans2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="D-Survey-in-Class"><a href="#D-Survey-in-Class" class="headerlink" title="D. Survey in Class"></a>D. Survey in Class</h6><p><strong>题意：</strong></p><p>​    给定若干条线段，求最大分数差值。</p><p><strong>题解：</strong></p><p>​    对于线段 <script type="math/tex">[l_1, r_1]</script> 和线段 <script type="math/tex">[l_2,r_2]</script> ，设 <script type="math/tex">r_1<r_2</script> ，则分三种情况讨论：</p><ul><li><script type="math/tex">r_1<l_2</script> ，则最大差值可以分别来源于两线段整段，即 <script type="math/tex">max(r_1-l_1+1, r_2-l_2+1)</script> ；</li><li><script type="math/tex">l_1\leq l_2\leq r_1 \leq r_2</script>，则最大差值来源于二者分别对交集取补，即 <script type="math/tex">max(r_2-r_1, l_2-l_1)</script> ；</li><li><script type="math/tex">l_2\leq l_1 \leq r_1 \leq r_2</script> ，包含关系，最大差值来源于长线段对短线段取补，即 <script type="math/tex">(r_2-l_2+1)-(r_1-l_1+1)</script> 。</li></ul><p>​    将每条线段按右端点排序，枚举线段 <script type="math/tex">[l_2,r_2]</script> ， 目标是找出对应的 <script type="math/tex">[l_1, r_1]</script> ， 三种情况分别需要求：</p><ul><li>右端点小于 <script type="math/tex">l_2</script> 的直线中，<script type="math/tex">r-l+1</script> 的最大值</li><li>相交直线中， <script type="math/tex">r</script> 的最小值以及 <script type="math/tex">l</script> 的最小值</li><li>左端点大于等于 <script type="math/tex">l_2</script> 的直线中， <script type="math/tex">r-l+1</script> 的最小值</li></ul><p>​    四个值四棵动态开点线段树维护即可。</p><p><strong>code：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x7fffffff</span><br><span class="line">int cnt = 0;</span><br><span class="line">const int N = 4e5 + 5;</span><br><span class="line">int dat[N &lt;&lt; 5], lc[N &lt;&lt; 5], rc[N &lt;&lt; 5];</span><br><span class="line"></span><br><span class="line">void update(int &amp;p, int l, int r, int k, int val) &#123;</span><br><span class="line">    if (!p) p = ++cnt, dat[p] = inf;</span><br><span class="line">    if (l == r) return (void) (dat[p] = min(dat[p], val));</span><br><span class="line">    int mid = l + r &gt;&gt; 1;</span><br><span class="line">    if (k &lt;= mid) update(lc[p], l, mid, k, val);</span><br><span class="line">    else update(rc[p], mid + 1, r, k, val);</span><br><span class="line">    dat[p] = inf;</span><br><span class="line">    if (lc[p]) dat[p] = min(dat[p], dat[lc[p]]);</span><br><span class="line">    if (rc[p]) dat[p] = min(dat[p], dat[rc[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int query(int p, int l, int r, int u, int v) &#123;</span><br><span class="line">    if (!p) return inf;</span><br><span class="line">    if (u &lt;= l &amp;&amp; r &lt;= v) return dat[p];</span><br><span class="line">    int mid = l + r &gt;&gt; 1, res = inf;</span><br><span class="line">    if (u &lt;= mid) res = min(res, query(lc[p], l, mid, u, v));</span><br><span class="line">    if (v &gt; mid) res = min(res, query(rc[p], mid + 1, r, u, v));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123;</span><br><span class="line">    return A.second == B.second ? A.first &lt; B.first : A.second &lt; B.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">#define mp(x, y) make_pair(x, y)</span><br><span class="line">    int t1 = 0, t2 = 0, t3 = 0, t4 = 0;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;pair&lt;int, int&gt; &gt; Stu(n);</span><br><span class="line">    for (int i = 0, l, r; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        Stu[i] = mp(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Stu.begin(), Stu.end(), cmp);</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (auto stu: Stu) &#123;</span><br><span class="line">        int l = stu.first, r = stu.second;</span><br><span class="line">        int rem;</span><br><span class="line">        rem = -query(t1, 0, m, 0, l - 1);</span><br><span class="line">        if (rem != -inf) ans = max(ans, max(rem &lt;&lt; 1, (r - l + 1) &lt;&lt; 1));</span><br><span class="line">        update(t1, 0, m, r, l - r - 1);</span><br><span class="line"></span><br><span class="line">        rem = query(t2, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (r - rem) &lt;&lt; 1);</span><br><span class="line">        update(t2, 0, m, r, r);</span><br><span class="line"></span><br><span class="line">        rem = query(t3, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, (l - rem) &lt;&lt; 1);</span><br><span class="line">        update(t3, 0, m, r, l);</span><br><span class="line"></span><br><span class="line">        rem = query(t4, 0, m, l, r);</span><br><span class="line">        if (rem != inf) ans = max(ans, ((r - l + 1) - rem) &lt;&lt; 1);</span><br><span class="line">        update(t4, 0, m, l, r - l + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-MEX-of-LCM"><a href="#E-MEX-of-LCM" class="headerlink" title="E. MEX of LCM"></a>E. MEX of LCM</h5><p><strong>题意：</strong></p><p>​    题如其名。给定 <script type="math/tex">n</script> 个数，则对应的有 <script type="math/tex">C_n^2</script> 个连续子序列。求所有子序列数值 <script type="math/tex">lcm</script> 的 <script type="math/tex">Mex</script> 。</p><p><strong>题解：</strong></p><p>​    同样是利用好值域。 对于区间 <script type="math/tex">[l,r]</script> ，固定住右端点 <script type="math/tex">r</script> ，则至多还剩下 <script type="math/tex">r</script> 个左端点，对应 <script type="math/tex">r</script> 个区间。这 <script type="math/tex">r</script> 个区间有多少 <script type="math/tex">lcm</script> 值？从 <script type="math/tex">l=r</script> 开始，每次向左添加一个数， <script type="math/tex">lcm</script> 要么不变， 要么至少翻一倍，因此 <script type="math/tex">lcm</script> 值的数目是 <script type="math/tex">log</script> 级别的。因此整个序列所有 <script type="math/tex">lcm</script> 值的数目不超过 <script type="math/tex">nlogn</script> ，迭代求出然后求 <script type="math/tex">Mex</script> 即可。复杂度 <script type="math/tex">O(nlogn)</script></p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / __gcd(x, y) * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inf = <span class="number">1ll</span> * n * n + <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; num[i];</span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; s;<span class="comment">//以r-1为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; rem; <span class="comment">//以r为右端点的lcm序列</span></span><br><span class="line">    set&lt;<span class="type">long</span> <span class="type">long</span>&gt; ans;<span class="comment">//所有lcm序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: num) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">lcm</span>(y, x);</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= inf) rem.<span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        rem.<span class="built_in">insert</span>(x);</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: rem) s.<span class="built_in">insert</span>(y);</span><br><span class="line">        rem.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: s) ans.<span class="built_in">insert</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = <span class="number">1</span>;</span><br><span class="line">    ans.<span class="built_in">insert</span>(inf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != now) &#123;</span><br><span class="line">            cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数理思维</title>
      <link href="/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/"/>
      <url>/2023/07/01/%E6%95%B0%E7%90%86%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h6 id="一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。"><a href="#一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。" class="headerlink" title="一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。"></a>一、“决不能把任何我没有明确地认识其为真的东西当作真的加以接受，也就是说，小心避免仓促的判断和偏见，只把那些十分清楚明白地呈现在我的心智之前，使我根本无法怀疑的东西放进我的判断之中”。</h6><p>​    在数理逻辑论证推理中，务必做到毫无破绽。防范”千里之堤，溃于蚁穴“的局面。更直观地来说，论证必须有从底层起始的依据。</p><p>​    在日常生活中，这一条也同样适用。我们处在一个信息爆炸的时代，很多时候困扰我们的并不是信息资源的匮乏，而是信息茧房的拘束以及信息泛滥的迷茫。保持理性，对信息加以筛选，过滤掉无依据的信息。</p><h6 id="二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。"><a href="#二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。" class="headerlink" title="二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。"></a>二、“把我所考察的每一个难题，都尽可能地分成细小的部分，直到可以而且适于加以圆满解决的程度为止”。</h6><p>​    比较典型的分而治之思想。当整体带有规律性时，局部往往也具有与整体相同或相似的规律性，通过不断地划分，最终将问题转化为一个个显然或已解决的子问题。从个别、特殊到一般的方法。</p><h6 id="三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。"><a href="#三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。" class="headerlink" title="三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。"></a>三、“按照次序引导我的思想，以便以最简单最容易认识的对象开始，一点一点上升到对复杂的对象的认识，即便是那些彼此间没有自然的先后次序的对象，我也要给它们设定一个次序”。</h6><p>​    从易到难，从简单到复杂地进行分析、解决，而不至于迷乱。</p><h6 id="四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”"><a href="#四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”" class="headerlink" title="四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”"></a>四、“把一切情形尽量完全地列举出来，尽量普遍地加以审视，使我确信毫无遗漏。”</h6><p>​    如其所言，思维缜密，考虑周全，确保推理覆盖到所有情况。</p><p>摘自： 笛卡尔 《方法论》</p><p>​    </p><p>​    </p><p><code>人生没有目的，只有过程，所谓的终极目的是虚无的。——人的情况和树相同。它愈想开向高处和明亮处，它的根愈要向下，向泥土，向黑暗处，向深处，向恶——千万不要忘记。我们飞翔得越高，我们在那些不能飞翔的人眼中的形象越是渺小。</code></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT 指北</title>
      <link href="/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/"/>
      <url>/2023/06/30/ChatGPT%20%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0b9628033c767bbf3aa9fee6487070856f5e148fa15f92e5f20f8eb5d8b0b88b">578d5c17fdb0be81f91dae08d76a8b9d310fe713a3967a08677820d492351d4d8db2ce40c3d8dab35779bf2fde14fa61c200e4156e98e199d65a4f6ec1aee5b9815b7e5e19294072fc6ca00bfdcfe1fdc03e417f1adb72afa06d680da541c738197ab655a1e49104eb77ef86810c9e98c936e71ca104e1468987a8c1e4b1296836fc3d4145db7d9fa4c464b5166fff91038e2df137e5865cd29aa5865e803bebe454cc244e72f408e32aeaeecae74074129952ce099bad2b1987eb5a86827dca7852c842cdc14eb9cb8266b8774b394f73c82ffd15441a66c402a27690d2352201cf129e86dadc27dbce48b9701822060af5d9f46cfad7e9a8bacdd9a487b6ba370c023ae61299c46c8b7f9cc4100e59a0c098d1bca096af391e03cbffd11680904121495a7e928ae1b3a572bd196bf307fd8e815440b15142cd0832f0b8e8ecad8f412613938a1a65d7f435cea3376f4717de8683ef1b9f573173c119169384e2071082ad17830d107bfdde9c46f44e4105a5a231bcac34b7f4c9d13a3041ea222256429263941c7aa50e1c238a49960c3c8d56e5ff8b29ba2f8c5129f7616b3ad065cd14acd62ed7699f53937ecd023a0d56bd295b45f263c1ee4f8b9426acd1ca77ae4ec2e922b18fee7c29cccd302426ec247fcd95e8650ec9ba580132dfe01dafc3882097b69a72e9472006bf33438a2b347e6fede1c44aa5d8255cef135c08e327f34a621531aa0b83f0c31b5669e24e0250798e3290b7e08de1de4c4f8554d08424e681a69f844a268ff59b9600a4122880760bb56642ccfc16bbd7b6fe5ac62e500220531706b6a9434298adaaa7c2c75b7f93ebfecb6534894df6f477bdde4f5bb44b1316fbd1cbafce529a9cfe14a130b2ef47140dfa3090ab6fa312274a67f661ce4d4b178cf9a5141d43adc3efb3bb0ad68bf1f682f19398b75d56ffb3de87e1c3dfc138195f9c436ef370e92fd57e54d8b22972c3bc7e3f068cc7ae5841ef8d6f250c9c7d998b895528166573464185355ca11909ec3377912299fc2162fed0db073e1a201d52767c97db1d3691ccb5ea3e30286c6b9f7ac6dc75cda6a57b08ec6e4e19f29642591fd0822b4cc4a45bbe7317888fec0223836e2dc79789659561124fd9e17bfb8c96339a8714177c12f979324aaaafb93974e0eccf4df7aeffc5c405708064516b72cb1cd6c795c6453e532d7916015105dc29705393b7c3d729c8c4afb47fc8128e6532d4919de15ec86c9f023fc04194611851c481a03b828fc3c4230600b5d94bff38a8d323e8885fc584e9ac3978afeecf77d309827cd7fcbfcf3536adad3adbba9762f408660ad60bd6238bb5cbd2e5b8d0997dd13be89a954a208f8eefbc6d878cdf5b2a802ac0ec2cce1000a2d274f5e48c77630ae7e8ab81dd57dbd03d0582dadfba8437a8b4e68c135c696b0d4b37447e9d376d61bd19266ff0634809b387c047ee4c7f2b6b0c2f6f621de194b15a859201705ad40319d2e7d1a1c886b0ec12332d5a57fbb2ad9e2713164610232a6f5a82bde627fafbbdf02d2383a9cd3d9e107657f08a02b2a535a8f0fcbe2d358cc62c67472d7bb5d8649da262144c896eb621cbbc979a63fbf3ea44a928d154d5a6706b0b0ff534cd35db0d9702b0cbdea9d5f6a1290426f05c59c34500bf913d6dc39d319f80b5dff4030af7de7e32b5856afa9683d8e7eb7b46fef84735b9c8ff15152086081797da1c839ccb75cc97fef9c38fcbedc64f4b384a9a8e99c1f2b508de9cd6b8027c4e2743d1d422b9a0a57f46819294aeda4d783ef4668a5f808fb8c53811db3672853b8ae5ed2fa68f5e39d6638177543a7ec36295c24dbc2fe6821e2c04458eaf0e402077bd68e663bcbf90a32a4fd7e692c4ff0263a829b7004ab7d3d7800fb7f8e075c9c3a0aa21a3a79dc3f1c29e13ab66610208af1804abd5a3d451813c573ae3dc14bf9ef69226669f033074a0311681bc2d0d28588b08a9ac56ba7fe20d397567ef517e0121ef8d1ac29abd6f8169967329581b48a8ad121163b857e2ef4e3076d370d99903cf3d91532d284a1a4afb23949c3c1cb9836577a0499d0e4bab26deb85311e854b3f4de26346631a778a2fc33d875f9aaf68579875a69615e740e9eb79db16b3f9b389507063f2ca4ceca5186fd72b2f61ae0679e010a4bd38aa7bec34219ca15ad9e0856972ab65b704fa9bb383a396fb26b274103a8b3c39a1d1951d09168193f5266632332715663118cc0c29f400d0e7f24f77543d1875ce3744db7b50256ff8e96d3d23b3f499ef06cc7e940951be896d16ffd18cfde1c906a96b9d90b50c48d8a7bb5cd66c3d0884564078fb3cc0ac3a1d4c962ef390fdb7850786a61589e1ad6019b15ccec04d277fca0cd1197328498afc896797ba3d4864ac4b6dab9392e35e74702f5b8aab284749c305e4646729c8e971a91fc73f2b0865f76ed95ab5d28b99d97807367c7ea5850dce550640690c09284eb7421866bfda04389edc0fa90aaded37e7a3a0ca1ce6eca3f0018aa38439f2fa6200fdcb33f5644a2bd4b912eb4f13a254ac7cdea8f148018a93837c5b3e3666a14548b1cc8a6387c3cfbeb27ca56bdfac92550c86835cce802a1607d8a528dc42e2ff738b67a3a7b8c7ede62eb5ed3ae1f5107489db5467cf1444c1824545b78ff98de3ac89e68ded45fe73b1711e1015cb244f6046b0ad33cbcef218c4df747a694f84285b0ff7d4be7730386458de5df313c0c014b995495db0eeb7aef36155abfd2bd611931276c3efec28af0a0c7c56aed369ad3471856e710aefb4349af76c0766b28cb535f28771ab80f4fc1864592556ed3696e4328a6df82711fb5cfa31dc8c16ccfef7ee5541a12b9a53edf8cc5052994b27aeb74874835b838f41965388c005f8b2a418fc7fa680352f4e681126d936c56eb39efb30c53620a24f6a10f59dbb609a221eb37fdba065f4d865ad20c8c27c63112cc50a267c07ad06a02a1019a0917a94289bbcf66d7372258edbd758b3c266d18d73e008422a2e1d9a665feea94914f3521ce3fb306cc790e1a8d70a09983fa416b6b3485f17c876c6c7781ba7d50e75ea1ba3ab6dc6e33d9767acc7d171ddb3714cee5a8dfd48e1f4ebeea41d1bdb00864e0d9d1bb4b02345acd9f49f4c29516763288309332f9796e55bf06df916e225be7f837e0d7b2fc9ab8e19465666c9e6052cf130c00a9e591d0838cbb52ae686ea00a02e2f8366776f47c586961b77a0358127db76d6ca8829ea8f71df597a02f3e9092672828496a0347465fadc16b1bf933f6f817a5b2c798f5dbf02dedf18b60e89064a24bcba7afed522845eb60454a62d1ed21d70688d822419a9d71404c5db9df70d7c11f5b8e38e97f95da616b5de5e11005e7ad00bb6f38f856f4a5f5e151916c46c3ebbe6649602cba5c3b89d28a6120f354cd333e4d7e86e21b66ec10b4f4e0658464fbe2a4ccfc028d45ccf73a2be22f9edd950b91a094e709e60ac1368f356e3132eb2a4918b645bd0d249c9d1513761c9d1c3637ea4f9c4577914c6d24d8d6c84bc1e83b04c05a425ae7075c1fd30e9ccc2517af0c3b62e83731346b90d8b7f47d2f1da6556402350609d647312bd12db35f8a127e53632e3265c7492899e47b7b8833f39cbd49c51613eda73ad8819bd7dce8e1426a8e9bfa32bf52a0065312a14dd51985a779505b7404d32a797d98f95fe9a1388a9b3e9d19100a41c577457a64c84126f1b84055cd821ddc6aba117f1e0930e306ecb961e1a39c6b4b9be623dcf0311c975ee4a49a5942889221d5cf7dff6437e6926adb0fa98378c13cb215c8c91ec79b20522439165ec78e383b3a8091ae096d8df7601975fcfa2c550b431b820524561101ca84917b4a6e2d2adb3cd0792d99c80e2de4a78ecb9bd54b55106eb136c8e9a424772e638862b5337e84a14c7227573a3566ec9d281f68203ad3b8e90cbfe9743dd4112fc2cc1073b32b6fe51167419037dcb8fc0ddb0913fef6d17d3679ba7efc65551f48865fa2046c9be394855f9abb4a0710d24a89bbe284f5b209a0543bbe0b71cd5725125cb1398a6df3bfe2b26fbcb8b05554962fb0d17ca95c7b98cd1d5b06cd945c0ebb5f2cece52ca8b5be76ce577b9f9b315f598bdc09f251581e79420d193e87a717822a85ad0fa3d6e9cf820f7269f44fc70dfe48d0bafc577a14185e58e772811895febabc5adef518e0c6c1a432170b4881c971cd8bfbf7737f68c8d990881baa37ab44aaa526d5f8dd17a921fb8539e4e9c2530e99bc8cabf0e77ecb0b0b4dfb05e2519bcb19c7785f42878636ab11c1b47c375621b640d95270df167a1043012b91b5058750a1a9b7ef6bca3a178fcb893ee5a9c17f51be7398293a866a5ca81bb339de8d422db232be59ae3d725665ff686f7342e5da98ddfd79083428a8f61da8d3817877be2603e7bbc241b979dfc1314c7e6bdbc069174340652a6e598a22a32d63291b7984bf527dd8147ef1c9734f3505f92f5ab33934b035007b34480a6543c0d8b5c70694865d41237d52a3c6881fa9edcf9e86810234b6b1105689a0a19f502d6c79f0d9efba90a224cd82db8d85e1f1cf96ea39b0e70809555c6773f5a0593e64457c2ff0801235a179dd01408c419194395fe5a4ccfb3369510e626443aa52961c02f83590386bdea13b081de2b0cb23ec122375ccab6f29e5138ffd6d2215a549c9d7be3fe4b2963c51efff678c7fca3922a8c50896179396b9adeddfcdd69c1f8f67e91670bf87b52727187c390f3fcc27218986cbd62287fc2b16501d4f2a74b5166ac45f4fed6a4f445b93b2fc81702bfd8451b5c7f7a87ca2cd8b5f00c671f6f73a4ee8ca3b2ee18d40bf2e0c34725f9ab31b1f9d2c86ccb27a422938898d6807aea0e0cc52f7dddd69c5344c6d2a3ebc86b235dd7f8ff11b97436d28289f4df2011cc22af341b49b18181bc58fd24637b58d5408649549fe47da5fbff571009d5fd233d0b83dd1db7757435f42ca5de0229b0662cdad24cf151d3029e077e6e01d0f242c7cd3c8f0cce4f421b0e3e9c006c035ea53014ab9e31ec6b6f5d2b97aa085424aa307b09c4c676352cd04e880fa6d23b19a1be02c9bdd6d2d11c2040a538ffab8a4a0e153e05f27ba094b850cdec3e90e139f9943a3286cb1d4818ec05d868ade7e38bf515af1d32b67d0c7758f29793b5c74e8e05c59bf62e0e363899ebf1ec09aca77f32288c22e3a81ea67c501af545f946360519ae1e4c04715d9e43f5a23808607b6ad8f0aaa75cc886790d0e768bf3c5fe071f82f076e0af671788a6afbdae09e80fbcd31381bb66ab62c3e4e68e49413fce2304016fbbb9d62b5cab45eb74a7da55f333eea28462dc5b7ddd3660a0c6b6bcc4b6a66dec95227de79eee1ff5f747f9de98dffd867db8e6fd7e9adab0b178e41c9a3c66983e731bf0cca6aded587ab2930c34ca1ec969ae46ebbe10cb4b9d68c2e5fe45885e5afdd41eed5f71683daa99b3deea37e70497c3456c66b4ae4fa673377106c222a1aa3885d4b42d13f148242c9a5b772ae5b46dfb0966ea1531dfaa50d2b53dfb6af310f94cb052d7c7b1e5190f6f9dc2c8cc88cd26baca3e508eb456d09b51329832509e4ed0f5dcd9e125305f2cb217b6f77544255eb5edc7b8adda3a7a46053eb98b12507c78dedb4da56953d4be909bdaf8b9b8ebd95cbbc977b9cca80ecbcdc52c623029cea5330bf05a6e4fd45c55dfa8b6ab4c0991be52a87c5c4825d3c33e6b2af733f2461b2350f84b22090b4be6631235bec0657e43521235c60d40b91467539adcd45fdf41613e53c774cce7d99a28133f0ecba414231dce28f22e7e697b369e3178d7c13276444e55b44ca7c4687a4606191a92c8610809e5e147748b0f9429d1c0e38393c177dc05b66e411ebf76c6d10d09ee10d674c9b3556a606ccace20f0f110a3651c017e8b177a3cbe5f842b877cdee76912eac93b927fd8f3e72e7eb51d2fcc18d2183bdc564e9586730068e7e5a28af416dfa119f6292000ede457569dfb0e960e221563489e023a488393065bbe5f31ec1193f127b49e5e56132e13d41a51655ad0522920b1359518f93ef614c62335cb478551f4502225b62951fa24235fc83febd00d2445668800fbf7206683b9ecc4723a6bec539a24b1bb56a71caaa8a0101d0d26dc6c0cd9c02db46b41e803387bbebc6be9d31bcd1d182e177f78ae1410cf15d7b289178f383da68ac73f5b0c168ee5d78fb31b9ae861058a699dc84f89187041d5d9784d9f27b7effc632044f1ad65a494d855c7bef88688fbdf1833dcfd02e8f0623c01e606f41e94ec621d1f33b6e8a90e69a776d53698461c5ffef029c7bd5d65c5d0d5c8254c06d21cacfa6ca9b0a691a440046058e208528373c096e25ed0168cd04225e893b731c6824f4f0128d83fb43252f01f4aeb6e43978aa17bb7bf25f5424d364ff7892fe4837bd79230463624ead5a376995d4fb076d8f2d945b153201483396ddd7a4806629d1238411ad798c2256366918c3708b6b692ac01787f74902169ea08bea09e561a61926dcdd120050272a5a63e73298b8d725b53d9ed71692b8db11d8565ba85275d08d509ced3582dce1a120645285a8b5c35a2e764dd13894ba53772247b0a4a1ce7a65b18961591a78811ad71b4d262e887064e96f5a388c57e2fc234d54285b5b390902c045b07dbce837b1f780068cc992e08705cf633f85a50bce1b9bd211cf814e9ec987a7a08174d99da61c1c9ee232648f65cd2bf9547c704ef20fb4ad57028dc5ca19f4d7dc6a07a207c876493c4f2ff3f8dbe4f29bc1e3f0c9a350b4eb3962fe96754486fda4aa032fc1910278d3b4bcabc91247fcb5168c8f77a2034951180a9f0505f2cb0aafbe56fd5268227a6bd17548f768a668b8639b969761b2d86e349f24efbf1587423d472d6457d3631ab9b91a7ad309ffb4f01c37b50da074dce5e5ad52426ebf0511a8f31f517cdd556af6bc224f745d54d794511cd4dc98a69210d60f0caf9d40fe209b144f203af8485b4b8ed48e85db564b5956c831624f96e6783a141d661ed66bd918055ffba0f8363b6f587d409c369472ca1ff4f24e2166d284dc138a062aff48b6538a10aefe334002bb0c2c19ccaffda14b0f5478a7761d659443adf21ebeb51bf25b2f08091b352bd1a9b206c1ba55ce3eaab64d6815a3f4ad5b8565c59d06d4de64886e564fb32b21ef6ef976026765d2783cb37cab04bc8e73ce8344ba6690a1297a903b1be9e7d11189f8591bb8760119a487e4d1316f34263b0537edfcb3169a094ce64e82a8091941018813d52117214593937a540c26714e40048592a5ec6d6a7bbe293814322eea9773e00cc1a714d9c001d36d2e61019c248ea1977ec4c54dd7b161b4dcec69812bdb229e75531c4431e07ae7f5b49d407d00df2f7e54e68c6d6ecba93a817b6750a93efd3d28f89b146d0827870cb035f4c140c14bf15c77892dc97c51a1bea8bb12a3d72449a9febb584ef764348fcf4a5b2acd512e3ae814b3cbbcfdfe51d1f330b1e594227f730b01ca60cc834593ce2bcdc08b28a769ca7b5cafeab1acd74b970d08f90ae6388ea9fcfe4e8b1d4e7e86aeec5dbe0dddeac564fb372396aeb58fd06ace81b0ee4f2ee13105326df367c2cc74184581af73d542041a464ee44c94c024b80a4870af54ff33641b5daadd592d6e9ebbf29ef505cfcb6968b8a28ec77da263ec38983ae301a5a373be648518ae3eedf3decbc264a0de2e72ecdd75e25331a3a0b22fe0af91f0314c0d2c67b12d7239cab1d0874e7e5b887ba33ff7d46ad9469b84ea6a2d5231868ea75b0c3883f5fb41b009213dc99160bdbb584517dd478a2105f8324118c53e6ea057aaebef438861bbe4ee5a58b5c5072551b6ba224c8f00f1d077d6efde112fc034baad7e0ae05acfd7375712ad8349c9e8c3935eb9f1cb7ac3d8836af2fb0f86ad3e43e0957c4bec35dadb67c53d339e01eba36645d6847c6d68596a17cfdea24dc52493d5e3e7fb9bf735a2f8a110f962bea57cffdaf595fc973fd915cc512c49ef5d31257dbe8847531a05ea602006ac0784fb29b93efa6f763e913d7bfe1f8afdfac85983a13ceeca2f576946404738c3d5763c586dbd5ddea84b4d51181549e416d2c9bfeec85bee6413362479de9a4bde0deae3f2f135c8d2566fe3f79a652acfcc4569d68ec6b9906892f0828c5ffdc111e398b9d96f272cbcbaea7cd231796458d111fbcce579052eb395e92745f0e658b68f4fd5c8db7b5b664f780d9c2c39b6bb90b9eb3d889ef9d54d71f69622d8999b9984056e78b65104a1ded33de34ff2ec23799df91bbb118fd2d35c63b825168215be40d14b97a600f11f2acfa2a595ccad024d23d0f875b473f445821dbd4b54d60de8c72ad331bdeb49e323da4dda1d705cd9eeef0533e2c648c25bac263cae778eac4de13f19ba82396e374a489b310d4d41d2a7ec228943dacb2ef40a7b77a302794f2197d6e74403232f4eaca30e7c45e47bd864f20f5f139b56935a87d6d65b91b5f6310fa8368d92b64711820ec54b4ef0afa6ad52bc1663b600d94922c6446a5517a6c9591ff2d6d34b5a5ee0d83beae4253061aedaad5e9a09b18ca8b055269db0d7203d9b5f2518f5bf7964a60628c6e19d64546102efb9ff87c37a984b89fd2cceba013a8b6639707451a940725e291d22769944eca80f703e321ae951401a77bb278c1f95ed3918d5c6ffa9585601c1c985f832f13c1fc157383aaa9f02a3c8c3adecc2ee8ced7d153b04255893b2a6f76c7674e713c63db9699f7ea3d8724e3002a414ed41f945152f81aebbf8701ad0d352c953e0777f008c6073a2a5ee11a503cbd4e1d0cb76be0da9fa13216c571b9bd4e36fc7f343ea4ec1cd61701386da014aa8adad328b71c28a50a88ad5119a1ef841a44e368e75da6ca528d627e162f731abac031e6fb5c900c181c3f74f5f9abc5e86d6e8fb29c7d46dd94176a59dfc930f32db13f5d27eff529b973eef379381f9ab6537987b0b8d598676f8f27b3b116d0e9bff76b02056182eb555fba061f5f7d19ca0c593d2546fd9d8ddb71524811da1987bc809fb09923b73f2d46aec81386e385b05ae09dc556da1c847f74ff00244ae227f7bbad6cf9af83843e1660899020221232d06ef59e2df1d84166a9e4e693ddc98e2568a72028764b5dcf815b738c5f17baf4057c314b759d5e68fe74723e5800463cb31669ebbb1419d5cec686951747e324456226db023b3078bf0d945474e386a956096c83d1d7fa935634067c12171bd47351c3d7c02de5a65f56b32bef8073f3fffdacf0d185abf7d987743a90d923ae7fc927ec750c144339890ed0abac99a046915eefad409039642fe6ee17ebe792d5dd5f5582e85af60d08be459200701c822440eb6d2ebe44caf1afe657536805dc80050083eb04a670b65a175c2b8683c353cc0fc3ccd9d01c5fb555cc5f6f9b9bbfd39a761b802e84a23484fa3b82240a36aff54621401dc0a7e93120d4595db1ad86714e0b78f4e18a7f4528736fe1a30f82eea30f56098e6817e4a09129ab8595f3daac9fde8d8814fb2ad2e23605346d0de643518a9dbba359f180fd0db77af843b2d7a629bec222def3e2ebbeceefac0ed8e3aa9b00ac47f021514bf7182103f3b2d5e86f9fc17c30ed3077eed0307c94f896c0db8c4061968c67c1317855e9492030433b9bc852dcc0f1fe83bc473b9c35a6a43c0dd76b06e1e725d00eb3aa4814e28f099a4048ea3f347426835227efba1ef0bb764d512663a47448d3b231c8b813f354d12be0bb87a0faf955b4e2a40c8b32dbe951a76fb68a140afb921a4d73abe1f9309803b090e06689c456fefb2218b17521f8e6f1366810fa849baba4d057a61a5ab41e89c6cb08b2f934d4d17945dfcac9feb43ccdf220c2c1252f45332be4b7ea756c902ce15bc584b27ddd999651527375ee2fdda52653ef236358b8d853477b209</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 880(Div. 2)</title>
      <link href="/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/"/>
      <url>/2023/06/29/Codeforces%20Round%20880%20(Div.%202)/</url>
      
        <content type="html"><![CDATA[<p>挂个传送门：<a href="https://codeforces.com/contest/1836">Dashboard - Codeforces Round 880 (Div. 2) - Codeforces</a></p><p>评价是，切完ABC蹲大牢</p><h5 id="B-Astrophysicists"><a href="#B-Astrophysicists" class="headerlink" title="B. Astrophysicists"></a>B. Astrophysicists</h5><p><strong>题意</strong>：</p><p>$k*g$ 银币分配给 $n$ 人，设一个人分到 $x$ 银币，$r=x \mod g$ 对每人有补正如下：</p><ul><li>若 $r\geq \lceil \frac{g}{2} \rceil$，则向上修正至 $x+(g-r)$；</li><li>否则，向下修正至 $x-r$ .</li></ul><p>求分配完后，剩下的银币数目之和最小值。</p><p><strong>题解</strong>：</p><p>​    什么黑心资本家出的题。</p><p>​    考虑一个人分配到的银币，从 $0$ 增加至 $g$ 。增加至 $\lceil \frac{g}{2}\rceil$ 前，经补正他所获得银币为 $0$ ，原先分配银币即剩下；增加至 $\lceil \frac{g}{2}\rceil$ 后，我们需要额外的银币为其补正。    故对一个人来说，我们的收益和他分配的银币呈一个由两直线构成的分段函数，从 $0$ 开始并且回到 $0$ 。我们的最大收益点在 $p=\lceil \frac{g}{2}\rceil-1$ 。</p><p>​    此时可以分成两种情况讨论：</p><ul><li><p>若 <script type="math/tex">n*p \geq k*g</script> ，那所有人贪心分配（至多 <script type="math/tex">p</script> ），最后每个人分配到 $0$ ，方案显然最优，结果为 <script type="math/tex">k*g</script> 。</p></li><li><p>若<script type="math/tex">n*p< k*g</script>， 最优分配结果为<script type="math/tex">g\lfloor \frac{p*n}{g} \rfloor</script> 。</p></li></ul><p>​    讨论下第二种情况，为什么是这个式子。</p><p>​    易知，最优方案不存在向上修正。设第 $i$ 个人分配到 $x_i$ 银币，则有<script type="math/tex">\sum x_i = k*g</script>，因此我们的收益 <script type="math/tex">income</script> 满足 <script type="math/tex">income=\sum (x_i\% g)\equiv (\sum x_i)\% g\equiv 0</script> 。这是一个比较重要的性质，答案必定是 $g$ 的倍数。</p><p>​    设 <script type="math/tex">income=kg</script> ，则必有 <script type="math/tex">kg \leq p*n</script> （答案上限就是 <script type="math/tex">p*n</script> ），故 <script type="math/tex">income = kg = g \lfloor \frac { p*n } { g } \rfloor</script> </p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, k, g;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; g;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> p = ((g + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p * n &gt;= k * g) &#123;</span><br><span class="line">        cout &lt;&lt; k * g &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; p * n / g * g &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-K-th-equality"><a href="#C-K-th-equality" class="headerlink" title="C. K-th equality"></a>C. K-th equality</h5><p><strong>题意</strong>：</p><p>​    构造第 $k$ 大字典序字符串，其中字符串形如 $A$ 位数 $+B$ 位数 $=C$ 位数。</p><p><strong>题解</strong>：</p><p>​    体感很简单的一道题。</p><p>​    设 $x$ 位数的范围为 $[L_x, R_x)$</p><p>​    由于 $A\leq 6$，因此枚举 $x+y=z$ 中的 $x$ 。</p><p>​    接下来寻找对 $y$ 的限制条件。</p><ul><li>$L_B\leq y&lt;R_B$</li><li>$L_C\leq z&lt; R_C$ ，即 $L_C\leq x+y &lt;R_C$</li></ul><p>​    由此可得限制条件 $max\{L_B,L_C-x\}\leq y&lt;min\{R_B,R_C+x\}$</p><p>​    然后边统计边算即可。复杂度 $O (10^A)$</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mn[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> A, B, C;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mx = mn[A + <span class="number">1</span>], i = mn[A]; i &lt; mx; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(mn[C] - i, mn[B]);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">min</span>(mn[C + <span class="number">1</span>] - i, mn[B + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= r - l) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; l + k - <span class="number">1</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; i + l + k - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> k -= r - l;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-Twin-Clusters"><a href="#E-Twin-Clusters" class="headerlink" title="E. Twin Clusters"></a>E. Twin Clusters</h5><p><strong>题意：</strong></p><p>​    给定长为 <script type="math/tex">2^{k+1}</script> 的一序列，值域为 <script type="math/tex">[0,4^k)</script> 。求原序列两不相交子区间，使得两子区间中数字的异或和相同。</p><p><strong>题解：</strong></p><p>​    瞄了眼 Tutorial ，不太好想。一开始想过类似于分块的思路，实际解法也差不多，不过只取一个块。</p><p>​    先关注二进制下低 <script type="math/tex">k</script> 位。算上空串，共有 <script type="math/tex">2^{k+1}+1</script> 个值，但实际上低 <script type="math/tex">k</script> 位值域 <script type="math/tex">[0,2^k-1]</script> 共 <script type="math/tex">2^k</script> 个值，因此根据鸽巢原理，我们可以匹配出 <script type="math/tex">2^k+1</script> 个区间 <script type="math/tex">(l_i, r_i]</script>，使得这每个区间 <script type="math/tex">S_{r_i} \ xor\ S_{l_i}</script> 的低<script type="math/tex">k</script> 位均为 $0$ 。</p><p>​    接下来关注这些线段的高 <script type="math/tex">k</script> 位。采取同样的方法，根据鸽巢原理，必定存在两个子区间高 <script type="math/tex">k</script> 位的异或和相同，取这两子区间的交即为结果。</p><p><strong>code</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    n = (<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; Line;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    g[<span class="number">0</span>] = s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lbit = (<span class="number">1ll</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hbit = (((<span class="number">1ll</span> &lt;&lt; (k &lt;&lt; <span class="number">1</span>)) - <span class="number">1</span>) ^ lbit);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; g[i];</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ g[i];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = (s[i] &amp; lbit);</span><br><span class="line">        <span class="keyword">if</span> (mp[p] || p == <span class="number">0</span>) Line.<span class="built_in">push_back</span>(<span class="built_in">mp</span>(mp[p], i));</span><br><span class="line">        mp[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Line) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = ((s[line.second] ^ s[line.first]) &amp; hbit);</span><br><span class="line">        <span class="keyword">if</span> (pos[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l1 = Line[pos[p] - <span class="number">1</span>], l2 = line;</span><br><span class="line">            <span class="keyword">if</span> (l1.second &lt;= l2.first) &#123;</span><br><span class="line">                cout &lt;&lt; l1.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.first + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">min</span>(l1.first, l2.first) + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">max</span>(l1.first, l2.first) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; l1.second + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                     &lt;&lt; l2.second &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> pos[p] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="D-Lottery"><a href="#D-Lottery" class="headerlink" title="D. Lottery"></a>D. Lottery</h5><p><strong>题意：</strong></p><p>​    给定 <script type="math/tex">n</script> 个人，每人买一张彩票，票号在 <script type="math/tex">[0,m]</script> 范围内。设开奖号为 <script type="math/tex">x</script> ，则票号距离 <script type="math/tex">x</script> 最近的 <script type="math/tex">k</script> 人中奖，平局情况则编号小的获胜。作为第 <script type="math/tex">n+1</script> 人，你编号最大，求最小位置，使得能够使你中奖的编号尽可能多。</p><p><strong>题解：</strong></p><p>​    非常繁琐的一道题。先来看这幅图（截自 tutorials ）：</p><p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202307021737523.png" alt="image-20230702173756179"></p><p>​    假设当前选择编号为 <script type="math/tex">c</script> ，<script type="math/tex">c</script> 的前 <script type="math/tex">k</script> 名为 <script type="math/tex">a</script> ，后 <script type="math/tex">k</script> 名为 <script type="math/tex">b</script> 。则中奖区间为 <script type="math/tex">(\lfloor \frac{a+c}{2} \rfloor, \lceil \frac{b+c}{2} \rceil)</script> 。由此计算结果。</p><p>​    接下来讨论需要枚举哪些 <script type="math/tex">c</script> 。由上面图可知，处在 <script type="math/tex">(d,e)</script> 区间内时，中奖区间虽然改变，但实际中奖区间长度不变（<script type="math/tex">a</script> 和 <script type="math/tex">b</script> 没有变化）。故我们只需讨论 <script type="math/tex">n</script> 个人所选号码的前后两三个数即可。 当然，特别考虑边界情况。</p><p>​    输入量较大，需要注意 <script type="math/tex">IO</script> 效率。</p><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; v;</span><br><span class="line"><span class="type">int</span> nowl, nowr;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calc</span><span class="params">(<span class="type">long</span> <span class="type">long</span> now_pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nowl &lt; n &amp;&amp; v[nowl] &lt; now_pos) ++nowl;</span><br><span class="line">    <span class="keyword">while</span> (nowr &lt; n &amp;&amp; v[nowr] &lt;= now_pos) ++nowr;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posl = nowr - k &lt; <span class="number">0</span> ? <span class="number">0</span> : (now_pos + v[nowr - k]) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> posr = nowl + k - <span class="number">1</span> &gt;= n ? m : (now_pos + v[nowl + k - <span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0ll</span>, posr - posl + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        v.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    nowl = nowr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res_pos = <span class="number">0</span>, ans = <span class="built_in">calc</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> bl = i == <span class="number">0</span> ? <span class="built_in">max</span>(<span class="number">0ll</span>, v[i] - <span class="number">2</span>) : <span class="built_in">max</span>(v[i] - <span class="number">2</span>, v[i - <span class="number">1</span>] + <span class="number">3</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> br = <span class="built_in">min</span>(v[i] + <span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> now_pos = bl; now_pos &lt;= br; now_pos++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">calc</span>(now_pos);</span><br><span class="line">            <span class="keyword">if</span> (p &gt; ans) &#123;</span><br><span class="line">                ans = p;</span><br><span class="line">                res_pos = now_pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res_pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="F-Doctor’s-Brown-Hypothesis"><a href="#F-Doctor’s-Brown-Hypothesis" class="headerlink" title="F. Doctor’s Brown Hypothesis"></a>F. Doctor’s Brown Hypothesis</h5><p><strong>题意：</strong></p><p>​    给定一有向图，求无序点对 <script type="math/tex">(u, v)</script> 的数目，使得 <script type="math/tex">u</script> 和 <script type="math/tex">v</script> 相互之间存在着长度为 <script type="math/tex">k</script> 的路径，其中 <script type="math/tex">u=v</script> 也被允许。</p><p><strong>题解：</strong></p><p>​    不会。稍微翻译下 tutorial 。</p><p>​    突破口在 <script type="math/tex">k\geq n^3</script> 。显然对于所有满足答案的点对，两点都在同一个强连通分量内。于是讨论范围缩减到同一个 <script type="math/tex">SCC</script> 。对强连通分量内的所有环的大小，存在一个最大公约数 <script type="math/tex">g</script> 。将所有的边 <script type="math/tex"><s,t></script> 按照 <script type="math/tex">t=(s+1)mod\ g</script> 进行染色。由于 <script type="math/tex">k</script> 比较大，所以可以认为颜色相同的点都是等价的。</p><p>​    对于一个连通分量内，满足条件的点对有以下两种：</p><ul><li>$g|k$ ，则所有颜色相同点对满足条件。</li><li>$2|g$ 且 $k\equiv g/2\ mod \ g$ ，则所有颜色差值为 $g/2$ 的点对满足条件</li></ul><p><strong>code：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[N];</span><br><span class="line"><span class="type">int</span> col[N], cnt_col;</span><br><span class="line"><span class="type">int</span> _stack[N], <span class="type">_t</span>, dfn[N], low[N], cnt, siz[N];</span><br><span class="line"><span class="type">bool</span> book[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//强连通分量</span></span><br><span class="line">    dfn[x] = low[x] = ++cnt;</span><br><span class="line">    _stack[++<span class="type">_t</span>] = x;</span><br><span class="line">    book[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[ver]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ver);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[ver]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book[ver]) low[x] = <span class="built_in">min</span>(low[x], dfn[ver]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        ++cnt_col;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = _stack[<span class="type">_t</span>];</span><br><span class="line">            col[p] = cnt_col;</span><br><span class="line">            ++siz[cnt_col];</span><br><span class="line">            book[p] = <span class="literal">false</span>;</span><br><span class="line">            --<span class="type">_t</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag[N], dis[N];</span><br><span class="line"><span class="type">bool</span> solved[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    dis[x] = d;</span><br><span class="line">    flag[x] = des;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[ver] != des) <span class="built_in">dfs</span>(ver, d + <span class="number">1</span>, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试染色</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    <span class="type">bool</span> Flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) Flag &amp;= <span class="built_in">draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">        <span class="keyword">else</span> Flag &amp;= (num[ver] == ((num[x] + <span class="number">1</span>) % base_num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt_num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Draw_col</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now, <span class="type">int</span> base_num, <span class="type">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//染色，统计数目</span></span><br><span class="line">    num[x] = now;</span><br><span class="line">    tag[x] = des;</span><br><span class="line">    ++cnt_num[now];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ver: vec[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[ver] != des) <span class="built_in">Draw_col</span>(ver, (now + <span class="number">1</span>) % base_num, base_num, des);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: v[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[i] == col[y]) vec[i].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> search_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solved[col[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        solved[col[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[col[i]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x = i, y = vec[x][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, <span class="number">0</span>, y);</span><br><span class="line">        d += dis[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= d; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d % j != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> p = j, rem_num = <span class="number">1</span>;</span><br><span class="line">            <span class="type">bool</span> now_flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (d % p == <span class="number">0</span>) &#123;</span><br><span class="line">                ++search_num;</span><br><span class="line">                <span class="keyword">if</span> (now_flag &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, p, search_num)) rem_num = p;</span><br><span class="line">                <span class="keyword">else</span> now_flag = <span class="literal">false</span>;</span><br><span class="line">                p *= j;</span><br><span class="line">            &#125;</span><br><span class="line">            d /= (p / j);</span><br><span class="line">            g *= rem_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span> &amp;&amp; (++search_num) &amp;&amp; <span class="built_in">draw_col</span>(x, <span class="number">0</span>, d, search_num)) g *= d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) cnt_num[j] = <span class="number">0</span>;</span><br><span class="line">        ++search_num;</span><br><span class="line">        <span class="built_in">Draw_col</span>(x, <span class="number">0</span>, g, search_num);</span><br><span class="line">        <span class="keyword">if</span> (k % g == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g; j++) ans += <span class="number">1ll</span> * cnt_num[j] * (cnt_num[j]+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; k % g == g / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g / <span class="number">2</span>; j++) ans += <span class="number">1ll</span> * cnt_num[j] * cnt_num[j + g / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当我开始真正爱自己</title>
      <link href="/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/"/>
      <url>/2023/06/29/%E5%BD%93%E6%88%91%E5%BC%80%E5%A7%8B%E7%9C%9F%E6%AD%A3%E7%88%B1%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<p><em>作者：卓别林</em></p><p>当我真正开始爱自己，</p><p>我才认识到，所有的痛苦和情感的折磨，</p><p>都只是提醒我：活着，不要违背自己的本心。</p><p>今天我明白了，这叫做“真实”。</p><p>​    </p><p>当我真正开始爱自己，</p><p>我才懂得，把自己的愿望强加于人，</p><p>是多么的无礼，就算我知道，时机并不成熟，</p><p>那人也还没有做好准备，</p><p>就算那个人就是我自己。</p><p>今天我明白了，这叫做“尊重”。</p><p>​    </p><p>当我开始爱自己，</p><p>我不再渴求不同的人生，</p><p>我知道任何发生在我身边的事情，</p><p>都是对我成长的邀请。</p><p>如今，我称之为“成熟”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我才明白，我其实一直都在正确的时间，</p><p>正确的地方，发生的一切都恰如其分。</p><p>由此我得以平静。</p><p>今天我明白了，这叫做“自信”。</p><p>​    </p><p>当我真正开始爱自己，</p><p>我不再牺牲自己的自由时间，</p><p>不再去勾画什么宏伟的明天。</p><p>今天我只做有趣和快乐的事，</p><p>做自己热爱，让心欢喜的事，</p><p>用我的方式、我的韵律。</p><p>今天我明白了，这叫做“单纯”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我开始远离一切不健康的东西。</p><p>不论是饮食和人物，还是事情和环境，</p><p>我远离一切让我远离本真的东西。</p><p>从前我把这叫做“追求健康的自私自利”，</p><p>但今天我明白了，这是“自爱”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我不再总想着要永远正确，不犯错误。</p><p>我今天明白了，这叫做“谦逊“。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我不再继续沉溺于过去，</p><p>也不再为明天而忧虑，</p><p>现在我只活在一切正在发生的当下，</p><p>今天，我活在此时此地，</p><p>如此日复一日。这就叫“完美”。</p><p>​    </p><p>当我开始真正爱自己，</p><p>我明白，我的思虑让我变得贫乏和病态，</p><p>但当我唤起了心灵的力量，</p><p>理智就变成了一个重要的伙伴，</p><p>这种组合我称之为，“心的智慧”。</p><p>我们无须再害怕自己和他人的分歧，</p><p>矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界，今天我明白，这就是“生命”。</p>]]></content>
      
      
      <categories>
          
          <category> 诗歌 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="青春无悔不死">
<meta property="og:type" content="website">
<meta property="og:title" content="mlger">
<meta property="og:url" content="https://example.com/page/3/index.html">
<meta property="og:site_name" content="mlger">
<meta property="og:description" content="青春无悔不死">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lg">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>mlger</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">mlger</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/11/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C05-%E8%BF%90%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C05-%E8%BF%90%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">谢希仁计算机网络05-运输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-22 08:14:00" itemprop="dateCreated datePublished" datetime="2023-11-22T08:14:00+08:00">2023-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-05 08:58:53" itemprop="dateModified" datetime="2024-01-05T08:58:53+08:00">2024-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="运输层概述">5.1 运输层概述</h3>
<h5 id="基础知识补充">5.1.1 基础知识补充</h5>
<p>​ 从 IP 层来说，通讯主体是两台主机。但从运输层的视角来看，真正进行通信的实体一台主机中的一个<strong>进程</strong>与另一台主机一个的<strong>进程</strong>。</p>
<p>​ 因此，运输层有一个比较重要的功能——<strong>复用 (multiplexing) </strong>和<strong>分用 (demultiplexing)</strong>。复用是指发送端不同应用程序可以使用同一个运输层传输协议。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121160059831.png" alt="" /><figcaption>image-20231121160059831</figcaption>
</figure>
<p>​ 由图观之，网络层为主机之间提供逻辑通信，而运输层为进程之间提供逻辑通信。</p>
<h5 id="运输层的端口">5.1.2 运输层的端口</h5>
<p>​ 单个计算机用的是进程标识符，但由于计算机操作系统种类很多，因此使用该种进程标识符来表示进程并不合适。</p>
<p>​ 此外，由于进程创建撤销均是动态的，通信一方几乎无法识别对方机器上的进程，因而将特定进程指名为终点是不可行的。</p>
<p>​ 解决方案是运输层采用<strong>协议端口号 (protocol port number)</strong>，或简称为<strong>端口 (port)</strong>。这种抽象的协议端口是<strong>软件端口</strong>。端口号只具有<strong>本地意义</strong>，只是为了标志<strong>本计算机</strong>应用层中的各个进程在运输层交互时的层间接口。不同计算机相同端口号是<strong>没有关联</strong>的。</p>
<p>​ 运输层端口号分为两大类：</p>
<ul>
<li><strong>服务器端使用的端口号</strong>：又分为两种
<ul>
<li>熟知端口号：又称<strong>系统端口号</strong>。</li>
<li>系统端口号：又称<strong>短暂端口号</strong>，通信结束就回收可给其它进程使用。</li>
</ul></li>
</ul>
<h5 id="运输层两个协议">5.1.3 运输层两个协议</h5>
<p>​ <strong>用户数据报协议 UDP (User Datagram Protocol)</strong>：传输前无需建立连接，不提供可靠交付，且较为简单。</p>
<p>​ <strong>传输控制协议 TCP (Transmission Control Protocol)</strong>：提供<strong>面向连接</strong>的服务，但不提供广播或多播服务，较为复杂。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121162255202.png" alt="" /><figcaption>image-20231121162255202</figcaption>
</figure>
<p>​ 接下来将详细阐述两个协议的内容及要点。</p>
<h4 id="用户数据报协议-udp">5.2 用户数据报协议 UDP</h4>
<p>​ UDP 有主要特点如：</p>
<ul>
<li>UDP 是无连接的。</li>
<li>UDP 使用尽最大努力的交付。</li>
<li>UDP 是面向报文的。直接将来自应用程序的报文添加首部后即交付 IP 层，因此报文大小的缺点需由应用程序负责。</li>
<li>UDP 无拥塞控制。</li>
<li>UDP 支持<strong>一对一</strong>、<strong>一对多</strong>、<strong>多对一</strong>和<strong>多对多</strong>交互通信。</li>
<li>UDP 首部开销小，止 8 字节。</li>
</ul>
<p>​ 首部格式如图：</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121162325100.png" alt="" /><figcaption>image-20231121162325100</figcaption>
</figure>
<p>​ 若接收方发现收到端口号不正确，则丢弃并由网际控制报文协议 ICMP 发送”端口不可达“差错报文。</p>
<p>​ ”伪首部“的出现是为了计算检验和，在实际传输中并不存在。检验和为 UDP 数据报每一个 16 位字之和的反码，到接收端再与每一 16 位字相加，最终结果为全 1 即无差错。</p>
<h4 id="传输控制协议-tcp-概述">5.3 传输控制协议 TCP 概述</h4>
<h5 id="tcp-协议主要特点">5.3.1 TCP 协议主要特点</h5>
<ol type="1">
<li><strong>面向连接</strong>，使用前建立连接，使用后释放连接。</li>
<li>只能是<strong>点对点</strong>的通信。</li>
<li>提供<strong>可靠交付</strong>，无差错，不丢失，不重复，且按序到达。</li>
<li>提供<strong>全双工通信</strong>。</li>
<li>面向<strong>字节流</strong>。流是指<strong>流入到进程或从进程流出的字节序列</strong>。</li>
</ol>
<h5 id="tcp-的连接">5.3.2 TCP 的连接</h5>
<p>​ TCP 连接的端点叫<strong>套接字 (socket)</strong> 或<strong>插口</strong>，我们由： <span class="math display">\[
socket = (IP:port)\\
TCP\ link::=\{socket1,socket_2\}=\{(IP_1:port_1),(IP_2:port_2)\}
\]</span></p>
<h4 id="可靠传输工作原理">5.4 可靠传输工作原理</h4>
<p>​ 理想传输条件两大特点：</p>
<ul>
<li>传输信道不产生差错。</li>
<li>不论发送端以多快速度发送数据，接收端总来得及处理收到数据。</li>
</ul>
<h5 id="停止等待协议">5.4.1 停止等待协议</h5>
<p>​ 假定 A 与 B 之间进行通讯。</p>
<h6 id="无差错情况">5.4.1.1 无差错情况</h6>
<p>​ 无差错时，A 发予 B 一个分组，B 接受后对 A 发送该分组的确认，A 收到确认后继续发送下一分组，如此往复。</p>
<h6 id="出现差错">5.4.1.2 出现差错</h6>
<p>​ B 接受到分组时除了差错并丢弃，或是分组在传输中丢失，B 都不会发送任何消息。A 过了一段时间没收到确认，就执行<strong>超时重传</strong>。为实现超时重传，每发送一个分组设置一个<strong>超时计时器</strong>。若计时器到期前收到确认，则撤销计时器。</p>
<ul>
<li>A 发送完分组必须保存副本以备重传。</li>
<li>分组与确认分组必须<strong>编号</strong>。</li>
<li>重传时间应稍大于平均往返时间，提升效率节省资源。</li>
</ul>
<h6 id="确认丢失与确认迟到">5.4.1.3 确认丢失与确认迟到</h6>
<p>​ 倘如 B 接收到分组 <span class="math inline">\(M_1\)</span>，但发回 A 的确认丢失，A 执行重传，B 又收到了相同的分组，此时应作两个动作：</p>
<ul>
<li><strong>丢弃重复分组。</strong></li>
<li><strong>向 A 发送确认。</strong></li>
</ul>
<p>​ 这种可靠传输协议通常称<strong>自动重传请求 ARQ (Automatic Repeat reQuest)</strong>。</p>
<p>​ 重传协议的优点是简单，但缺点是信道利用率低。 <span class="math display">\[
U = \frac{T_D}{T_D+RTT+T_A}
\]</span> <img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121184735026.png" alt="image-20231121184735026" /></p>
<p>​ 为了提高传输效率，我们采用<strong>流水线传输</strong>。为此引出下面一堆芝士。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121184822027.png" alt="" /><figcaption>image-20231121184822027</figcaption>
</figure>
<h5 id="连续-arq-协议">5.4.2 连续 ARQ 协议</h5>
<p>​ 核心概念是<strong>窗口</strong>，窗口大小设定为 size。</p>
<p>每次，发送端将窗口内连续的分组全部发送出去，接收端采用<strong>累计确认</strong>方式，对按序到达的最后一个分组发送确认。发送端每收到一个确认，就进行调整把滑动窗口前移。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121184940413.png" alt="" /><figcaption>image-20231121184940413</figcaption>
</figure>
<h4 id="tcp-报文段首部格式">5.5 TCP 报文段首部格式</h4>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121185758124.png" alt="" /><figcaption>image-20231121185758124</figcaption>
</figure>
<ul>
<li><strong>确认号</strong>：期望收到下一个报文段的第一个数据字节的序号。</li>
</ul>
<blockquote>
<p>若确认号 = N，则表明：到序号 N-1 为止所有的数据都已经收到。</p>
</blockquote>
<ul>
<li><strong>紧急 URG (URGent)</strong>：置为 1 时，紧急指针字段有效，应尽快传送。</li>
<li><strong>确认 ACK (ACKnowledgment)</strong>：置为 1 时确认号才有效。TCP 规定建立连接后所有报文段 ACK 都必须置为 1。</li>
<li><strong>同步 SYN (SYNchronization)</strong>：置为 1 表示是一个连接请求或连接接受报文。</li>
<li><strong>窗口</strong>：接收方让发送方设置其发送窗口的依据。窗口字段指出了现在允许对方发送的数据量。窗口值经常动态变化着。</li>
<li><strong>紧急指针</strong>：指出紧急数据字节数。</li>
<li>选项
<ul>
<li>TCP 最初只规定一种选项，<strong>最大报文长度 MSS (Maximum Segment Size)</strong>，指的是每一个 TCP 报文段<strong>数据字段最大长度</strong>，默认值为 536 字节。</li>
<li>后续增加<strong>窗口扩大</strong>选项，TCP 首部窗口是 16 位，窗口扩大选项占 3 字节，其中一个字节表示移位值 S，位数从 16 增大到 (16 + S)，且 S 最大值为 14。无需扩大时，可以发送 S = 0 的选项。</li>
<li><strong>时间戳</strong>，一是用于计算往返时间 RTT，二是处理 TCP 序号溢出的情况。</li>
</ul></li>
</ul>
<h4 id="tcp-可靠传输的实现">5.6 TCP 可靠传输的实现</h4>
<h5 id="补充">5.6.1 补充</h5>
<p>​ TCP 滑动窗口也有可能后缩，但 TCP 标准<strong>墙裂不推荐这么做</strong>。重传机制已如上讲述。</p>
<p>​ 发送缓存暂时存放：</p>
<ul>
<li>发送程序传送给发送方 TCP 准备发送的数据；</li>
<li>TCP 已发送但未收到确认的数据。</li>
</ul>
<p>​ 接收缓存暂时存放：</p>
<ul>
<li>按序到达但尚未被接收程序读取的数据；</li>
<li>未按序到达的数据。</li>
</ul>
<p>​ 对于未按序到达的数据，TCP 标注并无明确规定如何处理。一般是待缺失的数据流收到后，再按序交付上层。</p>
<h5 id="超时重传时间的选择">5.6.2 超时重传时间的选择</h5>
<p>​ 采用自适应算法。<strong>RTT：往返时间。RTO：超时重传时间</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121192544945.png" alt="" /><figcaption>image-20231121192544945</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231229104747507.png" alt="" /><figcaption>image-20231229104747507</figcaption>
</figure>
<p>​ <strong>Karn 算法及修正</strong>：计算加权 RTTS 时，不考虑重传段。每重传一次，将 RTO 加倍。</p>
<h4 id="tcp-流量控制">5.7 TCP 流量控制</h4>
<p>​ 流量控制就是<strong>让发送方发送速率不要太快，让接收方来得及接收</strong>。</p>
<p>​ 发送方的窗口不能超过接收方给出的接收窗口的数值。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121194421960.png" alt="" /><figcaption>image-20231121194421960</figcaption>
</figure>
<p>​ 若 B 向 A 发送零窗口后， 又有了存储空间，继续发送 rwnd = 400 的报文段，却于传输途中丢失，A 一直等待 B 的通知，而 B 也一直等待 A 的报文段，若没有其它措施，死锁局面将一直持续下去。为此，TCP 为每个连接设有一个<strong>持续计时器 (persistence timer)</strong>。只要一方收到对方零窗口通知则启动计时器，时间到期则发送零窗口<strong>探测报文段（仅携带 1 字节数据）</strong>。若窗口值确实为 0，就重置，否则死锁局面被打破。</p>
<p>​ TCP 的实现广泛使用 Nagle 算法：若进程把数据逐字节发送到 TCP 缓存，则发送方把第一个数据字节先发送出去，把后面到达的全部缓存。当收到第一个数据字符确认后，再把缓存中所有数据组装成一个报文发送出去，对随后到达的数据缓存。仅当收到前一个段的确认后才发送下一个段。当到达数据已经到达发送窗口大小一般或最大报文长度，就立即发送。 这种算法可以有效提高网络吞吐量。</p>
<p>​ <strong>窗口糊涂综合征：</strong>TCP 接收方缓存已满，而交互式应用进程每次只从接收缓存中读取 1 字节。接收方发回确认，将窗口置位 1 字节。如此下去，效率很低。为解决此问题，可以让接收方等待一段时间，待缓存能容纳一个最长报文段或有一半闲余空间，发出确认报文，并通知当前窗口大小。</p>
<h4 id="tcp-拥塞控制">5.8 TCP 拥塞控制</h4>
<h5 id="拥塞控制一般原理">5.8.1 拥塞控制一般原理</h5>
<p><span class="math display">\[
\sum对资源需求&gt;可用资源
\]</span></p>
<p>​ 拥塞控制即<strong>防止过多数据注入到网络中，可以使网络中路由器或链路不至过载</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121202516053.png" alt="" /><figcaption>image-20231121202516053</figcaption>
</figure>
<p>​ 拥塞控制分为<strong>开环控制</strong>与<strong>闭环控制</strong>两种。开环控制是在设计网络时事先将有关发生拥塞的因素考虑到，但系统运行后就不做改变了。</p>
<p>​ 闭环控制基于环路反馈，有如下措施：</p>
<ul>
<li>检测网络系统以定位拥塞。</li>
<li>将拥塞信息传送到可采取行动的地方。</li>
<li>调整网络系统运行以解决问题。</li>
</ul>
<h5 id="拥塞控制方法">5.8.2 拥塞控制方法</h5>
<p>​ <strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong>四种算法。</p>
<ul>
<li>慢开始：发送方维护一个<strong>拥塞窗口 cwnd (congestion winodw)</strong> 变量，发送时<strong>发送窗口等于拥塞窗口</strong>。以超时为依据判断网络拥塞，自小到大采用倍增增大拥塞窗口。</li>
</ul>
<p><span class="math display">\[
\Delta cwnd =min(N,SMSS)
\]</span></p>
<p>​ 用报文段个数作为窗口大小单位，每经过一个传输轮次，cwnd 加倍。SMSS (Sender Maximum Segment Size) 是指发送方的最大报文段。</p>
<ul>
<li>拥塞避免算法：每经过一个 RTT 就让 cwnd 加 1，呈线性缓慢增长。</li>
</ul>
<p>​ 实际操作中，慢开始和拥塞避免是配合使用的。设定一个 ssthresh 值，cwnd 小于该值，用慢启动；cwnd 大于该值，用拥塞避免；等于二者均可。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231121203427954.png" alt="" /><figcaption>image-20231121203427954</figcaption>
</figure>
<p>​ 超时则门限值置为当前 cwnd 的一半。当 B 端收到无序帧时，仍然发送对最前端已确认帧的确认，当 A 端收到一连三个确认帧，即可视为发生了数据丢失。</p>
<p>​ <strong>快恢复算法</strong>：发送端得知丢失个别报文段，便不进行慢启动，二是置拥塞窗口 sstresh = cwnd = cwnd / 2，并执行拥塞避免算法。</p>
<p>​ 拥塞避免阶段窗口线性增大，称为<strong>加法增大 AI (Additive Increase)</strong>。出现拥塞将门限值调整为原来一半，称为<strong>乘法减小 MD (Multiplicative Decrease)</strong>。二者结合即 AIMD 算法。</p>
<p>​ 同时发送窗口不得超过接收端窗口上限 rwnd。故有： <span class="math display">\[
发送窗口上限 = min[rwnd,cwnd]
\]</span></p>
<h5 id="主动队列管理-aqm">5.8.3 主动队列管理 AQM</h5>
<p>​ 路由器队列管理通常按照<strong>先进先出 FIFO</strong> 规则处理到来数据，当队列满时丢弃后续到达所有分组，称为<strong>尾部丢弃策略</strong>。但这种做法会导致短时间内大量连接同时进入满开始阶段，称为<strong>全局同步 (global syncronization)</strong>。</p>
<p>​ 为避免这种情况。出现了<strong>主动队列管理 AQM (Active Queue Management)</strong>，当队列长度达到某个警惕值时丢弃到达分组。曾流行的实现方法是<strong>随即早期检测 RED (Random Early Detection)</strong>，描述如下：</p>
<ul>
<li>若平均队列长小于最小门限，则将新分组加入队列。</li>
<li>若超过最大门限，则丢弃新分组。</li>
<li>若介于二者之间，则按某一丢弃概率 p 将新分组丢弃。</li>
</ul>
<h4 id="tcp-运输连接管理">5.9 TCP 运输连接管理</h4>
<p>​ 主动发起连接的进程称为<strong>客户 (client)</strong>，被动等待连接的进程称为<strong>服务器 (sever)</strong>。</p>
<h5 id="tcp-连接的建立">5.9.1 TCP 连接的建立</h5>
<p>​ 三次握手协议：（来自亲爱的 ChatGPT）</p>
<ul>
<li><strong>第一步 - 客户端发送连接请求：</strong>
<ul>
<li>客户端首先向服务器发送一个TCP报文，标志位中设置了SYN（同步）标志，并选择一个初始序列号（Initial Sequence Number）。</li>
<li>这个报文包含了客户端的一些连接参数，如MSS（Maximum Segment Size），表示客户端能够接受的最大报文段大小。</li>
</ul></li>
<li><strong>第二步 - 服务器确认请求并发送自己的连接请求：</strong>
<ul>
<li>服务器接收到客户端的SYN报文后，会回复一个确认报文，其中设置了SYN和ACK（确认）标志。</li>
<li>服务器也会选择一个自己的初始序列号，并在确认中包含自己的一些连接参数，如MSS。</li>
</ul></li>
<li><strong>第三步 - 客户端确认服务器的连接请求：</strong>
<ul>
<li>客户端接收到服务器的确认后，会向服务器发送一个确认报文，其中设置了ACK标志。</li>
<li>这个确认报文不包含SYN标志，因为连接已经建立。</li>
<li>服务器收到这个确认后，连接建立完成。</li>
</ul></li>
</ul>
<h5 id="tcp-连接释放">5.9.2 TCP 连接释放</h5>
<ol type="1">
<li>A 的进程线向其 TCP 发出连接释放报文段，并停止发送数据，主动关闭 TCP 连接。FIN 报文消耗一个序号，即使不携带数据。</li>
<li>B 收到报文段后立即发出确认，确认号 ack = u + 1，从 A 到 B 的连接即释放了，但从 B 到 A 的连接仍未释放，TCP 处于<strong>半关闭</strong>状态。</li>
<li>若 B 依据没有要向 A 发送数据，则发出释放报文，假定序号为 w。A 收到后，必须发出确认，ack = w + 1，序号为 seq = u + 1，经过<strong>等待计时器</strong>设置的时间 2MSL 后， A 进入 CLOSED 状态。，MSL 是<strong>最长报文段寿命</strong>。</li>
</ol>
<p>​ 此外，TCP 设有一个<strong>保活计时器</strong>，每个一段时间发送探测字段，若一连几个都收不到回应，则关闭连接。</p>
<h5 id="tcp-有限状态机">5.9.3 TCP 有限状态机</h5>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231122081330855.png" alt="" /><figcaption>image-20231122081330855</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/11/20/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C04-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C04-%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">谢希仁计算机网络04-网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-20 14:41:00" itemprop="dateCreated datePublished" datetime="2023-11-20T14:41:00+08:00">2023-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-05 16:28:46" itemprop="dateModified" datetime="2024-01-05T16:28:46+08:00">2024-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="网络层提供的两种服务">4.1 网络层提供的两种服务</h4>
<p>​ 电信网采用<strong>面向连接</strong>的通信方式，并在此基础上使用可靠传输协议，当有通信需求时，双方建立<strong>虚电路</strong>进行实时通讯，通讯结束后释放通讯资源。由于终端电话机结构简单，无处理差错能力，因此此方案对电话业务来说是十分合适的。</p>
<p>​ 但计算机网络的终端具有很强的处理差错能力，因此网络层的设计思路为：<strong>网络层向上只提供简单灵活的、无连接、尽最大努力的数据报服务</strong>。<strong>网络层不提供服务质量的承诺</strong>，可靠传输由网络主机中的运输层保障。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118144200510.png" alt="" /><figcaption>image-20231118144200510</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118163954841.png" alt="" /><figcaption>image-20231118163954841</figcaption>
</figure>
<h4 id="网际协议-ip">4.2 网际协议 IP</h4>
<p>​ 与 IP 协议配套的三个协议：</p>
<ul>
<li><strong>地址解析协议 ARP (Address Resolution Protocol)</strong></li>
<li><strong>网际控制报文协议 ICMP (Internet Control Message Protocol)</strong></li>
<li><strong>网际组管理协议 IGMP (Internet Group Management Protocol)</strong></li>
</ul>
<p>​ 三协议关系如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118164422575.png" alt="" /><figcaption>image-20231118164422575</figcaption>
</figure>
<p>​ TCP/IP 协议中的网络层常常被称为<strong>网际层</strong>或 <strong>IP 层</strong>。</p>
<h5 id="虚拟互联网络">4.2.1 虚拟互联网络</h5>
<p>​ <strong>没有一种单一的网络能够适应所有用户的需求</strong>。将网络连接起来需要一些不同的中间设备，一般有如下四种：</p>
<ul>
<li>物理层：<strong>转发器 (repeater)</strong></li>
<li>数据链路层：<strong>网桥</strong>或<strong>桥接器 (bridge)</strong></li>
<li>网络层：<strong>路由器</strong></li>
<li>网络层以上：<strong>网关 (gateway)</strong></li>
</ul>
<p>​ 由于历史原因，许多 TCP/IP 的文献曾把网络层使用的路由器称为网关。</p>
<p>​ 参与互连的计算机网络都是用相同的网际协议 IP，因此可以看作一个大的虚拟互连网络。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118170200174.png" alt="" /><figcaption>image-20231118170200174</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118181737412.png" alt="" /><figcaption>image-20231118181737412</figcaption>
</figure>
<h5 id="分类的-ip-地址">4.2.2 分类的 IP 地址</h5>
<p><span class="math display">\[
IP地址 ::=\{&lt;网络号&gt;,&lt;主机号&gt;\}
\]</span></p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118181859665.png" alt="" /><figcaption>image-20231118181859665</figcaption>
</figure>
<p>​ 其中 D 类地址用于<strong>多播</strong>。</p>
<p>​ <strong>点分十进制表示法</strong>：32 位 IPv4 地址，八位一段点分隔，每段十进制表示。</p>
<p>​ 常用的三种类别 IP 地址</p>
<ul>
<li>A 类地址：
<ul>
<li>网络号占一个字节，第一位固定为 0，共 126 (<span class="math inline">\(2^7-2\)</span>) 个可分配，全 0 表示 "this"，意为“本网络”， 127 (01111111) 保留作为本地软件<strong>环回测试</strong>本主机进程之间通信之用。</li>
<li>主机号占三个字节，因此一个 A 类网络号最大主机数为 <span class="math inline">\(2^{24}-2\)</span> 。全 0 表示本主机连接到的单个网络地址，全 1 表示该网络上的所有主机。</li>
</ul></li>
<li>B 类地址：
<ul>
<li>网络号占两个字节，前两位固定为 10，共 <span class="math inline">\(2^{14}-1\)</span> 个可分配，128.0.0.0不指派。最大主机数 65534，扣除全 0 和全 1。</li>
</ul></li>
<li>C类地址：
<ul>
<li>网络号占三个字节，前三位固定 110，192.0.0.0 不指派，因此 <span class="math inline">\(2^{21}-1\)</span> 个网络号。每个 C 类地址最大主机数 254。</li>
</ul></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118183641070.png" alt="" /><figcaption>image-20231118183641070</figcaption>
</figure>
<p>​ 两个路由器相连，在连线两端的接口处可分配也可不分配 IP 地址。节省资源则不分配，常称为 <strong>无编号网络</strong>或<strong>无名网络</strong>。</p>
<h5 id="ip-地址与硬件地址">4.2.3 IP 地址与硬件地址</h5>
<p>​ <strong>物理地址是数据链路层和物理层使用的地址，</strong>而 <strong>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</strong></p>
<p>​ 在通讯过程，数据从高层下到低层，层层封装，然后才到链路上传输。设备在收到 MAC 帧时，根据首部硬件地址决定收下或丢弃。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118184141275.png" alt="" /><figcaption>image-20231118184141275</figcaption>
</figure>
<p>​ <strong>IP 层抽象的互联网上只能看到 IP 数据报</strong>。</p>
<p>​ <strong>虽然 IP 数据报有源地址，但路由器只根据目的站 IP 地址的网络号进行路由选择</strong>。</p>
<h5 id="地址解析协议-arp">4.2.4 地址解析协议 ARP</h5>
<p>​ 知道 IP 地址，找出其相应的硬件地址。ARP 在主机 ARP 高速缓存 (<strong>APR cache</strong>) 中存放一个有<strong>本局域网</strong>上的各主机和路由器 IP 到硬件地址的映射表，并且映射表经常动态更新。</p>
<p>​ 当 A 向 B 发送 IP 数据报时，先在其 ARP cache 中查找，若查不到，则 ARP 进程广播 ARP 请求分组，除 B 外的主机不响应，B 则响应并向 A 发送 ARP 响应分组（单播），且 B 也将 A 的物理地址写入 cache 中。</p>
<p>​ ARP 解决的是<strong>同一个局域网</strong>上的映射问题。</p>
<h5 id="ip-数据报的格式">4.2.5 IP 数据报的格式</h5>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118200817531.png" alt="" /><figcaption>image-20231118200817531</figcaption>
</figure>
<ul>
<li><strong>版本</strong>：4 位，指版本号，实际使用的只有 IPv4 和 IPv6。</li>
<li><strong>首部长度</strong>：4 位，单位是 32 位字（即 4 字节）</li>
<li><strong>区分服务</strong>：8 位，一般情况不使用</li>
<li><strong>总长度</strong>：首部和数据之和的长度，16 位，因此数据报最大长度为 65535 字节。数据链路层中还有<strong>最大传送单元 MTU (Maximum Transfer Unit)</strong>。</li>
<li><strong>标识</strong>：16 位，每产生一个数据报，计数器 +1，并赋值给标识。</li>
<li><strong>标志</strong>：3 位，但目前只有两位有意义
<ul>
<li>低位 <strong>MF</strong>。 MF = 1 表示后面“<strong>还有分片</strong>”的数据表， MF = 0 则表示当前已是最后一片。</li>
<li>中间为 <strong>DF</strong>。当前仅当 DF = 0 时允许分片。</li>
</ul></li>
<li><strong>片偏移</strong>：13 位，顾名思义，该片从何处开始。</li>
<li><strong>生存时间</strong>：8 位，没经过一个路由， TTL 减去 1，减为 0 时，就丢弃数据报。</li>
<li><strong>协议</strong>：8 位，指出使用的协议</li>
<li><strong>首部检验和</strong>：16 位，，只检验数据报首部，但不包括数据部分。发送方，检验和置位剩余 16 位字的反码之和。接收方将检验和在内的所有 16 位字相加，若首部未变化，其和必为 0。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118202056828.png" alt="" /><figcaption>image-20231118202056828</figcaption>
</figure>
<ul>
<li><strong>源地址</strong>：32 位</li>
<li><strong>目的地址</strong>：32 位</li>
</ul>
<h5 id="ip-层转发分组的流程">4.2.6 IP 层转发分组的流程</h5>
<p>​ 路由表信息： <span class="math display">\[
(目的网络地址, 下一跳地址)
\]</span> <img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118202909343.png" alt="image-20231118202909343" /></p>
<p>​ 存在<strong>特定主机路由</strong>，对特定的主机指明一个路由，以便管理人员控制网络和测试网络。</p>
<p>​ 存在<strong>默认路由</strong>，减小路由表所占的空间和搜索路由表所用的时间。</p>
<blockquote>
<p>默认路由（Default Route）是网络中的一种路由设置，用于指定当路由表中没有匹配的路由项时，数据包应该被发送到的下一个跃点或下一跳。默认路由通常用于简化路由表，特别是在大型网络中。</p>
</blockquote>
<blockquote>
<p>在IPv4网络中，默认路由通常使用0.0.0.0/0表示，这表示所有目标地址。当路由表中没有与目标地址匹配的具体路由项时，数据包将被发送到默认路由指定的下一个跃点。这有助于简化路由表，特别是在较大的网络中，减少路由表的大小和复杂性。</p>
</blockquote>
<blockquote>
<p>在IPv6网络中，类似的概念是使用::/0来表示所有IPv6地址。当没有与目标IPv6地址匹配的具体路由项时，数据包将被发送到默认路由指定的下一个跃点。</p>
</blockquote>
<p>​</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231118203422006.png" alt="" /><figcaption>image-20231118203422006</figcaption>
</figure>
<p>​ <strong>分组转发算法的流程</strong>：</p>
<ol type="1">
<li>从数据报首部提取目的主机 IP 地址 D，得出网络地址 N。</li>
<li>若 N 就是与此路由连接的某个网络，则 <strong>直接交付</strong>；否则执行 3。</li>
<li>若路由表有目的地址为 D 的特定主机路由，则交给其指明的下一跳；否则 4。</li>
<li>若路由表中有到达 N 的路由，则交给其指明的下一跳，否则 5。</li>
<li>默认路由，否则 6。</li>
<li>报错</li>
</ol>
<h4 id="划分子网与构造超网">4.3 划分子网与构造超网</h4>
<h5 id="划分子网">4.3.1 划分子网</h5>
<p>​ IP 地址设计不合理之处：</p>
<ul>
<li>IP 地址空间利用率有时很低，一个网络号所连接的主机可能并不多。</li>
<li>每个物理网络分配一个网络号会使得路由表太大而使网络性能变坏。</li>
<li>两级 IP 不够灵活，有时需要开辟一个新的网络，此时只能申请一个新的网络号。</li>
</ul>
<p>​ 划分子网的方法： <span class="math display">\[
IP地址:=\{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;\}
\]</span> ​ 从 IP 数据报首部<strong>无法看出</strong>源主机或目的主机所连接的网络是否进行了子网划分，<strong>子网掩码</strong>正是用于解决这个问题的。</p>
<p>​ 子网掩码一般由一串连续的 1 和一串连续的 0 构成，且 1 的长度等于网络号与子网号位数之和，因此与 IP 地址进行<strong>与</strong>操作即可得出子网地址。 如果一个网络不划分子网，则使用默认子网掩码，显然，</p>
<p>​ A 类地址默认掩码为 255.0.0.0，或 0xFF000000。</p>
<p>​ B 类地址默认掩码为 255.255.0.0，或 0xFFFF0000。</p>
<p>​ C 类地址默认掩码为 255.255.255.0，或 0xFFFFFF00。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119102550234.png" alt="" /><figcaption>image-20231119102550234</figcaption>
</figure>
<h5 id="使用子网时的分组转发算法">4.3.2 使用子网时的分组转发算法</h5>
<p>​ 路由表包含：<strong>目的网络地址、子网掩码</strong>和<strong>下一跳地址</strong>。</p>
<ol type="1">
<li>从收到的数据报提取 IP 地址 D。</li>
<li>各网络子网掩码与 D 相与，看看是否匹配，若匹配则直接交付，否则 3。</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则交付之，否则 4。</li>
<li>对路由表每一行子网掩码与 D 相与，结果为 N，若 N 与该行目的网络的地址匹配，则交付给下一跳，否则 5。</li>
<li>默认路由，否则 6。</li>
<li>报错。</li>
</ol>
<h5 id="无分类编址-cidr-超网">4.3.3 无分类编址 CIDR （超网）</h5>
<p><span class="math display">\[
IP 地址:=\{&lt;网络前缀&gt;,&lt;主机号&gt;\}
\]</span></p>
<p>​ 网络前缀相同的连续 IP 地址组成一个 ”CIDR 地址块”。</p>
<p>​ CIDR 使用斜线激发，即 IP 地址后加上斜线 “/”，后写上前缀位数。</p>
<p>​ CIDR 还使用 32 位的地址掩码，其中前一串 1 就代表前缀。</p>
<p>​ 路由表中用 CIDR 地址块来查找目的网络，称为<strong>路由聚合</strong>或<strong>构造超网</strong>。</p>
<p>​ 在查找下一跳时，可能有多个 CIDR 地址块都能够与目的地址匹配，此时则根据<strong>最长前缀匹配</strong>原则确定下一跳。</p>
<p>​ 由于要进行最长前缀匹配，故最方便的方法即是在构造路由表时采用<strong>二叉线索</strong>，即 01-Trie，然后查询时即可迅速进行前缀匹配。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119105513490.png" alt="" /><figcaption>image-20231119105513490</figcaption>
</figure>
<p>​ 为了提高效率，还可采用各式<strong>压缩技术</strong>。</p>
<h4 id="网际控制报文协议-icmp">4.4 网际控制报文协议 ICMP</h4>
<p>​ ICMP 报文分为 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</p>
<p>​ ICMP 报文前 4 个字节是统一的格式，三个字段：类型、代码和检验和。接着 4 个字节与 ICMP 类型有关。最后面是数据字段，长度取决于 ICMP 类型。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119150429359.png" alt="" /><figcaption>image-20231119150429359</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119150446519.png" alt="" /><figcaption>image-20231119150446519</figcaption>
</figure>
<p>​ <strong>改变路由（重定向）：</strong> 路由器把改变路由报文发送给主机，让主机知道下次该将数据报发送给另外的路由器（可通过更好的路由）。</p>
<p>​ 不应发送 ICMP 差错报告的情况：</p>
<ul>
<li>对 ICMP 差错报文，不再发送 ICMP 差错报文</li>
<li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 报文。</li>
<li>对具有多播地址的数据报，都不发送。</li>
<li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 报文。</li>
</ul>
<p>​ ICMP 的一个重要应用就是<strong>分组网间探测 PING (Packet InterNet Groper)</strong>，是应用层直接使用网络层 ICMP 的一个例子。</p>
<p>​ 另一个重要应用是 traceroute (UNIX) / tracert (windows)，用于跟踪一个分组源点到终点的路径。下介绍其原理：</p>
<p>​ 主要采用数据报中的生存时间 TTL，先发送 TTL 为 1，收到<strong>时间超过</strong>差错报文则 TTL + 1 重新发送，否则收到<strong>终点不可达</strong>报文，且长度即 TTL。</p>
<h4 id="互联网的路由选择协议">4.5 互联网的路由选择协议</h4>
<h5 id="几个基本概念">4.5.1 几个基本概念</h5>
<h6 id="理想路由算法">4.5.1.1 理想路由算法</h6>
<p>​ <strong>理想路由算法</strong>几个特点：</p>
<ul>
<li>必须是正确的和完整的。</li>
<li>计算上应简单。</li>
<li>应能适应通信量和网络拓扑的变化（稳健性）。</li>
<li>应具有稳定性，通信量和网络拓扑相对稳定的情况下，应该收敛于一个可接受的解。</li>
<li>算法应该是最佳的。</li>
</ul>
<h6 id="分层次的路由选择">4.5.1.2 分层次的路由选择</h6>
<p>​ 互联网采用<strong>分层次的路由选择</strong>，原因：</p>
<ul>
<li>互联网规模非常大。</li>
<li>许多单位不愿外界了解自己内部网络的细节。</li>
</ul>
<p>​ 为此，把互联网划分为许多小的<strong>自治系统 AS (autonomous system)</strong>。一个 AS 对其他的 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</p>
<p>​ 故此，路由选择协议可以划分为两类：<strong>内部网关协议 IGP (Interior Gateway Protocol)</strong> 和<strong>外部网关协议 EGP (External Gateway Protocol)</strong>。常用的 IGP 有 RIP 和 OSPF 协议，常用的 EGP 有 BGP-4。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119160651490.png" alt="" /><figcaption>image-20231119160651490</figcaption>
</figure>
<p>​ 此外，路由选择协议还可依照路由表更新方分为<strong>静态路由协议</strong>和<strong>动态路由协议</strong>，常见的动态路由协议有 RIP、OSPF、BGP 等。</p>
<h5 id="rip">4.5.2 RIP</h5>
<p>​ RIP 是一种<strong>基于距离向量的路由选择协议</strong>，最大优点是简单。其中的“距离”是指“<strong>跳数</strong>” (hop count)。但 RIP 一条路径最多只能包含 15 个路由器，因此 RIP 只适用于小型互联网。</p>
<h6 id="rip-特点">4.5.2.1 RIP 特点</h6>
<p>​ RIP 特点：</p>
<ul>
<li>仅和相邻路由器交换信息。</li>
<li>路由器交换的信息是当前本路由器的路由表。</li>
<li>按照固定的时间间隔交换路由信息，如 30 秒。</li>
</ul>
<p>路由表信息为： <span class="math display">\[
(路由表,距离,下一跳)
\]</span></p>
<p>​ 下介绍路由更新算法：</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119161304200.png" alt="" /><figcaption>image-20231119161304200</figcaption>
</figure>
<p>​ 其实就是 Bellman-Fold 算法，不断遍历，能松弛即松弛。</p>
<p>​ 对于解释 3，书中的解释是无论距离是增大减小亦或不变，都要更新为最新的信息。</p>
<h6 id="rip-报文格式">4.5.2.2 RIP 报文格式</h6>
<p>​ RIP 报文格式：</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119161732197.png" alt="" /><figcaption>image-20231119161732197</figcaption>
</figure>
<ul>
<li><p>首部 4 字节，命令字段指出报文意义。</p></li>
<li><p>路由部分由若干路由信息组成，每个路由信息 20 字节。</p>
<ul>
<li><strong>地址标识符</strong> 标志所用地址协议。 <strong>路由标记</strong>填入自治系统号 ASN。</li>
<li>网络地址、子网掩码、下一跳路由地址、距离。</li>
</ul>
<p>一个 RIP 报文最多 25 个路由，故而最大长度 <span class="math inline">\(4+20\times 25=504\)</span> 字节。</p></li>
</ul>
<p>RIP 存在的问题：<strong>当网络出现故障，需要经过比较长的时间才能将此信息传送到所有的路由器</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119163624180.png" alt="" /><figcaption>image-20231119163624180</figcaption>
</figure>
<p>​ RIP 特点总结：<strong>实现简单开销小，距离有限，坏消息传播慢</strong>。</p>
<h5 id="内部网关协议-ospf">4.5.3 内部网关协议 OSPF</h5>
<p>​ <strong>OSPF 开放最短路径优先</strong> 使用了 Dijkstra 提出的<strong>最短路径算法 SPF</strong>。OSPF 三个要点如下：</p>
<ul>
<li>洪泛法：向本自治系统<strong>所有</strong>路由器发送信息。</li>
<li>发送的信息是与本路由器相邻所有路由器的链路状态。</li>
<li>当且仅当链路发生变化，才使用洪泛。</li>
</ul>
<p>​ 由此，每个路由器都能够得到本网完整的网络拓扑，采用 djikstra 算法即可得出最短路径从而构造路由表。</p>
<p>​ 而且 OSPF 将一个自治系统再划分为若干个小的范围，称为<strong>区域 (area)</strong>。连接不同区域的路由器叫<strong>区域边界路由器</strong>。主干区域的路由器称<strong>主干路由器</strong>。OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/image-20231119170556159.png" alt="" /><figcaption>image-20231119170556159</figcaption>
</figure>
<p>​ OSPF 其它特点：</p>
<ul>
<li>允许管理员指派不同代价，代价占 16 位，十分灵活。</li>
<li>若一个目的网络有多条相同代价路径，则可以分配通信量，达到<strong>负载平衡 (load balancing)</strong>。</li>
<li>支持可变长子网划分与 CIDR。</li>
<li>链路可能经常变变化，每条链路带上一个序号，序号越大链路越新。</li>
</ul>
<p>​ OSPF 五种分组类型：</p>
<ul>
<li><p><strong>类型1 问候 (hello) </strong>分组，用于发现维持邻站可达性。</p></li>
<li><p><strong>类型2 数据库描述 (Database Description) </strong>分组，向邻站给出自己库中所有链路状态项目的摘要。</p></li>
<li><p><strong>类型3 链路状态请求 (Link State Request)</strong> 顾名思义</p></li>
<li><p><strong>类型4 链路状态更新 (Link State Update)</strong> 洪泛</p></li>
<li><p><strong>类型5 链路状态确认 (Link State Acknowledgement)</strong> 对更新分组的确认</p></li>
</ul>
<h5 id="外部网关协议-bgp">4.5.4 外部网关协议 BGP</h5>
<p>​ <strong>边界网关协议 BGP</strong>。不同自治系统之间使用 BGP 的缘由：</p>
<ul>
<li>互联网<strong>规模太大</strong>，使得自治系统 AS 之间路由选择非常困难。</li>
<li>自治系统 AS 之间的路由选择必须考虑有关策略。</li>
</ul>
<p>​ BGP 的目的寻找一条能够到达目的且网络条件比较好的路由而非最佳路由，采用<strong>路径向量 (path vector) 路由选择协议</strong>。每个自治系统至少选定一 <strong>BGP 发言人</strong>，往往选定<strong>边界路由器</strong>。发言人之间采用 BGP 协议。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main//newPath/image-20231120080108690.png" alt="" /><figcaption>image-20231120080108690</figcaption>
</figure>
<p>​ 在 RFC 4271 中规定了 BGP-4 的四种报文：</p>
<ul>
<li>OPEN 报文，用来与相邻 BGP 发言人建立关系，使其初始化。</li>
<li>UPDATE 报文，通告某一路由信息，以及列出要撤销的多路由。</li>
<li>KEEPALIVE 报文，周期性证实邻站连通信。</li>
<li>NOTIFICATION 报文，发送检测到的差错。</li>
</ul>
<p>​ BGP 报文格式：</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120080845868.png" alt="" /><figcaption>image-20231120080845868</figcaption>
</figure>
<p>​ 标记 (marker) 段 16 字节长，用于鉴别，不需鉴别是置全 1。</p>
<p>​ 长度字段指出包括首部在内整个 BGP 报文<strong>字节</strong>为单位的长度，最小 19，最大 4096。（查了下，是根据 TCP 协议的滑动窗口决定的 <a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/428983149?bd_page_type=0&amp;pu=&amp;init=middle">这里</a>)</p>
<p>​ UPDATE 和 OPEN 报文的格式暂时不赘述。</p>
<h5 id="路由器的构成">4.5.5 路由器的构成</h5>
<p>​ 路由器结构划分为两大部分：<strong>路由选择部分</strong>和<strong>分组转发部分</strong>。</p>
<p>​ 路由选择部分也称为<strong>控制部分</strong>，核心构建为选择处理机，任务是根据协议构造出路由表，同时不断更新维护路由表。</p>
<p>​ 分组转发部分有三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>。</p>
<p>​ 交换结构 (switching fabric) 又称<strong>交换组织</strong>，作用是根据转发表处理分组，把输入的分组从魔偶个端口输出出去。</p>
<p>​ 为了使交换功能分散化，往往把复制到转发表放在每个输入端口中，称为<strong>"影子副本"</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083022304.png" alt="" /><figcaption>image-20231120083022304</figcaption>
</figure>
<p>​ 最早使用的路由器是普通的计算机，采用 CPU 作为路由选择处理机，利用中断机制启动处理。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083350315.png" alt="" /><figcaption>image-20231120083350315</figcaption>
</figure>
<h4 id="ipv6">4.6 IPv6</h4>
<p>​ 变化：</p>
<ul>
<li><strong>允许协议继续扩充</strong>。</li>
<li>灵活的首部格式</li>
<li>扩展的地址层次结构</li>
</ul>
<p>​ IPv6 数据报有 <strong>基本首部</strong>和<strong>有效载荷</strong>两部分组成，有效载荷也成为<strong>净载荷</strong>。有效载荷允许零个或多个<strong>扩展首部</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083649979.png" alt="" /><figcaption>image-20231120083649979</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120083714488.png" alt="" /><figcaption>image-20231120083714488</figcaption>
</figure>
<ul>
<li><strong>通信量类：</strong> 8 位，区分不同 IPv6 数据报类别或优先级。</li>
<li>流标号 (traffic class)：20 位。</li>
<li>有效载荷长度：除基本首部外的字节数。</li>
</ul>
<p>​ 扩展首部在传输中不进行处理，交给两端计算机处理，大大提高路由器处理效率。</p>
<p>​ IPv6 增加了任播 (anycast) 地址，终点是一组计算机，但数据报只交付其中一个，通常是最接近一个。</p>
<p>​ IPv6 采用<strong>冒号十六进制记法</strong>，如 <span class="math display">\[
68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF
\]</span></p>
<ul>
<li>允许省略前导 0。</li>
<li>可以将一串连续的 0 用一对冒号取代。</li>
<li>仅允许一次零压缩。</li>
<li>仍可采用 CDR 斜线表示法。</li>
</ul>
<p>​ 地址分类：</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120084419498.png" alt="" /><figcaption>image-20231120084419498</figcaption>
</figure>
<h5 id="ipv4-向-ipv6-过渡">4.6.3 IPv4 向 IPv6 过渡</h5>
<p>​ 策略一：<strong>双协议栈</strong>。装有双协议栈的主机或路由器既能与 IPv4 主机通信，又能与 IPv6 主机通信。根据域名系统 DNS 返回的地址类型确定主机使用的地址类型。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120103834796.png" alt="" /><figcaption>image-20231120103834796</figcaption>
</figure>
<p>​ 策略二：<strong>隧道技术</strong>。IPv6 数据报进入 IPv4 网络时，把 IPv6 数据报封装成 IPv4 数据报。要使得双协议栈主机知道 IPv4 数据报内封装的时 IPv6 数据报，则需要将 IPv4 首部的协议字段值设置为 41。</p>
<h5 id="icmpv6">4.6.4 ICMPv6</h5>
<p>​ IPv6 也不保证数据可靠交付，因此采用 ICMP 来反馈差错。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120104137961.png" alt="" /><figcaption>image-20231120104137961</figcaption>
</figure>
<h4 id="ip-多播">4.7 IP 多播</h4>
<p>​ 与单播相比，一对多的网络通信中，多播可大大节约网络资源。</p>
<p>​ 多播组的标识符是 IP 地址中的 D 类地址，范围是 224.0.0.0 到 239.255.255.255。多播地址只能用于目的地址而不能用于源地址。一个 D 类地址表示一个多播组。</p>
<h5 id="网际组管理协-igmp-和-多播路由选择协议">4.7.3 网际组管理协 IGMP 和 多播路由选择协议</h5>
<p>​ IGMP (Internet Group Management Protocol) 网际组管理协议：是让连接在本地局域网上的多播路由器知道本局域网上<strong>是否</strong>有主机参加或退出了某个多播组。</p>
<p>​ 多播路由选择协议：多播转发必须动态适应多播组成员的变化，在转发数据报时，不能仅仅根据数据报中的目的地址，而是考虑从什么地方来到什么地方去。</p>
<p>​ IGMP 属于整个网际协议 IP 的一个组成部分。</p>
<p>​ 多播路由选择协议：洪泛与剪除、隧道技术、基于核心的发现技术。</p>
<h4 id="虚拟专用网-vpn-和网络地址转换-nat">4.8 虚拟专用网 VPN 和网络地址转换 NAT</h4>
<h5 id="vpn">4.8.1 VPN</h5>
<p>​ RFC 1918 指明了一些<strong>专用地址</strong>，只用于机构内部通信，互联网中所有路由器对目的地址为专用地址的数据报一律不予转发。</p>
<p>​ VPN 的作用是对内部数据报进行加密，然后在公网上传输，使得效果跟内网通信一样。</p>
<p><img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120142854286.png" /></p>
<h5 id="nat">4.8.2 NAT</h5>
<p>​ 已经分配到本地 IP 地址，又想进行全球通信，则可使用 NAT。NAT 将每台计算机映射到 NAT 路由器的一个端口（每个端口具有一个全球 IP 地址），由此便可进行互联网通讯，此时目的主机只能知道 NAT 路由器端口的地址而不知发送端的地址。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120142901992.png" alt="" /><figcaption>image-20231120142901992</figcaption>
</figure>
<h4 id="mlps">4.9 MLPS</h4>
<p>​ MLPS 作为一种 IP 增强技术，广泛应用在互联网中。特点如下：</p>
<ul>
<li>支持面向连接的服务质量。</li>
<li>支持流量工程，平衡网络负载。</li>
<li>有效地支持 VPN。</li>
</ul>
<h5 id="工作原理">4.9.1 工作原理</h5>
<p>​ 在 MPLS 域入口处打上固定长的 MPLS 标记，然后对打上标记的 IP 数据报用硬件转发，只经过第二层，称为<strong>标记交换</strong>。</p>
<p>​ MPLS 域是指该域中有许多彼此相邻路由器，且均为支持 MPLS 技术的<strong>标记路由器 LSR</strong>。一个标记仅在两个 LSR 间才有意义。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120143602027.png" alt="" /><figcaption>image-20231120143602027</figcaption>
</figure>
<p>​ 如入接口 0 收到一个标记为 3 的 IP 数据报，路由器就知道应从出接口 1 转发且打上标记 1。</p>
<h5 id="转发等价类-fec">4.9.2 转发等价类 FEC</h5>
<p>​ IP 数据报的集合，对路由器来说具有相同的性质，如下一跳，相同服务类别，同样丢弃优先级等。</p>
<p>​ 例子：</p>
<ul>
<li>目的 IP 与某一特定 IP 地址前缀匹配的 IP 数据报</li>
<li>所有源地址与目的地址相同的数据报</li>
<li>具有某种服务质量需求的数据报</li>
</ul>
<h5 id="mpls-首部的格式">4.9.3 MPLS 首部的格式</h5>
<p>​</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120144102987.png" alt="" /><figcaption>image-20231120144102987</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/newPath/image-20231120144109443.png" alt="" /><figcaption>image-20231120144109443</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/11/02/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/02/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">谢希仁计算机网络03-数据链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-02 20:35:00" itemprop="dateCreated datePublished" datetime="2023-11-02T20:35:00+08:00">2023-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-09 21:09:43" itemprop="dateModified" datetime="2023-12-09T21:09:43+08:00">2023-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="使用点对点信道的数据链路层">3.1 使用点对点信道的数据链路层</h4>
<h5 id="数据链路和帧">3.1.1 数据链路和帧</h5>
<p>​ <strong>链路</strong>是指从一个结点到相邻节点的一段物理线路（有限或无线），而中间没有其它交换结点。链路是一条路径的组成部分。</p>
<p>​ 传输数据时，不仅需要物理线路，还需要一些必要的通信协议控制数据传输。若把<strong>实现该些协议的硬件与软件</strong>加到链路上，就构成了<strong>数据链路</strong>。现在最常用的方法是使用<strong>网络适配器（既有硬件也有软件）</strong>来实现这些协议。</p>
<p>​ 早期数据通信协议曾叫做<strong>规程 (procedure)</strong>。因此在数据链路层，规程与协议是同义语。</p>
<p>​ 数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的<strong>帧</strong>中的数据取出并上交给网络层。互联网中，网络层协议数据单元是 <strong>IP 数据报（或简称为数据报、分组或包）</strong>。</p>
<p>​ 点对点信道通信时的主要步骤：</p>
<p>​ (1) 结点 A 的数据链路层把网络层叫下来的 IP 数据报添加首部和尾部封装成帧。</p>
<p>​ (2) 结点 A 把封装好的帧发送给结点 B 的数据链路层。</p>
<p>​ (3) 若结点 B 数据链路层收到的帧无差错，则提取 IP 数据报并交给网络层，否则弃帧。</p>
<h5 id="三个基本问题">3.1.2 三个基本问题</h5>
<p>​ 三个基本问题：<strong>封装成帧</strong>、<strong>透明传输</strong>和<strong>差错检测</strong>。</p>
<h6 id="封装成帧">3.1.2.1 封装成帧</h6>
<p>​ <strong>封装成帧 (framing)</strong> 是指在一段数据前后分别添加首部和尾部，构成一个帧。首部和尾部的一个重要作用是进行<strong>帧界定</strong>。每一种链路协议都规定所能传送的帧的<strong>数据部分最大长度上限——最大传送单元 MTU (Maximum Transfer Unit)</strong>。</p>
<p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261052318.png" /></p>
<p>​ 帧界定使用特殊的<strong>帧界定符</strong>，帧开始符 SOH （十六制编码 01）放于首部，帧结束符 EOT （十六进制编码 04)放于尾部。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261058141.png" alt="" /><figcaption>image-20231026105820053</figcaption>
</figure>
<h6 id="透明传输">3.1.2.2 透明传输</h6>
<p>​ 当传输数据是非 ASCII 码的文件时，如果数据中某个字节二进制代码恰好和 SOH 和 EOT 这种控制字符一样，则会产生错误。<strong>透明传输</strong>的概念是指，无论怎样的数据通过，数据链路层都能原样无差错传输该数据。</p>
<p>​ 为实现透明传输，发送端的数据链路层在发送数据中出现控制字符的位置前插入一个转义字符 ESC （十六进制编码 1B），接收端的数据链路层在将其送往网络层前提前删除这个插入的转义字符。此方法叫做<strong>字节填充</strong>或<strong>字符填充</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261441992.png" alt="" /><figcaption>image-20231026144110932</figcaption>
</figure>
<h6 id="差错检测">3.1.2.3 差错检测</h6>
<p>​ 比特在传输过程中可能会产生差错，<span class="math inline">\(0\)</span> 变成 <span class="math inline">\(1\)</span>，<span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>，这种情况叫<strong>比特差错</strong>。同一时间传输错误的比特占总传输比特数的比率叫做<strong>误码率 BER (Bit Error Rate)</strong>。但实际数据传输误码率不可能降为零，因此位保证可靠传输，必须进行差错检测。目前广泛采用<strong>循环冗余检验 CRC (Cyclic Redundancy Check)</strong> 检错技术。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261446007.png" alt="" /><figcaption>image-20231026144652892</figcaption>
</figure>
<p>​ 传输差错可分为两大类，一类是基本的比特差错，里另一类是更复杂些的<strong>帧丢失</strong>、<strong>帧重复</strong>或<strong>帧失序</strong>。因此出现比特差错与出现传输差错并不等价。为实现可靠传输，在 CRC 检错的基础上，增加了<strong>帧编号</strong>、<strong>确认</strong>和<strong>重传机制</strong>。现在互联网采用区别对待方法，对于通信质量良好的传输线路，不适用确认和重传机制，即要求数据链路层向上提供可靠传输；对于通信质量较差的链路，则采用确认重传机制，数据链路层向上提供可靠传输。</p>
<h4 id="点对点协议-ppp">3.2 点对点协议 PPP</h4>
<p>​ 通信质量较差的年代，采用可靠传输协议是一种好办法，因此当时比较流行能实现可靠传输协议的<strong>高级数据链路控制 HDLC (High-level Data Link Control)</strong>。目前对于点对点的链路，则广泛采用简单得多的 <strong>点对点协议 PPP (Point-to-Point Protocol)</strong> 。</p>
<h5 id="ppp-协议的特点">3.2.1 PPP 协议的特点</h5>
<ol type="1">
<li><p>应满足需求：</p>
<ul>
<li>简单</li>
<li>封装成帧</li>
<li>透明性</li>
<li>多种网络层协议兼容</li>
<li>多种类型链路，如串行或并行，同步或异步，低速或高速</li>
<li>差错检测</li>
<li>检测连接状态</li>
<li>最大传送单元</li>
<li>网络层地址协商</li>
<li>数据压缩协商</li>
</ul></li>
<li><p>PPP 协议的组成</p>
<ol type="1">
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li>一个用来建立、配置和测试数据链路连接的 <strong>链路控制协议 LCP (Link Control Protocol)</strong>。</li>
<li>一套<strong>网络控制协议 NCP (Network Control Protocol)</strong>，其中每一个协议支持不同网络层协议。</li>
</ol></li>
</ol>
<h5 id="ppp-协议的帧格式">3.2.2 PPP 协议的帧格式</h5>
<h6 id="各字段意义">1. 各字段意义</h6>
<p>​ 首部第一字段和尾部第二字段为标志字段 F 。</p>
<p>​ 首部第二、三字段无具体含义，未定义。</p>
<p>​ 首部第四字段是 <span class="math inline">\(2\)</span> 字节的协议字段。协议字段为 <span class="math inline">\(0x0021\)</span> 时，PPP 帧的信息字段就是 IP 数据报；协议字段为 <span class="math inline">\(0xC021\)</span>，则信息字段是 PPP 链路控制协议 LCP 的数据；而 <span class="math inline">\(0x8021\)</span> 表示这是网络层的控制数据。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261532003.png" alt="" /><figcaption>image-20231026153257957</figcaption>
</figure>
<h6 id="字节填充">2. 字节填充</h6>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261534633.png" alt="" /><figcaption>image-20231026153411583</figcaption>
</figure>
<h6 id="零比特填充">3. <strong>零比特填充</strong></h6>
<p>​ 发送端每遇见 <span class="math inline">\(5\)</span> 个连续的 <span class="math inline">\(1\)</span> ，则插入一个 <span class="math inline">\(0\)</span>；接收端采取相反操作。</p>
<h5 id="ppp-协议的工作状态">3.2.3 PPP 协议的工作状态</h5>
<p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202310261610078.png" alt="image-20231026161026019" /></p>
<h4 id="使用广播信道的数据链路层">3.3 使用广播信道的数据链路层</h4>
<h5 id="局域网的数据链路层">3.3.1 局域网的数据链路层</h5>
<p>​ 局域网最主要特点：<strong>网络为一个单位所有，且地理范围和站点数目均有限</strong>。</p>
<p>​ 局域网优点：</p>
<p>​ (1) 可广播，一个站点可以很方便访问全网，主机可共享连接在局域网上的各种硬件和资源。</p>
<p>​ (2) 便于系统的扩展和演变，各设备位置可灵活调整或改变。</p>
<p>​ (3) 提高系统的可靠性 (reliability)、可用性 (availability) 和生存性 (survivability)。</p>
<p>​ 局域网可按网络拓扑进行分类，分为<strong>星形网</strong>（核心设备<strong>集线器</strong>）、<strong>环形网</strong>、<strong>总线网</strong>几类，其中总线网以传统以太网最为著名。经过几十年发展，以太网已经在局域网市场中占据绝对优势，以太网几乎成为局域网同义词。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310270907254.png" alt="" /><figcaption>image-20231027090759182</figcaption>
</figure>
<p>​ 从 <span class="math inline">\(10\ Mbit/s\)</span> 到 <span class="math inline">\(10\ Gbit/s\)</span> 的局域网均可用双绞线。双绞线已成为局域网中的主流传输媒体。数据率很高时，往往需要使用光纤作为传输媒体。</p>
<p>​ 共享信道在技术上有两种方法：</p>
<p>​ (1) <strong>静态划分信道</strong>，如 2.4 中的频分复用、时分复用、波分复用和码分复用，但是这种划分代价较高，不适合局域网使用。</p>
<p>​ (2) <strong>动态媒体接入</strong>，又称<strong>多点接入 (multiple access)</strong>，特点是信道并非在用户通信时固定分配给用户。又分为两类：</p>
<ul>
<li><strong>随机接入</strong> 所有用户可以随机发送信息，但如果恰巧有两个或多个用户同一时刻发送信息，则会产生<strong>碰撞</strong>（即<strong>冲突</strong>），使得这些用户全部发送失败。因此需要有解决碰撞的协议。</li>
<li><strong>受控接入</strong> 用户服从控制而不能随机发送信息，代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询 (polling)</strong>，或称<strong>轮询</strong>。</li>
</ul>
<p>​ 现在用“<strong>传统以太网</strong>”表示最初流行的 <span class="math inline">\(10 Mbit/s\)</span> 的以太网。</p>
<h6 id="以太网的两个标准">3.3.1.1 以太网的两个标准</h6>
<p>​ 世界上第一个局域网产品规约—— DIX Ethernet V2； 第一个 IEEE 的以太网标准 IEEE 802.3，数据率为 <span class="math inline">\(10\ Mbit/s\)</span>。这两个标准区别很小，因此也常把 IEEE 802.3 局域网简称以太网。</p>
<p>​ 为了使得数据链路层能更好适应多种局域网标准，IEEE 802 委员会将局域网的数据链路层拆成两个子层，即 <strong>逻辑链路控制 LLC (Logical Link Control)</strong> 子层和<strong>媒体接入控制 MAC (Medium Access Control)</strong> 子层。与接入媒体相关内容全部放在 MAC 子层，LLC 子层与传输媒体无关， MAC 子层对 LLC 子层来说是透明的。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310270955977.png" alt="" /><figcaption>image-20231027095503914</figcaption>
</figure>
<p>​ 现代 TCP/IP 体系经常使用的局域网只剩下 DIX Ethernet V2 而非 IEEE 802.3 中的局域网，因此逻辑链路子层 LLC（即 IEEE 802.2 标准）作用已经消失，很多厂商生产适配器上仅有 MAC 协议而没有 LLC 协议。</p>
<h6 id="适配器的作用">3.3.1.2 适配器的作用</h6>
<p>​ 适配器实现功能包含物理层和数据链路层两部分。</p>
<p>​ 计算机与外界局域网的连接是通过<strong>适配器 (adapter)</strong>进行的。适配器本来是主机箱内插入的一块网络接口板，又称<strong>网络接口卡 NIC (Network Interface Card)</strong>，或<strong>网卡</strong>。现在计算机主板上都已经嵌入该种适配器，不再使用单独的网卡，因此采用适配器这个术语更准确些。</p>
<p>​ 适配器与局域网之间通过电缆或双绞线以串行传输方式进行通信，与主机则通过计算机主板上的 I/O 总线以并行传输进行通信，因此适配器一个重要功能是<strong>进行数据串行传输与并行传输的转换</strong>。</p>
<p>​ 计算机的硬件地址在适配器的 ROM 中，而软件地址——IP 地址，则在计算机存储器中。</p>
<h5 id="csmacd-协议">3.3.2 CSMA/CD 协议</h5>
<p>​ 局域网上的计算机称为“<strong>主机</strong>”、“<strong>工作站</strong>”、“<strong>站点</strong>”或“<strong>站</strong>”。</p>
<p>​ 为了通信减半，以太网采取以下两种措施：</p>
<p>​ 第一，采用<strong>无连接</strong>工作方式，不必先建立连接即可发送数据。适配器对发送帧<strong>不进行编号，也不要求对方发回确认</strong>。因此以太网提供的服务随时<strong>尽最大努力的交付，即不可靠的交付</strong>。若目的站收到有差错帧，则丢，是否需要重传则<strong>有高层决定</strong>。</p>
<p>​ 总线同一时间只允许一台计算机发送数据，否则会产生碰撞。以太网采用最简单的随机接入，但同时使用 CSMA/CD 协议处理碰撞，意思是<strong>载波监听多点接入/碰撞检测 (Carrier Sense Multiple Access with Collision Detection)</strong>。</p>
<p>​ 第二，以太网发送数据采用<strong>曼彻斯特 (Manchester) 编码</strong>的信号。优点是每个码元都出现一次电压变换，可以很方便地把位同步信号提取出来；缺点则是所占频带宽度比原始基带信号增加一倍。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310271025170.png" alt="" /><figcaption>image-20231027102549093</figcaption>
</figure>
<p>​ 介绍下 CSMA/CD 协议要点。</p>
<p>​ “<strong>多点接入</strong>”说明其是总线型网络。</p>
<p>​ “<strong>载波监听</strong>”是用电子技术检测总线上有无其它计算机在发送，其实就是<strong>检测信道</strong>。发送前和发送中都必须进行信道检测。发送前检测是为了获得发送权。发送中检测则是为了及时发现碰撞，即碰撞检测。</p>
<p>​ “<strong>碰撞检测</strong>“亦即“<strong>边发送边监听</strong>”，几个站同时在总线上发送数据时，总线上信号电压变化幅度会增大，超过一定阈值时，就视为产生了碰撞。一旦出现碰撞，适配器立即停止发送，等待一段随机时间后再次发送。</p>
<p>​ <strong>电磁波在 <span class="math inline">\(1\ km\)</span> 电缆的传播时延约为 <span class="math inline">\(5\ \mu s\)</span></strong>。把总线上的<strong>单程端到端传播时延记为<span class="math inline">\(\tau\)</span></strong>。最迟经过 <span class="math inline">\(2\tau\)</span> 的时延即可确认是否发生碰撞（信息来回一次最大可能时延）。</p>
<p>​ 在使用 CSMA/CD 协议时，一个站不可能同时进行发送和接收，因此使用 CSMA/CD 协议的以太网只能进行<strong>半双工通信</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310271605705.png" alt="" /><figcaption>image-20231027160531598</figcaption>
</figure>
<p>​ 每一个站在发送数据后的一小段时间内，存在遭遇碰撞的可能性，这段时间是不确定的，因此称为以太网<strong>发送的不确定性</strong>。端到端往返时间 <span class="math inline">\(2\tau\)</span> 称为<strong>争用期</strong>。经过争用期检验后，才能肯定此次发送是否发生碰撞。</p>
<p>​ 以太网使用<strong>截断二进制指数退避 (truncated binary exponential backoff)</strong> 算法确定碰撞后重传时机，这里不多赘述。</p>
<p>​ 以太网规定一个最短帧长 64 字节，即 512 bit，这样发送一个帧的时间也至少需要一个争用期。凡是长度小于 64 字节的帧都是<strong>由于冲突而异常终止的无效帧</strong>。</p>
<p>​ <strong>强化碰撞</strong>是指发送数据一旦发生碰撞，除立即停止发送数据外，继续发送 32 或 48 比特的<strong>人为干扰信号 (jamming signal)</strong>，以便让所有用户都知道发生碰撞。</p>
<p>​ 以太网还规定<strong>帧间最小间隔</strong>为 <span class="math inline">\(9.6\ \mu s\)</span>，相当于 96 比特时间，是为了使得刚刚受到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p>
<p>​ 由此，CSMA/CD 协议总结如下：</p>
<p>​ (1) 准备发送：组装成帧</p>
<p>​ (2) 检测信道：检测到信道忙，则不停检测，直至信道空闲</p>
<p>​ (3) 发送：边发送边监听，发送成功则回到 (1) ；发生碰撞则执行指数退避算法，等待一定时间后回到 (2)，若重传 16 次仍失败，则停止重传并向上报错。</p>
<h5 id="使用集线器的星形拓扑">3.3.3 使用集线器的星形拓扑</h5>
<p>​ <strong>集线器 (hub)</strong> 是一个<strong>物理层网络设备</strong>，通常与双绞线以太网相配合使用。10BASE-T 双绞线以太网的出现，是局域网发展史上一个非常重要的里程碑，从此以太网的拓扑就从总线型变为更加方便的星形网络，以太网也在局域网中占据统治地位。</p>
<p>​ 集线器有如下特点：</p>
<ul>
<li>使用集线器的以太网逻辑上仍是一个总线网，各站共享逻辑总线，仍使用 CSMA/CD 协议，同一时刻至多允许一个站发送数据。</li>
<li>一个集线器有多个<strong>接口</strong>，每个接口通过 RJ-45 插头用两对双绞线与一台计算机上的适配器相连。集线器像一个<strong>多接口的转发器</strong>。</li>
<li>集线器工作在<strong>物理层</strong>，每个接口仅仅简单转发比特，不进行碰撞检测。若发生碰撞，则所有接口都收不到正确的帧。</li>
<li>采用专门芯片进行自适应串音回波抵消，减少近端串音干扰（发出去的强信号对受到的弱信号的干扰）。</li>
</ul>
<p>​ <strong>堆叠式 (stackable)</strong> 集线器由 4~8 个集线器堆叠使用。</p>
<p>​ IEEE 802.3 标准还可以使用光纤作为传输媒体，主要作用于集线器之间的连接。</p>
<h5 id="以太网的信道利用率">3.3.4 以太网的信道利用率</h5>
<p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202310271654367.png" alt="image-20231027165412308" /> <span class="math display">\[
a = \frac{\tau}{T_0}
\]</span> ​ <span class="math inline">\(a\)</span> 趋近于 <span class="math inline">\(0\)</span>，表示一发生碰撞即可检测出来，信道资源被浪费时间非常少。因此为了使 <span class="math inline">\(a\)</span> 值尽量小，<strong>以太网的长度受到限制</strong>（<span class="math inline">\(\tau\)</span> 不能太大），同时<strong>以太网的帧长不能太短</strong> （否则 <span class="math inline">\(T_0\)</span> 太小）。</p>
<p>​ 理想状况下，不发生任何碰撞，则发送一帧时延为 <span class="math inline">\(T_0+\tau\)</span>，而帧本身发送时延为 <span class="math inline">\(T_0\)</span>，因此有极限信道利用率 <span class="math display">\[
S_{max}=\frac{T_0}{T_0+\tau}=\frac{1}{1+a}
\]</span> ​ 因此只有当 <span class="math inline">\(a\)</span> 远小于 <span class="math inline">\(1\)</span> 时才能得到尽可能高的极限信道利用率。</p>
<h5 id="以太网的-mac-层">3.3.5 以太网的 MAC 层</h5>
<h6 id="mac-层的硬件地址">3.3.5.1 MAC 层的硬件地址</h6>
<p>​ 局域网中，<strong>硬件地址</strong>又称<strong>物理地址</strong>或 <strong>MAC 地址</strong>（因地址用在 MAC 帧中）。</p>
<p>​ IEEE 802 标准为局域网规定一种 48 位的全球地址，是指局域网上每一台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。</p>
<p>​ IEEE 的<strong>注册管理机构 RA (Registration Authority)</strong> 是局域网全球地址的法定管理机构，负责分配地址字段 6 字节中的前三字节（即最高 24 位）。世界上生产适配器的厂家都必须向 IEEE 购买由这三个字节构成的号，名称为 <strong>组织唯一标识符 OUI (Organizationally Unique Identifier)</strong>，通常也称<strong>公司标识符 (company_id)</strong>。地址中后三个字节由厂家自行指派，称为<strong>扩展标识符 (extended identifier)</strong>。</p>
<p>​ IEEE 规定地址字段第一字节的最低位为 I/G 位。I/G 表示 Individual/Group。该位为 0 时，地址字段表示一个<strong>单个站地址</strong>。该位为 1 时表示<strong>组地址</strong>，用来进行<strong>多播</strong>。因此 IEEE 只分配前三字节中的 23 位。</p>
<p>​ 第一字节低 2 位规定位 G/L 位，该位为 0 时是<strong>全球管理</strong>（保证全球没有相同地址），厂商向 IEEE 购买的 OUI 均属于全球管理。</p>
<p>​ 适配器有<strong>过滤</strong>功能，适配器收下的帧包括以下三种：</p>
<p>​ (1) <strong>单播 (unicast) 帧</strong>，收到的帧的 MAC 与本站硬件地址相同。</p>
<p>​ (2) <strong>广播 (broadcast) 帧</strong>，发送给本局域网所有站点的帧（全 1 地址）。</p>
<p>​ (3) <strong>多播 (multicast) 帧</strong>，发送给本局域网上一部分站点的帧。</p>
<p>​ 所有适配器都应能够识别前两种帧，有的适配器可用编程方法识别第三种帧。</p>
<p>​ 适配器还可设置为一种特殊的工作方式即<strong>混杂方式 (promiscuous mode)</strong>。窃听所有的帧，经常为黑客所使用。</p>
<h6 id="mac-帧的格式">3.3.5.2 MAC 帧的格式</h6>
<p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202311021938027.png" alt="image-20231102193850945" /></p>
<p>​ 数据字段小于 64 字节时，MAC 子层会在其后加入一个填充字段。</p>
<p>​ MAC 子层向下传到物理层时还要在帧前插入 8 字段，第一字段为 7 个字节的<strong>前同步码 （1 和 0 的交替码）</strong>，使得适配器接受 MAC 帧时迅速调整时钟频率。第二字段为<strong>帧开始定界符</strong>，定义为 <code>10101011</code>，前 6 位作用与前同步码相同，最后两个连续 1 预告信息接收。</p>
<p>​ 由于曼彻斯特码的使用，以太网不需要着帧结束定界符，由此也不需要插入字节来保证传输透明。</p>
<h4 id="扩展的以太网">3.4 扩展的以太网</h4>
<p>​ <strong>扩展的以太网在网络层看来仍然是一个网络</strong>。</p>
<h5 id="物理层扩展">3.4.1 物理层扩展</h5>
<p>​ 扩展主机与集线器之间距离一种简单方法是使用光纤和一对光纤调制解调器。</p>
<p>​ 使用多个集线器，可以构成覆盖范围更大的多级星形结构以太网。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202311021954027.png" alt="" /><figcaption>image-20231102195453931</figcaption>
</figure>
<p>​ 但这种多级结构的集线器以太网也有一些缺点。</p>
<p>​ (1) 多个系以太网相连把多个碰撞与变成一个，但此时最大吞吐量仍然是一个系的吞吐量 10 Mbits/s。</p>
<p>​ (2) 若不同系用不同以太网技术（如数据率不同），则无法互连。</p>
<h5 id="数据链路层扩展">3.4.2 数据链路层扩展</h5>
<p>​ 最初使用<strong>网桥 (bridge)</strong>，对 MAC 帧的目的地址进行 <strong>转发</strong> 和 <strong>过滤</strong>。</p>
<p>​ <strong>交换式集线器 (switching hub)</strong> 也称<strong>交换机 (switch)</strong> 或 <strong>第二层交换机 (L2 switch)</strong> 很快淘汰了网桥，这种设备<strong>工作在数据链路层</strong>。</p>
<h6 id="交换机特点">3.4.2.1 交换机特点</h6>
<p>​ 实质上是一个<strong>多接口网桥</strong>，通常有十几个或更多接口。具有<strong>并行性</strong>，能同时连通多对主机进行通信，相互通信主机<strong>独占传输媒体，无碰撞地传输数据</strong>。</p>
<p>​ 交换机的接口还有存储器，能在输出端口繁忙时将到来的帧进行缓存。</p>
<p>​ 交换机即插即用，内部<strong>帧交换表</strong>是通过<strong>自学习</strong>算法自动逐渐建立。</p>
<p>​ 许多交换机对收到的帧采用存储转发，但有些交换机用<strong>直通</strong>的交换方式，提高了帧的转发速度，但缺点是少了检查差错步骤。</p>
<h6 id="交换机的自学习功能">3.4.2.2 交换机的自学习功能</h6>
<p>​ <del>懒得写，看书吧。</del></p>
<p>​ 为防止环状网络拓扑导致的资源浪费，IEEE 的 802.1D 标准制定了<strong>生成树协议 STP (Spanning Tree Protocol)</strong>，不改变物理上的网络拓扑，但从逻辑上切断某些链路，消除环状结构的存在。</p>
<p>​ 随着站点数目增多和交换机成本的下降，传统总线以太网迅速为星形以太网所取代，但由于<strong>仍采用以太网的帧结构</strong>，故仍称以太网。</p>
<h5 id="虚拟局域网">3.4.3 虚拟局域网</h5>
<p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202311022019173.png" alt="image-20231102201909117" /></p>
<p>​ 利用交换机能方便地实现<strong>虚拟局域网 VLAN (Virtual LAN) </strong>，虚拟局域网限制接收广播信息的计算机数，使得网络不会因传播过多的广播信息（即“<strong>广播风暴</strong>”）而引起性能恶化。</p>
<p>​ 1988 年 IEEE 批准了 802.3ac 标准，该标准定义了以太网帧格式的扩展，以支持虚拟局域网。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202311022022437.png" alt="" /><figcaption>image-20231102202204367</figcaption>
</figure>
<p>​ 以太网最大帧长从原来的 1518 字节变为 1522 字节。</p>
<h4 id="高速以太网">3.5 高速以太网</h4>
<h5 id="base-t-以太网">3.5.1 100BASE-T 以太网</h5>
<p>​ 在双绞线上传输 100 Mbit/s 基带信号的星形拓扑以太网，但仍使用 IEEE 802.3 的 CSMA/CD 协议，又称<strong>快速以太网 (Fast Ethernet)</strong>。现在快速以太网正式标准为 IEEE 802.3u。</p>
<p>​ IEEE 802.3u 标准并未包括对同轴电缆支持，由细缆以太网升级到快速以太网必须重新布线，因此现在 10/100 Mbit/s 的以太网均无屏蔽双绞线布线。</p>
<p><del>更快的以太网就不写了，看书看吐了。。。。。</del>#</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/10/22/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/22/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">编程作业 code</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-22 18:12:00" itemprop="dateCreated datePublished" datetime="2023-10-22T18:12:00+08:00">2023-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-16 20:48:27" itemprop="dateModified" datetime="2023-12-16T20:48:27+08:00">2023-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本页面将<strong>计组</strong>和<strong>数据结构与算法</strong>两门课的编程作业代码于 ddl /发布三周后公布，仅供参考。如有错误或可改进之处，敬请联系 Lg，直接 qq 联系或 <code>1370120724@qq.com</code> 均可。</p>
<table>
<thead>
<tr class="header">
<th>计组</th>
<th>writer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/1929f5477a814e68aa56/?dl=1">COA_hw1</a></td>
<td>Lg</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/1950f62a50374ff9b2d0/?dl=1">COA_hw2</a></td>
<td>Lg</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/010a76d95c1545d29262/?dl=1">COA_hw3</a></td>
<td>zz</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/6b70dfe587634842bea5/?dl=1">COA_hw4</a></td>
<td>Lg</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/7932ebf9e0ec48dca483/?dl=1">COA_hw5</a></td>
<td>Lg</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/8fef2c4fbe6c4c2a8df2/?dl=1">COA_hw6</a></td>
<td>Lg</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/5a95c20bc470455787de/?dl=1">COA_hw7（含 pdf 附件）</a></td>
<td>Lg</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>数据结构与算法</th>
<th>writer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/0aa0a872c19a4b4a8af9/?dl=1">DS_hw1</a></td>
<td>Lg</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/eaca1c8b47874f1caf43/?dl=1">DS_hw2</a></td>
<td>Lg</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/2e65d5aa45e84fd5815f/?dl=1">DS_hw3</a></td>
<td>Lg</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/31ecfa006910450d881d/?dl=1">DS_hw4</a></td>
<td>Lg</td>
</tr>
</tbody>
</table>
<blockquote>
<p>​ 也许你感觉自己的努力总是徒劳无功，但不必怀疑，你每天都离顶点更进一步。今天的你离顶点还遥遥无期。但你通过今天的努力，积蓄了明天勇攀高峰的力量。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/10/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02-%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/22/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02-%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">谢希仁计算机网络02-物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-22 10:21:00" itemprop="dateCreated datePublished" datetime="2023-10-22T10:21:00+08:00">2023-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-09 21:09:43" itemprop="dateModified" datetime="2023-12-09T21:09:43+08:00">2023-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="物理层的基本概念">2.1 物理层的基本概念</h4>
<p>​ 用于物理层的协议也称为<strong>规程(procedure)</strong>。</p>
<p>​ 可将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：</p>
<p>​ (1) <strong>机械特性</strong>：指明接口所用接线器的形状尺寸、引脚数目排列等。</p>
<p>​ (2) <strong>电气特性</strong>：指明接口电缆各条线电压范围。</p>
<p>​ (3) <strong>功能特性</strong>：指明某条线某电平的电压的意义。</p>
<p>​ (4) <strong>过程特性</strong>：指明不同功能的各种可能事件的出现顺序。</p>
<p>​ 数据在计算机内部采用<strong>并行传输</strong>，但在通信线路上一般采用<strong>串行传输</strong>，因此物理层还要完成传输方式的转换。</p>
<h4 id="数据通信的基础知识">2.2 数据通信的基础知识</h4>
<h5 id="数据通信系统的模型">2.2.1 数据通信系统的模型</h5>
<p>​ 数据通信系统可划分为三大部分：<strong>源系统</strong>（或<strong>发送端、发送方</strong>）、<strong>传输系统</strong>（或<strong>传输网络</strong>）和<strong>目的系统</strong>（或<strong>接收端、接收方</strong>）</p>
<p>​ 源系统一般包含两部分：</p>
<ul>
<li><strong>源点(source)</strong>：产生要传输的数据。又称<strong>源站</strong>或<strong>信源</strong>。</li>
<li><strong>发送器</strong>：将源点产生数据进行编码，之后才能进行传输。如<strong>调制器</strong>。</li>
</ul>
<p>​ 目的系统一般包含两部分：</p>
<ul>
<li><strong>接收器</strong>：接受传输信号，并转化为目标设备能处理的信息。如<strong>解调器</strong>。</li>
<li><strong>终点(destination)</strong>：接受比特流</li>
</ul>
<p>​ 现在很多计算机使用内置的调制解调器，用户在计算机外看不见调制解调器。</p>
<p>​</p>
<p>通信的目的是传送<strong>消息(message)</strong>。<strong>数据(data)</strong>是运送消息的实体。<strong>信号(signal)</strong>是数据的电气或电磁表现。信号可分为两大类：</p>
<p>​ (1) <strong>模拟信号</strong>，或<strong>连续信号</strong>：如用户家中的调制解调器到电话端局之间的用户线上的信号。</p>
<p>​ (2) <strong>数字信号</strong>，或<strong>离散信号</strong>：如用户家中计算机到调制解调器之间，或电话网中继线上传送的信号。使用时间域（或称时域）的波形表示数字信号时，取不同离散数值的基本波形称为<strong>码元</strong>。</p>
<h5 id="有关信道channel的几个基本概念">2.2.2 有关<strong>信道(channel)</strong>的几个基本概念</h5>
<p>​ 从通信双方的交互方式来看，有三种基本通信方式：</p>
<p>​ (1) <strong>单向通信</strong>：也称<strong>单工通信</strong>。如无线电广播，或有线电广播及电视广播。</p>
<p>​ (2) <strong>双向交替通信</strong>：也称<strong>半双工通信</strong>，双方均可发送，但不可同时发送。</p>
<p>​ (3) <strong>双向同时通信</strong>：也称<strong>全双工通信</strong>。</p>
<p>​ 单向通信仅需一条信道，而双向交替通信和双向同时通信均需两条。全双工通信效率最高。</p>
<p>​</p>
<p>​ 来自信源的信号称为<strong>基带信号</strong>，往往含有较多低频成分甚至直流成分，而许多信道并不能传输这种低频或直流分量，因此必须对基带信号进行<strong>调制(coding)</strong>。使用<strong>载波(carrier)</strong>进行调制，把基带信号频率搬移到较高频段，并转化为模拟信号，便可更好在模拟信道中传输。载波调制后信号称<strong>带通信号</strong>，调制称为<strong>载波调制</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211254285.jpg" alt="" /><figcaption>0d28fb91042f8ce7aa2ce716249dd2d</figcaption>
</figure>
<h5 id="信道极限容量">2.2.3 信道极限容量</h5>
<p>​ 限制码元在信道上传输速率的因素：</p>
<p>​ (1) 信道可通过频率范围</p>
<p>​ 信道能通过频率范围有限，高频分量往往无法通过信道。高频分量传输时受衰减，接收端受到信号便失去了码元间的清晰界限，此现象称<strong>码间串扰</strong>。</p>
<p>​ 奈氏准则告诉我们：<strong>任何信道中，码元传输速率有上限，超过该上限，则会出现严重码间串扰问题，使接收端对码元的判决称为不可能。</strong></p>
<p>​ (2) 信噪比</p>
<p>​ 信噪比是信号的平均功率与噪声的平均功率比值，记作 <strong>S/N</strong>，度量单位为<strong>分贝</strong>。</p>
<p>​ 香农公式指出，信道的<strong>极限传输速率 C </strong>为 <span class="math display">\[
C = W\log_2(1+S/N)\ \ \ (bit/s)
\]</span> ​ 其中 <span class="math inline">\(W\)</span> 为信道带宽， <span class="math inline">\(S\)</span> 和 <span class="math inline">\(N\)</span> 分别表示信号与噪声的平均功率。</p>
<p>​ 香农公式表面，信噪比越大，极限传输速率越高。对于频带宽度已确定的信道，信噪比也无法继续提高，码元传输速率也达上界，欲提升传输速率，可通过编码的方法<strong>让每一个码元携带更多比特信息量</strong>。</p>
<h4 id="物理层下面的传输媒体">2.3 物理层下面的传输媒体</h4>
<p>​ <strong>传输媒体</strong>分为<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>两大类。</p>
<h5 id="导引型传输媒体">2.3.1 导引型传输媒体</h5>
<h6 id="双绞线">1. <strong>双绞线</strong></h6>
<p>​ 两根互相绝缘铜导线绞合，以减少对相邻导线的电磁干扰。使用最多地方为电话系统。</p>
<p>​ 模拟运输和数字运输均可使用双绞线，通信距离为几到十几公里。</p>
<p>​ 为提升抗电磁干扰能力，可在外面加上一层用金属丝编织成的屏蔽层，称为<strong>屏蔽双绞线</strong>，简称 <strong>STP(Shielded Twisted Pair)</strong>。<strong>无屏蔽双绞线</strong>简称 <strong>UTP(Unshielded Twisted Pair)</strong> 。</p>
<p>​ “商用建筑物电信布线标准”—— <strong>EIA/TIA-568-A</strong> ——规定了 5 个种类的 UTP 标准，最常用的是 5 类线。</p>
<p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211404631.png" alt="image-20231021140449514" /></p>
<h6 id="同轴电缆">2. <strong>同轴电缆</strong></h6>
<p>​ 由内导体铜质芯线、绝缘层、网状编织外导体屏蔽层以及保护塑料外层组成。具有良好抗干扰特性，被广泛用于传输较高速率的数据。</p>
<p>​ 目前主要用在有线电视网的居民小区中。</p>
<h6 id="光缆">3. <strong>光缆</strong></h6>
<p>​ <strong>光纤</strong>在发送端有光源，可采用发光二极管或半导体激光器。接收端用光电二极管做成光检测器，可还原出电脉冲。原理是利用光的全反射。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211409293.png" alt="" /><figcaption>image-20231021140938197</figcaption>
</figure>
<p>​ 现代工艺可制造出超低损耗光纤，即做到传输数公里而没什么衰耗。这是光纤通信飞速发展的最关键因素。</p>
<p>​ 可以存在多条不同角度入射光线在同一光纤中传输，称为<strong>多模光纤</strong>。但光脉冲传输时会展宽，因此多模光纤<strong>仅适用于近距离传输</strong>。</p>
<p>​ 光纤优点：</p>
<p>​ (1) 通信容量大。</p>
<p>​ (2) 传输损耗小，中继距离长，对远距离传输经济。</p>
<p>​ (3) 抗雷和电磁干扰性能好，在大电流脉冲干扰下尤为重要。</p>
<p>​ (4) 无串音干扰，保密性好。</p>
<p>​ (5) 体积小，重量轻。</p>
<h6 id="架空明线">4. <strong>架空明线</strong></h6>
<p>​ 在电线杆上架设互相绝缘的明线（铜线或铁线）。许多国家都已经停止铺设，目前我国一些农村与边远地区仍使用。</p>
<h5 id="非导引型传输媒体">2.3.2 非导引型传输媒体</h5>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211418400.png" alt="" /><figcaption>image-20231021141801277</figcaption>
</figure>
<p>​ 无线传输可使用频段很广，紫外线和更高的波段目前还不能用于通信。</p>
<p>​ 短波通信（即高频通信）主要靠电离层反射，但电离层不稳定产生的衰落现象和反射产生的多径效应，使得短波通信质量较差。因此短波无线电台一般采用低速传输。</p>
<h6 id="微波通信">2.3.2.1 微波通信</h6>
<p>​ <strong>无线电微波通信</strong>在数据通信中具有重要地位，频率范围为 <span class="math inline">\(300\ MHz\sim 300\ GHz\)</span> （波长 <span class="math inline">\(1\ m\sim1\ mm\)</span>），主要用 <span class="math inline">\(2\sim40\ GHz\)</span> 范围。微波在空间主要是直线传播，会穿过电离层进入宇宙空间，因此不像短波可以反射到地面很远地方。微波通信主要分为<strong>地面微波接力通信</strong>和<strong>卫星通信</strong>两种方式。</p>
<p>​ 由于地球是个曲面，微波直线传输距离受到限制，因此需要在两个通讯点间建立若干中继站，进行<strong>接力</strong>。微波接力通信可传输电话、电报、图像、数据等信息，特点是：</p>
<p>​ (1) 频率高，频段范围宽，通信信道容量大。</p>
<p>​ (2) 受到干扰小，质量高。</p>
<p>​ (3) 建设投资少，见效快，易于跨越山区、江河。</p>
<p>​ 但也有如下缺点：</p>
<p>​ (1) 相邻站必须直视，不可有障碍物。有时一个天线发出信号也会分成几条略有差别路径，造成失真。</p>
<p>​ (2) 有时会受到恶劣天气影响。</p>
<p>​ (3) 隐蔽性和保密性差</p>
<p>​ (4) 大量中继站使用和维护需要耗费大量人力物力。</p>
<h6 id="卫星通信">2.3.2.2 卫星通信</h6>
<p>​ 利用位于约 <span class="math inline">\(3\)</span> 万 <span class="math inline">\(6\)</span> 千公里高空的同步卫星作为中继器。主要优缺点与地面微波通信差不多。但<strong>具有较大传播时延</strong>。费用较高。</p>
<p>​ 由于在同步卫星轨道架设卫星数量有限，因此在卫星上使用不同频段来进行通信，保证大的通信容量资源。</p>
<p>​ 红外通信、激光通信也用于非导引型媒体。可用于近距离笔记本电脑相互传送数据。</p>
<h4 id="信道复用技术">2.4 信道复用技术</h4>
<h5 id="频分复用时分复用与统计时分复用">2.4.1 频分复用、时分复用与统计时分复用</h5>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211436769.png" alt="" /><figcaption>image-20231021143631664</figcaption>
</figure>
<p>​ <strong>频分复用 FDM (Frequency Division Multiplexing)</strong> 的所有用户<strong>在同样时间占用不同带宽资源</strong>。</p>
<p>​ <strong>时分复用 TDM (Time Division Multiplexing)</strong> 则是将时间划分为一段段等长的 TDM 帧，所有用户<strong>在不同时间占用同样的频带宽度</strong>。</p>
<p>​ <strong>复用器(multiplexer)</strong> 和<strong>分用器(demultiplexer)</strong> 成对使用。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211439720.png" alt="" /><figcaption>image-20231021143935600</figcaption>
</figure>
<p>​ <strong>统计时分复用 STDM (Statistic TDM)</strong> 是一种改进的时分复用，能明显提高信道利用率。使用<strong>集中器(concentrator)</strong> 进行复用。集中器也称<strong>智能复用器</strong>。</p>
<p>​ <img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211444418.png" alt="image-20231021144401327" /></p>
<h5 id="波分复用">2.4.2 波分复用</h5>
<p>​ <strong>波分复用 WDM (Wavelength Division Multiplexing)</strong> 就是<strong>光的频分复用</strong>。一根光纤复用几十路或更多路光载波信号，使用<strong>密集波分复用 DWDM (Dense WDM)</strong> 这一名词。</p>
<p>​ <strong>掺铒光纤放大器 EDFA (Erbium Doped Fiber Amplifier)</strong> 不需要进行光电转化直接对光信号进行放大。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211448096.png" alt="" /><figcaption>image-20231021144822976</figcaption>
</figure>
<h5 id="码分复用">2.4.3 码分复用</h5>
<p>​ <strong>码分复用 CDM (Code Division Multiplexing)</strong> 是另一种共享信道方法，也称<strong>码分多址 CDMA (Code Division Multiple Access)</strong> 。每个用户可以在同一时间用同样频带进行通信。<strong>各用户间不会造成干扰，具有很强抗干扰能力，频谱类似于白噪声，不易被敌人发现</strong>。</p>
<p>​ CDMA 中，每一个比特时间再划分为 <span class="math inline">\(m\)</span> 个短的间隔，称为<strong>码片 (chip)</strong>。通常 <span class="math inline">\(m\)</span> 取 <span class="math inline">\(64\)</span> 或 <span class="math inline">\(128\)</span>。一个站如果发送比特 <span class="math inline">\(1\)</span> ，则表示发送该码片，发送 <span class="math inline">\(0\)</span> 则表示该码片的反码。如此每发送 <span class="math inline">\(b\)</span> 个比特，实际信息则<strong>扩频</strong>为 <span class="math inline">\(mb\)</span> 个比特。该种扩频方式属于<strong>直接序列扩频 DDSS (Direct Sequence Spread Spectrum)</strong>。另一种扩频方式为 <strong>调频扩频 FHSS (Frequency Hopping Spread Spectrum)</strong>。</p>
<p>​ CDMA 要求每一个站分配的码片向量各不相同且<strong>相互正交</strong>。实际系统采用<strong>伪随机码序列</strong>。</p>
<p>​ 任何一个码片与自身内积为 <span class="math inline">\(1\)</span>，与其反码内积为 <span class="math inline">\(-1\)</span> 。</p>
<p>​ 结合<strong>全球定位系统 GPS</strong>，所有的站可以同步发送码片序列。若 X 站接受 S 站发送的数据，则需预先知道 S 站特有的码片序列，然后将接受到的信号与 S 站的码片序列作内积，即可解码。</p>
<h4 id="数字传输系统">2.5 数字传输系统</h4>
<p>​ 早期数字传输系统缺点：</p>
<p>​ (1) <strong>速率标准不统一。</strong></p>
<p>​ (2) <strong>不是同步传输。</strong></p>
<p>​ 为解决上述问题，美国于 1988 年首先推出一个数字传输标准，叫<strong>同步光纤网 SONET (Synchronous Optical Network)</strong>。</p>
<p>​ ITU-T 以 SONET 为基础，制定国际标准<strong>同步数字系列 SDH (Synchronous Digital Hierarchy)</strong>。 SDH/SONET 标准的制定及各国的统一运用，实现了数字传输体制上的世界性标准。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310211642004.png" alt="" /><figcaption>image-20231021164224886</figcaption>
</figure>
<h4 id="宽带接入技术">2.6 宽带接入技术</h4>
<h5 id="adsl-技术">2.6.1 ADSL 技术</h5>
<p>​ <strong>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line)</strong> 技术是用数字技术<strong>对现有的模拟电话用户线进行改造</strong>，使它能够承载宽带数字业务。 下行带宽（从 ISP 到用户）远远大于上行带宽（从用户到 ISP ）。传输距离取决于数据率与线径。</p>
<p>​ ADSL 在用户线两端各安装一个 ADSL 调制解调器，我国目前采用的实现方法是 <strong>离散多音调 DMT (Discrete Multi-Tone) 调制技术</strong>。 ADSL 并不能保证固定的数据率。 其最大优点是不需要重新布线。</p>
<p>​ 基于 ADSL 的接入网三大组成部分：<strong>数字用户线接入复用器 DSLAM (DSL Access Multiplexer)</strong>，用户线和用户家中一些设施。 ADSL 调制解调器必须成对使用，把端局和用户家中的 ADSL 调制解调器分别记为 ATU-C（C 代表<strong>端局 (Central Office)</strong>）和 ATU-R （R代表<strong>远端 (Remote)</strong>）。用户电话通过<strong>分离器 (Splitter)</strong> 与 ATU-R 连在一起。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310220934571.png" alt="" /><figcaption>image-20231022093405458</figcaption>
</figure>
<p>​ ADSL 技术也在发展，第二代 ADSL 改进的地方主要为：</p>
<p>​ (1) 通过提高调制效率得到更高的数据率。</p>
<p>​ (2) 采用<strong>无缝速率自适应技术 SRA (Seamless Rate Adaptation)</strong>，自适应调整速率。</p>
<p>​ (3) 改善线路质量测评和故障定位功能。</p>
<p>​ ADSL 技术并不适用于企业，原因在于企业通常需要使用上行信道发送大量数据给用户。为满足企业需要，ADSL 技术有几种变型，记为 xDSL。</p>
<h5 id="光纤同轴混合网">2.6.2 光纤同轴混合网</h5>
<p>​ <strong>光纤同轴混合网 （HFC 网，HFC 是 Hybrid Fiber Coax 缩写）</strong>是基于有线电视网基础上开发的一种居民宽带接入网，主要特点如下：</p>
<p>​ 把原有有线电视网同轴电缆主干部分该换为光纤，从头端连接到<strong>光纤节点 (fiber node)</strong>。光纤节点光信号转化为电信号，通过同轴电缆传输到每个家庭。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310220944400.png" alt="" /><figcaption>image-20231022094401301</figcaption>
</figure>
<p>​ 模拟电视机要能够接受数字电视信号，需要一个<strong>机顶盒 (set-top box)</strong>连接在同轴电缆与电视机之间。若欲接入互联网，还需增加 HFC 网所使用的调制解调器，称为 <strong>电缆调制解调器 (cable modem)</strong>。</p>
<h5 id="fttx-技术">2.6.3 FTTx 技术</h5>
<p>​ <strong>光纤到户 FTTH (Fiber To The Home)</strong> 两个问题：</p>
<p>​ (1) 价格高昂。</p>
<p>​ (2) 一般家庭用户没有这样高的数据率需求。</p>
<p>​ 这种情况下，出现了多种宽带光纤接入方式，称为 FTTx ，x 表示不同的光纤接入地点。</p>
<p>​ 为有效利用光纤资源，光纤干线和用户之间，需要铺设一段中间转换装置即 <strong>光配线网 ODN (Optical Distribution Network)</strong>，使得数十个家庭用户可以共享一根光纤。 五元的逛配线网称为<strong>无源光网络 PON (Passive Optical Network)</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/mlger/Pict/main/202310221001923.png" alt="" /><figcaption>image-20231022100126778</figcaption>
</figure>
<p>​ 光纤干线与<strong>光线路终端 OLT (Optical Line Terminal)</strong> 相连，OLT 把收到的下行数据发往无源的 1:N <strong>光分路器 (splitter)</strong> ，然后以广播方式向所有用户端的<strong>光网络单元 ONU (Optical Network Unit)</strong> 发送。</p>
<p>​ 光配线网采用波分复用，上行和下行分别使用不同的波长。</p>
<p>​ 目前已实现了多种不同的 FTTx， 如 <strong>光纤到路边 FTTC（C 表示 Curb）</strong>、<strong>光纤到小区 FTTZ（Z 表示 Zone）</strong>、<strong>光纤到大楼 FTTB（B 表示 Building）</strong>、<strong>光纤到楼层 FTTF（F 表示 Floor）</strong>、<strong>光纤到办公室 FTTO （O 表示 Office）</strong>、<strong>光纤到桌面 FTTD（D 表示 Desk）</strong>等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/09/08/%E8%AE%A1%E7%BB%8401-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/08/%E8%AE%A1%E7%BB%8401-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">计组01-计算机系统概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-08 16:42:00" itemprop="dateCreated datePublished" datetime="2023-09-08T16:42:00+08:00">2023-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-09 21:09:43" itemprop="dateModified" datetime="2023-12-09T21:09:43+08:00">2023-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="概念">1.1 概念</h4>
<ul>
<li>何为计算机：计算机是指“<strong>通用电子计算机</strong>”
<ul>
<li>通用：不是专用设备</li>
<li>电子：采用电子元器件</li>
<li>数字：信息采用数字化形式表示</li>
</ul></li>
<li>计算机系统：硬件和软件</li>
<li>何为计算机“<strong>组织</strong>”：操作单元及其互联连接
<ul>
<li>对编程人员不可见</li>
<li>包括：控制信号，存储技术等</li>
</ul></li>
<li>何为计算机”<strong>结构</strong>“：直接影响逻辑程序执行的属性
<ul>
<li>对编程人员可见</li>
<li>包括：指令集，表示数据类型的位数等</li>
</ul></li>
</ul>
<p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202309081604546.png" /></p>
<ul>
<li><strong>指令集体系结构</strong>： <strong>ISA</strong> ，有时称为<strong>指令系统</strong>。 ISA 是一种规约，规定如何使用硬件。
<ul>
<li>可执行指令的集合，包含指令格式、操作种类及操作数的规定</li>
<li>指令可以接受的操作数类型</li>
<li>操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、长度和用途</li>
<li>操作数所能存放的<strong>存储空间的大小和编址方式</strong></li>
<li>操作数在存储空间存放时按照<strong>大端还是小端方式存放</strong></li>
<li>指令获取操作数的方式，即<strong>寻址方式</strong></li>
<li>指令执行过程的控制方式，包括<strong>程序计数器（PC）、条件码定义</strong>等</li>
</ul></li>
<li>ISA 与组成之间的关系：计算机组成必须能够<strong>实现 ISA 规定的功能</strong>，如提供 GPR 、标志、运算电路等，<strong>一种 ISA 可以有不同的计算机组成</strong>。</li>
</ul>
<h4 id="计算机简史">1.2 计算机简史</h4>
<h5 id="第一代真空管">1.2.1 第一代：真空管</h5>
<ul>
<li>ENIAC ：第一台<strong>通用</strong>计算机，十进制，手动编程</li>
<li>ABC ：第一台<strong>电子</strong>计算机，不可编程</li>
<li>EDVAC ：冯·诺伊曼架构（普林斯顿架构）</li>
<li>三个基本原则：
<ul>
<li>二进制</li>
<li>存储程序</li>
<li>5个组成部分
<ul>
<li>主存储器：地址和存储内容</li>
<li>算术逻辑单元 / 处理单元：执行信息处理</li>
<li>程序控制单元 / 控制单元：指挥信息处理</li>
<li>输入设备</li>
<li>输出设备</li>
</ul></li>
</ul></li>
</ul>
<h5 id="第二代晶体管">1.2.2 第二代：晶体管</h5>
<ul>
<li>体积更小、更便宜、发热更少</li>
<li>使用高级语言编程，并为计算机提供了系统软件</li>
</ul>
<h5 id="第三代中小规模集成电路">1.2.3 第三代：中小规模集成电路</h5>
<h5 id="第四代超大规模集成电路">1.2.4 第四代：（超）大规模集成电路</h5>
<ul>
<li>思想：
<ul>
<li>将整个电路安装在很小的硅片上，而不是用分立元件搭成的等价电路</li>
<li>晶体管可以通过金属化相互连接，形成电路</li>
</ul></li>
<li><ul>
<li></li>
</ul></li>
</ul>
<h4 id="计算机发展">1.3 计算机发展</h4>
<h5 id="摩尔定律">1.3.1 摩尔定律</h5>
<ul>
<li>价格不变时，单芯片上所能包含的晶体管数量每年翻一番 (1965-1969) / 1970年起减慢为每18个月翻一番</li>
<li>影响：
<ul>
<li>更小尺寸带来更多<strong>灵活性</strong>与<strong>可能性</strong></li>
<li>成本下降</li>
<li><strong>减小电能损耗与冷却要求</strong></li>
<li><strong>芯片间连接更少</strong>，更可靠</li>
</ul></li>
</ul>
<h4 id="计算机性能">1.4 计算机性能</h4>
<h5 id="cpu-性能">1.4.1 CPU 性能</h5>
<ul>
<li>计算机设计主要目标：提升 CPU 性能</li>
<li>系统时钟
<ul>
<li>时钟频率： 1s 内执行基本操作的次数</li>
<li>始终周期：执行每次最基本操作的时间</li>
</ul></li>
<li>指令执行： <span class="math inline">\(CPI_i\)</span> 表示第 <span class="math inline">\(i\)</span> 种指令需要周期数， <span class="math inline">\(I_i\)</span> 表示第 <span class="math inline">\(i\)</span> 类指令条数，则有</li>
</ul>
<p><span class="math display">\[
CPI=\frac{\sum_{i=1}^n(CPI_i \times I_i)}{I_c},I_c=\sum_{i=1}^n I_i
\]</span></p>
<p>​ 执行一个程序的处理时间表示为 <span class="math display">\[
T=I_c\times CPI \times t
\]</span></p>
<ul>
<li>每秒百万条指令（ MIPS ）：</li>
</ul>
<p><span class="math display">\[
MIPS = \frac{I_c}{T\times 10^6}=\frac{f}{CPI\times 10^6}
\]</span></p>
<ul>
<li>每秒百万条浮点操作（ MFLOPS ）：</li>
</ul>
<p><span class="math display">\[
MFLOPS=\frac{N_{floating-point\ op}}{T\times 10^6}
\]</span></p>
<h5 id="性能设计的基本原则">1.4.2 性能设计的基本原则</h5>
<ul>
<li><strong>大概率事件优先原则</strong>：对于大概率事件，赋予优先的处理权与资源使用权。</li>
</ul>
<p><span class="math display">\[
系统加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}
\]</span></p>
<ul>
<li><strong>Amdahl</strong> 定律：
<ul>
<li>部件系统加速比受限于其在系统中所占重要性比例。</li>
<li>性能增加的递减规则：改进越，系统获得效果越小</li>
</ul></li>
</ul>
<p><span class="math display">\[
系统加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}=\frac{1}{(1-局部占比)+
\frac{局部占比}{提升的性能}}
\]</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">计算机网络01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-05 08:33:00" itemprop="dateCreated datePublished" datetime="2023-09-05T08:33:00+08:00">2023-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-09 21:09:43" itemprop="dateModified" datetime="2023-12-09T21:09:43+08:00">2023-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="第1章-概述">第1章 概述</h4>
<h4 id="计算机网络在信息时代的作用">1.1 计算机网络在信息时代的作用</h4>
<p>​ 21世纪<strong>数字化</strong>、<strong>网络化</strong>、<strong>信息化</strong>，形成<strong>以网络为核心的信息时代</strong>。</p>
<p>​ 三大类网络：电信网络、有线电视网络、计算机网络</p>
<p>​ 互联网两个基本特点：<strong>连通性</strong>和<strong>共享</strong></p>
<ul>
<li>连通性：不论多远，都可便捷地交换各种信息</li>
<li>资源共享：信息共享、软件共享、硬件共享</li>
</ul>
<h4 id="互联网概述">1.2 互联网概述</h4>
<p>​ <strong>计算机网络</strong>由若干<strong>节点( node )</strong>和连接这些节点的<strong>链路( link )</strong>组成。</p>
<ul>
<li>节点：计算机、集线器、交换机、路由器等</li>
</ul>
<p>​ 网络把许多计算机连接在一起，<strong>互连网</strong>把许多网络通过路由器连在一起。与网络相连接的计算机称为<strong>主机</strong>。</p>
<p>​ 互联网发展的三个阶段：</p>
<ol type="1">
<li>由 ARPANET 向互连网发展。 20 世纪 70 年代， APRA 开始研究多种网络互连的技术，称为互联网的雏形。 1983 年 TCP/IP 成为 ARPANET 上的标准协议，互联网诞生。 1990 年 ARPANET 关闭。</li>
</ol>
<ul>
<li><strong>internet （互连网）</strong>：指多个网络连接而成的网络</li>
<li><strong>Internet （互联网）</strong>：专有名词</li>
</ul>
<ol start="2" type="1">
<li>第二阶段特点是建成了<strong>三级结构的互联网</strong>。分为<strong>主干网</strong>、<strong>地区网</strong>和<strong>校园网（企业网）</strong>。</li>
<li>第三阶段特点是形成了<strong>多层次 ISP 结构的互联网</strong>。 ISP 译为<strong>互联网服务提供商</strong>。</li>
</ol>
<p>​</p>
<p>​ 计算机网络的分类：</p>
<ul>
<li><strong>LAN</strong> （<strong>局域网</strong>）</li>
<li>特点
<ul>
<li>作用范围小</li>
<li>多用户访问</li>
<li>高速度</li>
<li>错误率可控</li>
</ul></li>
<li>设备
<ul>
<li><strong>Hub</strong> （集线器）：多端口中继器</li>
<li><strong>Bridge</strong> （网桥）：</li>
<li><strong>Switch</strong> （交换机）：</li>
<li><strong>Router</strong> （路由器）：分组交换，转发收到的分组</li>
</ul></li>
<li><strong>WAN</strong> （<strong>广域网</strong>）</li>
<li>特点
<ul>
<li>作用范围大</li>
<li>通过链路传输</li>
<li>速度相对较低</li>
<li>错误率较难控制</li>
</ul></li>
<li>设备
<ul>
<li><strong>Router</strong> （路由器）：</li>
<li><strong>Modem CSU/DSU TA/NT1</strong></li>
</ul></li>
</ul>
<p><strong>Boring！</strong></p>
<h4 id="互联网的组成">1.3 互联网的组成</h4>
<ul>
<li><p>互联网的组成：</p>
<ul>
<li><p>（1）<strong>边缘部分</strong>：由所有连接在互联网上的主机组成，是<strong>用户直接使用</strong>的部分。主机又称为<strong>端系统（end system）</strong></p></li>
<li><p>（2）<strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。这部分是<strong>为边缘部分提供服务的</strong>。</p></li>
</ul></li>
<li><p>端系统间通信方式：客户-服务器模式 and 对等连接方式</p>
<ul>
<li><strong>客户(client)</strong>-<strong>服务器(sever)</strong>模式（C/S模式）
<ul>
<li>客户是服务请求方，服务器是服务提供方</li>
</ul></li>
<li>对等连接方式（P2P）
<ul>
<li>并不区分服务请求方与服务提供方</li>
</ul></li>
</ul></li>
<li><p><strong>电路交换</strong>主要特点：</p>
<ul>
<li><strong>建立连接</strong> → <strong>通话</strong> → <strong>释放资源</strong></li>
<li>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</li>
<li>传输效率较低</li>
</ul></li>
<li><p><strong>分组交换</strong>主要特点：</p>
<ul>
<li>采取<strong>存储转发</strong>技术</li>
<li>发送的整块数据成为<strong>报文</strong>(message)</li>
<li>发送之前，先将报文划分成一个个更小的等长数据段，加上必要控制信息组成的<strong>首部</strong>(header)或<strong>包头</strong>，构成一个<strong>分组</strong>(packet)或<strong>包</strong>。</li>
<li>主机进行信息处理，路由器用来转发分组，即进行分组交换。</li>
</ul></li>
</ul>
<h4 id="计算机网络的类别">1.5 计算机网络的类别</h4>
<ul>
<li>按照网络的作用范围分类：
<ul>
<li><strong>广域网 WAN </strong>：</li>
<li><strong>域域网 MAN </strong>：作用范围一般是一个城市。可以为一个或几个单位所有，也可以是一种公用设施，用来将多个局域网进行互连。</li>
<li><strong>局域网 LAN </strong>：</li>
<li><strong>个人区域网 PAN</strong>：把属于个人的设备用无线技术连接起来</li>
</ul></li>
<li>按网络使用分类：
<ul>
<li><strong>公用网</strong>(public network)</li>
<li><strong>专用网</strong>(private network)</li>
</ul></li>
<li><strong>用来把用户接入到互联网的网络</strong>：
<ul>
<li><strong>接入网 AN</strong>：又称<strong>本地接入网</strong>或<strong>居民接入网</strong>。</li>
</ul></li>
</ul>
<h4 id="计算机网络的性能">1.6 计算机网络的性能</h4>
<h5 id="性能指标">1.6.1 性能指标</h5>
<ul>
<li><strong>速率</strong>：数据传送速率，也成为<strong>数据率</strong>或<strong>比特率</strong>。提到网络速率，往往指<strong>额定速率</strong>，而非运行速率。单位 bps 。</li>
<li><strong>带宽</strong>：
<ul>
<li><strong>信号具有的频带宽度</strong>，单位是<strong>赫兹</strong>，表示<strong>某信道允许通过的信号频带范围</strong>。</li>
<li>网络中某通道传输数据的效率，即<strong>最高数据率</strong>，单位是 bps 。</li>
</ul></li>
<li><strong>吞吐量</strong>：表示单位时间内通过某个网络的实际数据量</li>
<li><strong>时延</strong>：数据从网络一端传送到另一端的时间，组成：
<ul>
<li><strong>发送时延</strong>：主机或路由器发送数据帧所需时间</li>
<li><strong>处理时延</strong>：</li>
<li><strong>排队时延</strong>：数据帧进入路由器后需排队等待处理，等待的时间成为排队时延</li>
<li><strong>传播时延</strong>：信道中传播的时间</li>
</ul></li>
</ul>
<p><span class="math display">\[
传播时延=\frac{信道长度(m)}{电磁波在信道上传播速率(m/s)}
\]</span></p>
<ul>
<li><strong>时延带宽积</strong>： 传播时延与带宽乘积</li>
<li><strong>往返时间 RTT </strong>：数据在信道中往返一次所需时间</li>
<li><strong>利用率</strong>：</li>
</ul>
<p><span class="math display">\[
D=\frac{D_0}{1-U}
\]</span></p>
<h4 id="计算机网络体系结构">1.7 计算机网络体系结构</h4>
<h5 id="osi-七层协议">1.7.1 OSI 七层协议</h5>
<ul>
<li><strong>物理层</strong>：管理通信设备和网络媒体之间的互联互通，<strong>规范</strong>链接的电气和功能<strong>规格</strong>。</li>
<li><strong>数据链路层</strong>：<strong>通过物理链接提供数据传输链路</strong>。</li>
<li><strong>网络层</strong>： 在两终端之间进行<strong>路径选择</strong>。</li>
<li><strong>传输层</strong>：负责网络中<strong>端到端的网络通信</strong>，为虚拟电路的建立、维护、终止，传输故障检测及恢复，以及信息流的控制提供机制。</li>
<li><strong>会话层</strong>：<strong>创建</strong>、<strong>管理</strong>和<strong>维护</strong>会话。同步表示层实体间的会话并<strong>管理其间的数据交换</strong>。提供高效的<strong>数据传输</strong>、<strong>服务类别</strong>以及会话、演示及应用层的<strong>异常报告功能</strong>。</li>
<li><strong>演示层</strong>：保证不同系统的信息交换，涉及<strong>数据编码</strong>、<strong>格式转换</strong>、<strong>数据加密</strong>。将多种数据格式转化成通信中采用的标准表示形式。</li>
<li><strong>应用层</strong>：OSI 协议最高层，离用户最近，<strong>为用户应用程序提供网络服务</strong>，不为其它层提供服务。</li>
</ul>
<h5 id="五层协议的体系结构">1.7.2 五层协议的体系结构</h5>
<ul>
<li><strong>应用层</strong>：通过进程间的交互来完成特定网络应用，交互数据称为报文。不同网络应用需要有不同的应用层协议。</li>
<li><strong>运输层</strong>：主要使用两种协议： <strong>TCP、UDP</strong> 。</li>
<li><strong>网络层</strong>：把运输层产生的报文段或数据封装成<strong>包</strong>或<strong>分组</strong>进行传送。由于网络层使用 IP 协议，因此分组也叫 <strong>IP 数据报</strong>。</li>
<li><strong>数据链路层</strong>：将网络层交下来的 <strong>IP 数据报</strong>组装成帧，每一帧包括数据和必要的控制信息。</li>
<li><strong>物理层</strong>：上传数据单位为比特。</li>
</ul>
<h5 id="tcpip-四层协议">1.7.3 TCP/IP 四层协议</h5>
<p><img src="https://raw.githubusercontent.com/mlger/Pict/main/202309111635872.png" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/31/%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5/" class="post-title-link" itemprop="url">相信未来</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-31 22:40:00" itemprop="dateCreated datePublished" datetime="2023-07-31T22:40:00+08:00">2023-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-22 23:15:00" itemprop="dateModified" datetime="2024-01-22T23:15:00+08:00">2024-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%97%E6%AD%8C/" itemprop="url" rel="index"><span itemprop="name">诗歌</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em>作者：食指</em></p>
<p>当蜘蛛网无情地查封了我的炉台，</p>
<p>当灰烬的余烟叹息着贫困的悲哀，</p>
<p>我依然固执地铺平失望的灰烬，</p>
<p>用美丽的雪花写下：相信未来。</p>
<p>​</p>
<p>当我的紫葡萄化为深秋的露水，</p>
<p>当我的鲜花依偎在别人的情怀，</p>
<p>我依然固执地用凝霜的枯藤，</p>
<p>在凄凉的大地上写下：相信未来。</p>
<p>​</p>
<p>我要用手指那涌向天边的排浪，</p>
<p>我要用手掌 那托起太阳的大海，</p>
<p>摇曳着曙光那支温暖漂亮的笔杆，</p>
<p>用孩子的笔体写下：相信未来。</p>
<p>​</p>
<p>我之所以坚定地相信未来，</p>
<p>是我相信未来人们的眼睛——</p>
<p>她有拨开历史风尘的睫毛，</p>
<p>她有看透岁月篇章的瞳孔。</p>
<p>​</p>
<p>不管人们对于我们腐烂的皮肉，</p>
<p>那些迷途的惆怅，失败的苦痛，</p>
<p>是寄予感动的热泪，深切的同情，</p>
<p>还是给以轻蔑的微笑，辛辣的嘲讽。</p>
<p>​</p>
<p>我坚信人们对于我们的脊骨，</p>
<p>那无数次地探索、迷途、失败和成功，</p>
<p>一定会给予热情、客观、公正的评定，</p>
<p>是的，我焦急地等待着他们的评定。</p>
<p>​</p>
<p>朋友，坚定地相信未来吧，</p>
<p>相信不屈不挠的努力，</p>
<p>相信战胜死亡的年轻，</p>
<p><strong>相信未来，热爱生命。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/06/Codeforces%20Round%20877%20(Div.%202)/" class="post-title-link" itemprop="url">Codeforces Round 877 (Div. 2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-06 19:48:00" itemprop="dateCreated datePublished" datetime="2023-07-06T19:48:00+08:00">2023-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-09 21:09:43" itemprop="dateModified" datetime="2023-12-09T21:09:43+08:00">2023-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>传送门：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1838">Codeforces Round 877 (Div. 2)</a></p>
<h5 id="a.-blackboard-list">A. Blackboard List</h5>
<p><strong>题意：</strong></p>
<p>​ 给定包含两个数字的初始，然后进行 <span class="math inline">\(n-2\)</span> 次操作，每次操作从序列中取出两个数字（不能取同一个），将其差之绝对值加入序列，最终得到一长度为 <span class="math inline">\(n\)</span> 的序列。</p>
<p>​ 现给定最终序列（乱序）， 求最初始数字之一。</p>
<p><strong>题解：</strong></p>
<p>​ 由于新加入数字必为非负数，因此序列中的负数必定是初始数字。</p>
<p>​ 若全为非负数，由于 <span class="math inline">\(|a-b|\leq|a|\)</span> 且 <span class="math inline">\(|a-b|\leq |b|\)</span> ，因此最大数字必为初始数字。</p>
<h5 id="b.-minimize-permutation-subarrays">B. Minimize Permutation Subarrays</h5>
<p><strong>题意：</strong></p>
<p>​ 给定一 <span class="math inline">\(n\)</span> 的排列。交换两数字的位置，使得交换后序列中，能够成排列的连续子序列数目最少。</p>
<p><strong>题解：</strong></p>
<p>​ <span class="math inline">\(1\)</span> 与 <span class="math inline">\(2\)</span> 之间夹 <span class="math inline">\(n\)</span> ，这样能够使得数目恒为 <span class="math inline">\(1\)</span> ，是为最少。讨论即可</p>
<h5 id="c.-no-prime-differences">C. No Prime Differences</h5>
<p><strong>题意：</strong></p>
<p>​ 将 <span class="math inline">\(n*m\)</span> 之内的正整数排成一个 <span class="math inline">\(n*m\)</span> 矩阵，使得矩阵中任意两相邻元素差值的绝对值不为素数。</p>
<p><strong>题解：</strong></p>
<p>​ 先考虑 <span class="math inline">\(m\geq 5\)</span> 时，将 <span class="math inline">\(\{0, 1*n, 2*n, 3*n, ... (m-1)*n\}\)</span> 排成一列。以下是一种合适的构造方法。</p>
<p>​ 设 <span class="math inline">\(p=\lfloor \frac{m-1}{2}\rfloor\)</span> 考虑两个序列 <span class="math display">\[
\{0, 1*n, 2*n, ...p*n \} \\
\{(p+1)*n, (p+2)*n, ... (m-1)*n\}
\]</span> ​ 然后将两序列合成（下面序列的元素依次插入上面序列的空隙）。</p>
<p>​ 若 <span class="math inline">\(m=4\)</span> ，则可构造为 <span class="math inline">\(\{1*n, 3*n, 0, 2*n\}\)</span></p>
<p>​ 设该序列为 <span class="math inline">\(A\)</span> ，则最终矩阵可构造为 <span class="math inline">\(p_{i, j}=i+A_j\)</span></p>
<p><strong>code：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i += <span class="number">2</span>) &#123;</span><br><span class="line">        add[i] = now;</span><br><span class="line">        now += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">4</span>) &#123;</span><br><span class="line">        add[<span class="number">0</span>] = n;</span><br><span class="line">        add[<span class="number">1</span>] = <span class="number">3</span> * n;</span><br><span class="line">        add[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        add[<span class="number">3</span>] = <span class="number">2</span> * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) cout &lt;&lt; i + add[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="d.-bracket-walk">D. Bracket Walk</h5>
<p><strong>题意：</strong></p>
<p>​ 一括号序列，从最左侧出发可以随意向左右移动（不超边界），最终停在最右侧。途经符号构成一括号序列，若该括号序列合法，则称原序列 walkable 。</p>
<p>​ 现给定一括号序列 <span class="math inline">\(s\)</span> ， <span class="math inline">\(q\)</span> 次单点修改，要求求出每次单点修改后，序列是否 walkable 。</p>
<p><strong>题解：</strong></p>
<p>​ walkable 的必要条件首先是长度 <span class="math inline">\(n\)</span> 为偶数。</p>
<p>​ 其次构造一序列 <span class="math inline">\(A\)</span> ，包含所有的 <span class="math inline">\(i\)</span> ，使得</p>
<ul>
<li><p><span class="math inline">\(s_i=&#39;)&#39;\)</span> 且 <span class="math inline">\(i\)</span> 为奇数</p></li>
<li><p><span class="math inline">\(s_i=&#39;(&#39;\)</span> 且 <span class="math inline">\(i\)</span> 为偶数</p>
<ol type="1">
<li>若 <span class="math inline">\(A\)</span> 为空，则显然圆括号序列为 <span class="math inline">\(()\)</span> 重复若干次，必定 walkable。</li>
<li>若 <span class="math inline">\(A\)</span> 非空，其中最小数字为奇数，则意味着序列开头为 <span class="math inline">\(()()()...())\)</span> ，必定非法</li>
<li>若 <span class="math inline">\(A\)</span> 非空，其中最大数字为偶数，则意味着序列末尾为 <span class="math inline">\((()()()\)</span> ，必定非法</li>
<li>剩余情况， <span class="math inline">\(A\)</span> 中最小数字 <span class="math inline">\(m\)</span> 为偶数， 最大数字 <span class="math inline">\(M\)</span> 为奇数，则 <span class="math inline">\(m, M\)</span> 之间符号数为偶数，其中左右括号奇偶性相同。则在 <span class="math inline">\(m-1,m\)</span> 这两个位置产生足够多的 <span class="math inline">\(((....\)</span> 来消除右侧的 <span class="math inline">\()\)</span>，然后在<span class="math inline">\(M,M+1\)</span> 两个位置产生对应数量的 <span class="math inline">\())\)</span> 补齐即可。合法。</li>
</ol></li>
</ul>
<p><strong>code：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;str](<span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="built_in">return</span> ((str[p - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) ^ (p &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) s.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2 9</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; pos;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(pos)) s.<span class="built_in">erase</span>(pos);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">insert</span>(pos);</span><br><span class="line">        str[pos - <span class="number">1</span>] = <span class="string">&#x27;(&#x27;</span> + <span class="string">&#x27;)&#x27;</span> - str[pos - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((*s.<span class="built_in">begin</span>() &amp; <span class="number">1</span>) || !(*s.<span class="built_in">rbegin</span>() &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="e.-count-supersequences">E. Count Supersequences</h5>
<p><strong>题意：</strong></p>
<p>​ 求满足以下条件的 <span class="math inline">\(b\)</span> 序列个数：</p>
<ul>
<li><span class="math inline">\(b\)</span> 序列含 <span class="math inline">\(m\)</span> 个正整数，所有数字均在 <span class="math inline">\([1,k]\)</span> 内</li>
<li><span class="math inline">\(b\)</span> 序列删去若干个数，顺序不变，可以得到 <span class="math inline">\(a\)</span> 序列</li>
</ul>
<p><strong>题解：</strong></p>
<p>​ 考虑 <span class="math inline">\(dp\)</span></p>
<p>​ <span class="math inline">\(f[i][j]\)</span> 表示含 <span class="math inline">\(i\)</span> 个正整数删去后可得到长度为 <span class="math inline">\(j\)</span> 的 <span class="math inline">\(a\)</span> 序列前缀的序列数，则有如下转移方程： <span class="math display">\[
f[i][j]=
\begin{cases}
f[i-1][j-1]+(k-1)*f[i-1][j],\ j&lt;n \\
f[i-1][j-1]+k*f[i-1][j], \ j=n
\end{cases}
\]</span> ​ 发现该转移方程与 <span class="math inline">\(a\)</span> 无关。</p>
<p>​ 因此将 <span class="math inline">\(a\)</span> 序列设为 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(1\)</span> ，然后作差法。</p>
<p>​ 最终答案为： <span class="math display">\[
k^m-\sum_{i=0}^{n-1}\binom{m}{i}(k-1)^{m-i}
\]</span> <strong>code：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">auto</span> quick_pow = [&amp;mod](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">            a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">quick_pow</span>(k, m);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans -= <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>(k - <span class="number">1</span>, m - i) % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        ans += mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * (m - (i+<span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">        now = <span class="number">1ll</span> * now * <span class="built_in">quick_pow</span>((i+<span class="number">1</span>), mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
      <meta itemprop="name" content="Lg">
      <meta itemprop="description" content="青春无悔不死">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mlger">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/03/Educational%20Codeforces%20Round%20150%20(Div.%202)/" class="post-title-link" itemprop="url">Educational Codeforces Round 150 (Div. 2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-03 20:20:00" itemprop="dateCreated datePublished" datetime="2023-07-03T20:20:00+08:00">2023-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-27 17:30:24" itemprop="dateModified" datetime="2024-02-27T17:30:24+08:00">2024-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>传送门：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1841">Educational Codeforces Round 150 (Rated for Div. 2)</a></p>
<h5 id="a.-game-with-board">A. Game with Board</h5>
<p><strong>题意：</strong></p>
<p>​ 给定初始序列为 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(1\)</span> ，两人轮流行动，每次可以选择序列中若干个相同的数，剔除，并将他们的和加入序列。第一位无法行动的一方获胜。假设二人都绝对聪明，试问先手是否必胜。</p>
<p><strong>题解：</strong></p>
<p>​ 分类讨论一下：</p>
<ul>
<li><span class="math inline">\(2\leq n \leq 4\)</span>，有限轮模拟易得后手必胜。</li>
<li><span class="math inline">\(n\geq5\)</span> ，则先手取 <span class="math inline">\(n-2\)</span> 个 <span class="math inline">\(1\)</span>， 后手只能取 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> ， 之后序列变为 <span class="math inline">\(\{n-2, 2\}\)</span> ，故先手必胜。</li>
</ul>
<p><strong>code：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c.-ranom-numbers">C. Ranom Numbers</h5>
<p><strong>题意：</strong></p>
<p>​ A, B, C, D, E 分别代表 <span class="math inline">\(1, 10, 100, 1000, 10000\)</span> 。给定一由大写字母 ABCDE 组成的串，对于某一字符，若字符串后方有严格大于它的字符，则符号为负，否则为正。字符串权值为所有字母乘上符号的权值之和。</p>
<p>​ 现可以修改至多一字符，求可能的最大权值。</p>
<p><strong>题解：</strong></p>
<p>​ 据说 DP 和贪心均可，这里思路是 DP 。</p>
<p>​ 为了方便起见，先将字符串反转，规则也对应修正。</p>
<p>​ 然后设计状态： <span class="math inline">\(F[i][j][0/1]\)</span> 代表到第 <span class="math inline">\(i\)</span> 位，目前前缀最大值为 <span class="math inline">\(j\)</span> ，且已经/未修改的最大权值。 <span class="math inline">\(i\)</span> 这一位用滚动数组滚掉，然后枚举状态的转移即可。</p>
<p>​ 复杂度 <span class="math inline">\(O(nMK)\)</span> ，其中 <span class="math inline">\(M=5, K=2\)</span> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> f[<span class="number">2</span>][<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[<span class="number">0</span>][i][<span class="number">0</span>] = f[<span class="number">0</span>][i][<span class="number">1</span>] = -inf;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">        p ^= <span class="number">1</span>;</span><br><span class="line">        q ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) f[p][i][<span class="number">0</span>] = f[p][i][<span class="number">1</span>] = -inf;</span><br><span class="line">        <span class="type">int</span> x = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;   <span class="comment">//i-1位前缀最大</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) &#123;   <span class="comment">//</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">5</span>; y++) &#123;</span><br><span class="line">                    <span class="type">int</span> nt = t + (y != x);</span><br><span class="line">                    <span class="type">int</span> nj = <span class="built_in">max</span>(y, j);</span><br><span class="line">                    <span class="keyword">if</span> (nt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        f[p][nj][nt] = <span class="built_in">max</span>(f[p][nj][nt], f[q][j][t] + (y == nj ? digit[y] : -digit[y]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">0</span>]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[p][i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="d.-pairs-of-segments">D. Pairs of Segments</h5>
<p><strong>题意：</strong></p>
<p>​ 给定 <span class="math inline">\(n\)</span> 条线段，用区间表示 <span class="math inline">\([l,r]\)</span> 。若 <span class="math inline">\(n\)</span> 为偶数，且可以将 <span class="math inline">\(n\)</span> 条线段分为 <span class="math inline">\(\frac{n}{2}\)</span> 对， 每一对线段相交， 不成一对的线段相交，则称其 <strong>beautiful</strong> 。现问至少删去多少线段，使得剩下的线段可以 <strong>beautiful</strong> 。</p>
<p><strong>题解：</strong></p>
<p>​ <span class="math inline">\(n\)</span> 比较小。一开始以为是 <span class="math inline">\(dp\)</span> 但怎么都消除不了后效性。实际解法是——直接暴力。</p>
<p>​ 首先考虑两对线段，共四条。不成对线段不相交的等价条件可以表示为： 成对线段取并集，所得两条线段不相交。</p>
<p>​ 因此可以直接求出 <span class="math inline">\(C_n^2\)</span> 对线段中，相交对的并集。然后找出尽量多的并线段，使其互不相交即可。互不相交可以天然保证每条线段至多用了一次。求不相交线段数目，这里用了动态开点线段树。</p>
<p>​ 复杂度 <span class="math inline">\(O(n^2logn)\)</span> 。</p>
<p><strong>code：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> lc[N &lt;&lt; <span class="number">4</span>], rc[N &lt;&lt; <span class="number">4</span>], dat[N &lt;&lt; <span class="number">4</span>], cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">    dat[p] = <span class="built_in">max</span>(dat[p], val);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid) <span class="built_in">update</span>(lc[p], l, mid, k, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rc[p], mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || u &gt; v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(lc[p], l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(rc[p], mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">Line</span>(n);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; Uline;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; Line[i].first &gt;&gt; Line[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a.first, b.first) &lt;= <span class="built_in">min</span>(a.second, b.second);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> uni = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="built_in">min</span>(a.first, b.first), <span class="built_in">max</span>(a.second, b.second));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(Line[i], Line[j])) <span class="keyword">continue</span>;</span><br><span class="line">            Uline.<span class="built_in">pb</span>(<span class="built_in">uni</span>(Line[i], Line[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(Uline.<span class="built_in">begin</span>(), Uline.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line: Uline) &#123;</span><br><span class="line">        <span class="type">int</span> rem = <span class="built_in">query</span>(rt, <span class="number">-1</span>, inf, <span class="number">-1</span>, line.first - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">update</span>(rt, <span class="number">-1</span>, inf, line.second, rem + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rem + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - (ans &lt;&lt; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h5 id="e.-fill-the-matrix">E. Fill the Matrix</h5>
<p><strong>题意：</strong></p>
<p>​ 给定一 <span class="math inline">\(n*n\)</span> 的矩阵，其中第 <span class="math inline">\(i\)</span> 列的第 <span class="math inline">\(1-a_i\)</span> 行为黑格， <span class="math inline">\(a_i-n\)</span> 行为白格，仅白格可以填数。当一个格填数 <span class="math inline">\(x\)</span> 且其正右侧格填数 <span class="math inline">\(x+1\)</span> 时，贡献一 beauty 。填入 <span class="math inline">\(1-m\)</span> 共 <span class="math inline">\(m\)</span> 个数，求最大 beauty 值。</p>
<p><strong>题解：</strong></p>
<p>​ 看起来似乎比其他几道好想很多。上层所有线段都是下层线段的子集，因此从最底层线段开始枚举，填数，分裂即可。</p>
<p>​ 这里还是用的线段树。注意细节。</p>
<p><strong>code：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dat[N &lt;&lt; <span class="number">2</span>], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>) (dat[p] = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    dat[p] = <span class="built_in">min</span>(dat[p &lt;&lt; <span class="number">1</span>], dat[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= l &amp;&amp; r &lt;= v) <span class="keyword">return</span> dat[p];</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, ans = N;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>, l, mid, u, v));</span><br><span class="line">    <span class="keyword">if</span> (v &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, u, v));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">pos</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] = n - a[i];</span><br><span class="line">        pos[a[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pos[i] 值为i的位置集合(补上界n+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pos[i].<span class="built_in">pb</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(pos[i].<span class="built_in">begin</span>(), pos[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r, pre_min;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre_min) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">pre_min</span>(pre_min) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node X) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l &lt; X.r - X.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ask(l, r) ask(1, 1, n, l, r)</span></span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">1</span>, n, <span class="number">0</span>));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p.l == p.r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> min_num = <span class="built_in">Ask</span>(p.l, p.r);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>) &gt; m) &#123;</span><br><span class="line">            ans += (m / (p.r - p.l + <span class="number">1</span>) * (p.r - p.l)) + <span class="built_in">max</span>(<span class="number">0ll</span>, m % (p.r - p.l + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m -= <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l + <span class="number">1</span>);</span><br><span class="line">            ans += <span class="number">1ll</span> * (min_num - p.pre_min) * (p.r - p.l);</span><br><span class="line">            <span class="type">int</span> L = std::<span class="built_in">lower_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.l) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> R = std::<span class="built_in">upper_bound</span>(pos[min_num].<span class="built_in">begin</span>(), pos[min_num].<span class="built_in">end</span>(), p.r) - pos[min_num].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> pre_l = p.l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt; R; pre_l = pos[min_num][i] + <span class="number">1</span>, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre_l &lt; pos[min_num][i]) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, pos[min_num][i] - <span class="number">1</span>, min_num));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre_l &lt;= p.r) q.<span class="built_in">push</span>(<span class="built_in">node</span>(pre_l, p.r, min_num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lg"
      src="https://cdn.luogu.com.cn/upload/image_hosting/oti64lgi.png">
  <p class="site-author-name" itemprop="name">Lg</p>
  <div class="site-description" itemprop="description">青春无悔不死</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zjy1412.github.io/" title="https:&#x2F;&#x2F;zjy1412.github.io" rel="noopener" target="_blank">耀耀</a>
        </li>
    </ul>
  </div>

      </div>

      
      <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
      <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
      <div class="widget-wrap">
          <div id="myCanvasContainer" class="widget tagcloud">
              <canvas width="250" height="250" id="resCanvas" style="width:100%">
                  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">专业课</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F/" rel="tag">系统</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97%E6%AD%8C/" rel="tag">诗歌</a><span class="tag-list-count">4</span></li></ul>
              </canvas>
          </div>
      </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-06 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lg</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
//    window.MathJax = {
//      loader: {
//
//        source: {//
//          '[tex]/amsCd': '[tex]/amscd',
//          '[tex]/AMScd': '[tex]/amscd'
//        }
//      },
//      tex: {//
//        inlineMath: {'[+]': [['$', '$']]},
//
//        tags: 'ams'
//      },
//      options: {
//        renderActions: {
//          findScript: [10, doc => {
//            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
//              const display = !!node.type.match(/; *mode=display/);
//              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
//              const text = document.createTextNode('');
//              node.parentNode.replaceChild(text, node);
//              math.start = {node: text, delim: '', n: 0};
//              math.end = {node: text, delim: '', n: 0};
//              doc.math.push(math);
//            });
//          }, '', false],
//          insertedScript: [200, () => {
//            document.querySelectorAll('mjx-container').forEach(node => {
//              let target = node.parentNode;
//              if (target.nodeName.toLowerCase() === 'li') {
//                target.parentNode.classList.add('has-jax');
//              }
//            });
//          }, '', false]
//        }
//      }
//    };
    window.MathJax = {
      tex2jax: {
        inlineMath: [ ['$$','$$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
